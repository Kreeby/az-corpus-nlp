QAFQAZ
UN VERS TET
Borland
C++
il
Obyektyönlü
Proqramla rma
Az rbaycan Respublikas  T hsil
Nazirliyinin 20.10.2006-c  il tarixli, 760
sayl mri il  d rs v saiti kimi tövsiy
edilmi dir.
Etibar Seyidzad
BAKI - 2007
Elmi redaktor : t.e.n., dos. X lil smay lov
 (“Qafqaz” Universiteti)
yçil r  : f.-r.e.d., prof. F xr ddin sayev
 (“Qafqaz” Universiteti)
 t.e.n., Abzetdin Adamov
 (“Qafqaz” Universiteti)
            Korrektor : fa Seyidova
            Dizayner : Sahib Kaz mov
Seyidzad  Etibar Vaqif o lu
Borland C++ il
Obyektyönlü Proqramla rma
 Seyidzad  E.V. 2007
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
M Ü N D  R  C A T
3
MÜND CAT
I F L ................................................................................. 9
OBYEKTYÖNLÜ PROQRAMLA DIRMA ................. 9
1.1 Proqram Layih ndirm ....................................... 9
1.2 Proqram Xüsusiyy tl ri ....................................... 10
1.3 Modul Strukturunun rtl ri............................... 14
1.4 Obyektyönlü Proqramla rman n saslar ...... 15
II F L .............................................................................. 25
C-D YEN KL R C-Y LAV R ............. 25
2.1 Eyni Adl  Müxt lif Arqumentli Funksiyalar...... 25
2.2 Operatorlar n T yini............................................. 31
2.3 Aktiv Qiym t Verm k.......................................... 33
2.4 T qdimat (Referans) Tip T yinedicisi................. 37
2.5 Gizl nmi  D yi nl ri Görm k......................... 41
2.6 C++-da Prototipl rin T yin Edilm si .................. 43
2.7 Struktur Tipl r ...................................................... 44
2.8 rh Operatoru...................................................... 45
2.9 new v  delete Opratorlar .................................... 46
2.10 inline Makrolar .................................................. 49
III F L............................................................................. 51
OBYEKTL R ................................................................. 51
3.1 Obyekt N dir?....................................................... 51
3.2 Layih ndirici ...................................................... 55
3.3 Müraci t Haqq ..................................................... 57
Etibar Seyidzad
4
3.4 Yoxedici (Destructor) ........................................... 62
3.5 Standart Obyekt Tipl ri........................................ 67
3.6 Layih ndirici Üz rin  Yükl ....................... 67
3.7 Obyektl  M nims tm ...................................... 74
IV F L............................................................................. 85
OBYEKTL N XÜSUS YY TL ........................ 85
4.1 Obyekt Üzvl ri Olan Obyektl r .......................... 85
4.2 Friend (Dost) T yinedicisi.................................... 90
4.3 Obyekl rin Operatorlara Yükl nm si................. 97
4.4 this Lokal D yi ni ........................................... 101
4.5 Ümumi Ortaq D yi nl r ................................ 103
4.6 Statik (Static) Funksiyalar .................................. 107
4.7 const Funksiyalar ............................................... 112
4.8 ç-iç  T yinl r...................................................... 112
4.9 Obyekt Göst ricil ri............................................ 115
4.10 Obyekt Massivi ................................................. 117
V F L............................................................................ 121
OBYEKT TÖR TM K............................................... 121
5.1. Tör tm liyyat ........................................... 121
5.2 Sinifl rin Tör dilm si......................................... 122
5.3 Müraci t Haqlar  v  Nüfuz Etm ...................... 127
5.4 Dinamik Yükl ............................................... 129
5.5 Qaydal  Funksiyalar ........................................... 133
5.6 Misallar................................................................ 138
5.6.1 Curve............................................................. 138
5.6.2 LineDemo ..................................................... 143
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
M Ü N D  R  C A T
5
5.7 C++ Metod Ça  Sistemi................................. 161
5.8 Mövcud Olandan Tör n Sinifl r ................... 164
VI F L........................................................................... 169
ABLONLAR HAZIRLAMAQ.................................. 169
6.1 ablonlar.............................................................. 169
6.2 ablon Funksiyalar ............................................. 172
6.3 ablon Obyektl r ................................................ 176
VII F L ......................................................................... 181
AXINLAR ..................................................................... 181
7.1 Ax n N dir?......................................................... 181
7.2 Standart Ax nlar.................................................. 181
7.3 Ax nlara Nizamlanm  M lumat Yaz lmas ..... 185
7.3.1 Geni lik N zar ti ......................................... 185
7.3.2 Yerl  N zar ti........................................ 187
7.3.3 Bo luq N zar ti............................................ 188
7.3.4 Tam dl rin saslar na N zar t............ 189
7.3.5 H qiqi  N zar t ............................. 190
7.4 Ax nlardan Nizamlanm  M lumat Oxunmas 192
7.5 S hvl  N zar t................................................. 195
7.6 Fayl Üz rind ki Ax nlar..................................... 195
7.6.1 Fayla Yazma ................................................. 196
7.6.2 Fayldan Oxuma............................................ 200
7.7 Obyektl r v  Ax nlar .......................................... 202
VIII F L........................................................................ 211
CLASS TABXANASI.............................................. 211
Etibar Seyidzad
6
8.1 Container Class Kitabxanas .............................. 211
8.2 T yin Olunmu  Sinifl r ...................................... 212
8.3 T yinl r v  Tipl r ............................................... 214
8.3.1 Tip v  Sinif Kodlar ...................................... 214
8.3.2 S hv Kodlar n T yini................................ 216
8.3.3 Ba q Fayllar  v  T yin Edilmi  Sinifl r.... 217
8.4 Sinifl r.................................................................. 218
8.4.1 Object ............................................................ 218
8.4.2 Error .............................................................. 227
8.4.3 Sortable ......................................................... 228
8.4.4 String............................................................. 229
8.4.5 BaseDate ....................................................... 232
8.4.6 Date ............................................................... 235
8.4.7 BaseTime....................................................... 239
8.4.8 Time .............................................................. 242
8.4.9 Association ................................................... 244
8.5 M lumatlar Sturukturu Sinifl ri........................ 247
8.5.1 Container ...................................................... 247
8.5.2 Stack .............................................................. 251
8.5.3 Deque ............................................................ 255
8.5.4 Queue............................................................ 258
8.5.5 PriorityQueue............................................... 259
8.5.6 Collection...................................................... 261
8.5.7 List................................................................. 263
8.5.8 DoubleList .................................................... 265
8.5.9 HashTable..................................................... 268
8.5.10 Btree ............................................................ 270
8.5.11 Bag............................................................... 277
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
M Ü N D  R  C A T
7
8.5.12 Set ................................................................ 278
8.5.13 Dictionary ................................................... 278
8.5.14 AbstractArray............................................. 279
8.5.15 Array ........................................................... 283
8.5.16 SortedArray ................................................ 285
8.6 Yenil yicil r (Iterators)....................................... 290
8.6.1 DoubleListIterator........................................ 293
8.7 Misal .................................................................... 294
Etibar Seyidzad
8
ÖN SÖZ
Bu kitabda obyektyönlü proqramla rman n
saslar ,  Borland C++ proqramla rma dilinin
xüsusiyy tl ri rh edilmi dir.
saitd n obyektyönlü proqramla rma
öyr nm k ist n t r, mü lliml r, h mçinin
proqramç lar faydalana bil rl r. V sait mümkün q r
sad  dild  yaz lm r. Kitabdak  mövzular misallarla
mü ayi t olunmu dur ki, bu da mövzunu asan
nims  köm k edir.
Onu  da  qeyd  ed k  ki,  kitab  respublikam zda  bu
mövzuda az rbaycan dilind  yaz lm  ilk v saitdir. Buna
gör  d  kitabda bir çox yeni terminl rin istifad sind
tinlikl r qar ya ç xm  v  bu ç tinlikl rin aradan
qald lmas na c hd göst rilmi dir.
Kitab n haz rlanmas nda laz mi rait yaratd na
gör  Qafqaz Universitetinin r hb rliyin , d rli
sl tl rin  gör  f.-r.e.d., professor F xr ddin sayev ,
t.e.n., dossent X lil smay lova, t.e.n. Abzetdin Adamova
shih etdiyin  gör  V fa Seyidovaya, dizayner Sahib
Kaz mova, kitab n çap nda göst rdikl ri d st  gör
Mü fiq brahimova v  S di bdürr hmanova öz s mimi
kkürümü bildirir m.
Mü llif
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
9
I F L
OBYEKTYÖNLÜ
PROQRAMLA DIRMA
1.1 Proqram Layih ndirm
Kompüter texnologiyas n paralel inki af ed n iki
sas sah si vard r: texniki vasit r (hardware) v
proqram t minat  (software).  Texniki  vasit r  n  q r
sür tl  inki af ets  d , proqram t minat  il  t chiz
edilm n heç bir faydas  olmaz. Proqram n texniki
vasit r olmadan i sini d  dü ünm k olmaz. Lakin
yax  texniki vasit  olmazsa, uy un olaraq yax  proqram
da yaz lmaz. stifad çil rin ist dikl rini texniki
vasit rl  yerin  yetirm ri üçün is  h r zaman yax
proqram t minat na ehtiyac vard r.
Proqram t minat  çox miyy tli olan, lakin bunun
qiym ti çox gec ba a dü ül n bir mövzu olmu dur. Yax n
keçmi  kompüter ehtiyac  olan xsl r i rini gör
bil k proqram, sonra da bu proqram  i k bir
kompüter axtar r v  proqram  kompüterin ayr lmaz bir
xüsusiyy ti kimi görürdül r. Bu bir növ kompüter
sat lar n ehtiyac duyulan proqramlar  özl rinin
Etibar Seyidzad
 10
yazmalar ndan v  öz kompüterl ri xaricind  bu proqram
satmamalar ndan qaynaqlan rd . Haz rda is  müst qil
proqramla rma il  m ul olan firmalar n qurulmas
bu s hv dü ünc ni aradan qald rm r. Bu h mçinin
proqram t minat  v  texniki vasit rin bir-birind n f rqli
bir ey olduqlar  h qiq tinin anla lmas  t min
etmi dir.
1.2 Proqram Xüsusiyy tl ri
Do ruluq (correctness)  – veril n tap qlar n
tam olaraq yerin  yetirilm sidir. Proqram
layih ndirm n vv l onun hans  tap qlar
yerin  yetir yini mü yy n etm k laz md r.
Proqram haz r olduqdan sonra bu t yin olunan
xüsusiyy ti tam t min etm lidir;
Dayan ql q (robustness)  – gözl nilm z
hadis r n tic sind  proqram n icras
silm li, s hv liyyatlar  yerin
yetirm lidir. Proqram, n yax  halda olsa
bel , üz rin  qoyulan tap qlardan ba qa i ri
görm lidir. Proqramç n s hvl rin  gör
proqram n icras n k silm si üçün t dbirl r
görülm lidir;
Geni bilm k (extendibility)  – g kd
veril n tap qlar n d yi dirilm si v  ya
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
11
yenil rinin lav  edilm si asan olmal r. Bunun
üçün:
- sad  layih r haz rlanaraq mür kk b
layih rd n qaçmaq laz md r (design
simplicity);
- proqram  bir  m rk zd n  as  olaraq  idar
etm k zin  modul sturukturundan istifad
ed k yerli bir idar  etm  formas  seçilm lidir
(decentralization).
krar istifad  olunma (reusability)  –
haz rlanan layih nin, yaz lan proqram n v  ya
heç olmazsa modullar n ba qa proqramlar
find n istifad  edil  bilm sidir. Buna layih
daxilind  istifad  edil n elementl rin yeni
layih  d  istifad  edil  bilm sini lav  etm k
laz md r;
Uy unluq (compatibility)  – proqram n müxt lif
kompüter sisteml rind  ortaq xüsusiyy tl
malik olmas r. Bunun üçün müxt lif standartlar n
tbiq edilm si laz md r:
- lumatlar fayl  format n uy unlu u;
- lumatlar strukturunun uy unlu u.
Menyu, dialoq, r sm, düym  kimi istifad çi
mühitinin (user interface) uy unlu u;
Etibar Seyidzad
 12
nb rin istifad  edilm si (efficiency)  –
kompüterin malik oldu u bütün avadanl qlar
li kild  tam istifad  etm sidir. stifad
ed  bilm dikd  d  dig r proqramlar üçün
istifad siz qalmas na yol verm sidir;
Da nabilm  (portability)  – bir proqram
haz rlanm  oldu u kompüterd n ba qa dig r
kompüterl rd  d  istifad  oluna bilm lidir. Bu iki
formada ola bil r:
- Qaynaq uy unlu u (source compatible)  –
proqram n yaz ld liyyat sistemind n
ba qa bir sistem  da b yenid n komplyasiya
olunaraq i si;
- kilik kod uy unlu u (binary compatible)  –
proqram n yaz ld  mühitd  komplyasiya
olunaraq icra oluna bil n fayl (executable file)
ld  edildikd n sonra ba qa bir mühit
da naraq i dilm si. Proqram n
kmill dirilm si bax ndan sli sas
götürül k proqram kodunun da nabil n
olmas r.
zar t oluna bilm  (verifiability)  – bir
proqram n s hv hallarla qar la mas  zaman
onun icras n davam etm sin  v  h tta heç icra
olunmamas na s b olan s hvl r ortaya ç xd
zaman istifad çiy  v  proqramç ya s hvin hans
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
13
bd n ba  verdiyi mövzusunda kifay t q r
lumat n verilm sidir;
Taml q (integrity)  – icaz siz müdaxil r v
yi dirm r qar nda proqram, m lumatlar,
fayl kimi proqram komponentl rinin
qorunmas r. M n, m lumatlar v  ya indeks
fayllar n itm si (silinm si) zaman  proqram icra
olunark n bunu mü yy nl dirib bildirir;
Asan istifad  edilm  (easy of use)  –
proqramdan istifad  ed n xsin onu asanl qla
öyr nm si, istifad  ed  bilm si, n tic rini
dqiq ed  bilm si, s hvl rini düz ld  bilm sidir;
Birlikd  i k (interoperability)  – bir
proqram n ehtiyac  oldu u ba qa bir proqram
ça ra bilm si xüsusiyy tidir. Bu halda iki
proqram ard l olaraq i kl  b rab r bir-biri
il  m lumat mübadil si ed  bilm lidirl r.
Yuxar da göst ril n rtl ri t min etm k sas n
proqramç  müh ndisin v zif si olmaqla b rab r, modul
strukturundan istifad  etm k geni  bilm , krar istifad
olunma, uy unluq, da na bilm  probleml rini h ll etm
imkan verir. Bu halda n az  b zi proqram modullar
yenid n yazma a ehtiyac qalm r.
Etibar Seyidzad
 14
1.3 Modul Strukturunun rtl ri
Parçalanabilm  (modular decomposability)  –
bir problemi alt hiss  ay raraq
layih ndirm kdir. M n, riyazi
liyyatlar n yerin  yetirildiyi bir proqramda
massivl rin istifad  edilm si üçün bir massiv
modulu t yin ed k massivl laq dar
liyyatlar n ham  bu modulda yazmaq.
Eyni kild  ehtiyac olarsa, matris, vektor,
kompleks d kimi t yinl r üçün d  modul
yazaraq problemi kiçik hiss  ay rmaq;
Birl diril bilm  (modular composability)  –
bir-birind n x rsiz haz rlanan modullar n bir
yer  y lmas  zaman  çat mayan v  ya tam
olmayan modullar n olmamas r;
Ayd nl q (modular understandability)  –
müxt lif xsl r t find n yaz lmas na
baxmayaraq oxundu u zaman proqram n ayd n
olmas r. Proqram n yenid n bax lmas  v  ya
kmill dirilm si zaman  çox miyy tli olan
bu xüsusiyy ti saxlamaq üçün modul
proqram n yaz lmas ndan ba qa proqram
daxilind  n yin n  üçün istifad  edildiyinin, bu
istifad  n tic sind  n  olaca n ayd n bir
kild rh olunmas  laz md r;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
15
Qorunma (modular protection)  – bir modulun
 formas na v  m lumatlara dig r bir
modulun icaz  verilmi  hallardan ba qa
müdaxil  etm si, yaz lan modullar n ümumi
tl ri olmas na baxmayaraq bunlar n bir-
birind n f rql ndirilm si laz md r;
Davaml q (modular continuity)  – problemin
yinind ki kiçik d yi iklikl r bir v  ya bir neç
hiss nin d yi sin  s b olark n proqram
sturukturu kimi istifad  olunan modullar
aras ndak  vasit r (m n, funksiya
prototipl ri) d yi dirilm lidir.
ndi d  modullulu un t min olunmas  üçün istifad
olunacaq obyektyönlü proqramla rman n
xüsusiyy tl rini gözd n keçir k.
1.4 Obyektyönlü Proqramla rman n
saslar
Bir sistem daxilind  müxt lif xarakterli obyektl r
ola bil r. Bu obyektl rin tamamil  bir-birind n f rqli
xüsusiyy tl ri il  b rab r, eyni v  ya ox ar xüsusiyy tl ri
 vard r. Xüsusiyy tl r v  davran lar n müxt lif
olamalar na baxmayaraq eyni imkanlara malik ola
bil rl r.
Etibar Seyidzad
 16
n, bir idar  kompüter, telefon, faks, katib ,
mur, müdir kimi obyektl r ola bil r. sas n bunlar n
r biri bir obyektdir. H r birinin öz funksiyas  vard r.
Lakin ümumi xüsusiyy tl ri d  vard r. Katib , m mur,
müdir h r biri bir insand r. Bu insan olma xüsusiyy tidir.
r biri mü ssis  müxt lif m bl  maa la i yirl r.
Gördükl ri i  ümumi bir i dir, lakin h r birinin öz i i
vard r. st k eyni, davran lar is  müxt lifdir. rini icra
ed rk n istifad  etdikl ri m lumatlar da eyni d
rqlidir.
Bu b nz tm  il obyekt - mü yy n i ri yerin  yetir n,
bu m qs dl  d  müxt lif funksiyalardan ibar t olan bir
strukturdur. Bu struktur daxilind  d yi nl r ola bil r.
Lakin sas n v zif sini mü yy n ed k funksiyalar
rkibind  saxlay r. Bu xüsusiyy paketl dirm
(encapsulation) deyilir.
Bunun dig r bir xüsusiyy ti d  paketl dirilc k
funksiyalar n nec  i yi mü yy n edilm n, sad
nec  istifad  edil yi mü yy n edil  bil r ki, bu da
vacibdir. Buna da müc rr dl dirm (abstraction) deyilir.
Paketl dirm  v  müc rr dl dirm , obyekti mü yy n
etm k üçün kifay t olan iki funksiyad r.
Obyekl rin dig r xüsusiyy tl rind n biri d  tör
xüsusiyy tidir. Obyekt t yin edil rk n, vv lc n t yin
olunmu  ba qa bir  obyekti  özün  baza olaraq seç  bil r.
Bu hal yeni t yin olunan obyektin özün  baza seçdiyi
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
17
obyektin xüsusiyy tl rind n istifad  etm  imkanlar na
uy un g lir, bununla b rab r yeni obyektin baza obyekti
il  eyni xüsusiyy t da mas na s b olur.
Yeni obyekt yeni xüsusiyy tl r qazana bildiyi kimi,
bu xüsusiyy tl ri t kmill dir  v  d yi dir  d  bil r. Bu
xüsusiyy tör  (derivation), xüsusiyy tl ri alma a is
miras alma (inheritance) ad  verilir.
Buna a dak  misal  göst  bil rik:
Bir avtomobil t mirçisi avtomobil r ngl  (hava
rça il ), lehiml  v  karbürator sazlama i rini yerin
yetirmi  olsun.
Avtomobil T mirçisi
Bu avtomobil t mirçisi obyektidir. Bu avtomobil
mirçisinin üç o lu oldu unu v  onlar n h r birini
yeti dirdikd n sonra, bir sah  üzr  ixtisasla rd  f rz
ed k.
- ngl
- Lehiml
- Karbürator Sazlama
Etibar Seyidzad
 18
Burada Avtomobil R ngsaz , Avtomobil Qaynaqç
 Avtomobil Elektriki tör  obyektl rdir. Avtomobil
mirçisi is  baza obyektidir. Tör  obyektl r
(Avtomobil R ngsaz , Avtomobil Qaynaqç  v
Avtomobil Elektriki) baza obyektinin, y ni Avtomobil
mirçisinin xüsusiyy tl rini göst kl r. Uy un
olaraq avtomobil r ngl k, lehiml k v
karbürator t nziml kl r.
Avtomobil R ngsaz ndan avtomobili r ngl sini
ist diyimiz zaman, o avtomobili hava f rças  il
ngl kdir. Lakin Avtomobil T mirçisi bu i i yaln z
adi f rça il  gör kdi. Avtomobil T mirçisi il
Avtomomobil R ngsaz n gördükl ri i  r ngl  i idir.
Avtomobil T mirçisi Avtomobil R ngsaz
Karbürator Sazlay
Avtomobil Qaynaqç
- R ngl
- Lehiml
- Karbürator Sazlama
- R ngl  (Hava f rças  il )
- Lehiml  (Oksigen qayna
il )
- Elektrik ri
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
19
Avtomobil R ngsaz n adi f rça il  r ngl yi
bacarmas na baxmayaraq hava f rças  il  r ngl yir. Lakin
ist diyi zaman adi f rça il  d  r gl  bil r.
Eyni kild  Avtomobil Qaynaqç  da oksigen
qayna  il  lehiml yir. Avtomobil T mirçisi is  sad
qövs qayna  il  lehiml  bilir. Avtomobil Qaynaqç
eyni zamanda r ngl  i rini d  bacar r. Bu qabiliyy ti
Avtomobil T mirçisind n miras alm  v  sad  f rça il
ngl yi bacar r.
Ücüncü qolu t kil ed n Avtomobil Elektriki is
tamamil  ba qa bir xüsusiyy  malikdir. Avtomobil
mirçisi elektrik i rini gör  bilm diyi halda Avtomobil
Elektriki bu i ri gör  bilir. Avtomobil Elektriki eyni
zamanda r ngl , lehiml  v  karbürator t nziml
rini Avtomobil T mirçisind n öyr ndiyi q r gör
bilir. T bii ki, r laz m g rs , Avtomobil Elektrikinin
n, r ngl  bacar n l v edilm si uy un
görül rs , heç bir i  görm si t min oluna bil r.
Burada növb ti üç xüsusiyy t n ri c lb edir:
1. Tör nmi  obyektl r baza obyektinin
xüsusiyy tl rini qoruyub saxlayaraq istifad  ed
bilirl r;
2. Tör nmi  obyektl r tör ndikl ri obyektl rin
(baza obyektl rinin) xüsusiyy tl rini d yi dir
bilirl r;
Etibar Seyidzad
 20
3. Tör nmi  obyektl r yeni xüsusiyy tl r qazana
bilirl r.
Bir sistem daxilind  ist r bir obyektd n tör nmi
obyektl r olsun, ist rs  d  bir-birind n f rqli obyektl r
olsun, bu obyektl rin ox ar xüsusiyy tl ri ola bil r v  bu
xüsusiyy tl r eyni adla verilir. Bu da eyni adl , lakin
müxt lif obyektl rin üzvü olan obyektl rin meydana
lm sin  s b olur. Bu hal obyektl r aras ndak
ox arl qlar  göst rir. Buna ox arl q (polymorphism)
deyilir. slind  bir obyektd n t n sinifl r aras nda
ox arl n olmas  vacibdir.
Obyektyönlü proqramla rmada obyektl rin malik
olduqlar  m lumatlar  v  funksiyalar  qoruyaraq, birba a
istifad  etm  icaz  verm ri, ba qa bir alt
xüsusiyy tdir. Burada miras qoyma n ksi olan bir
liyyatdan söhb t gedir. Bir obyekt b zi
xüsusiyy tl rini saxlay b sad  özü istifad  edir. Dig r
obyektl rin istifad  etm sin  icaz  verm z v  ya
hdudla rar. Bu, dört müxt lif hal il rh edil  bil r:
1. Xüsusi (private)  – bir  üzv  m lumat n  v  ya
funksiyan n yaln z üzvü oldu u obyekt daxilind
istifad  olunmas ;
2. Qorunmu  (protected) – bir üzv d yi ninin v
ya funksiyas n üzvü oldu u obyekt xaricind  o
obyektd n tör n obyektl rin sad  istifad
ed  bilm si;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
21
3. Ümumi  (public)  – bir üzvün bütün obyektl r
find n ortaq istifad  edilm si;
4. Dost  (friend)  – bir  obyektin  ba qa  bir  obyekti
dost elan ed k üzvl rinin ham n bu obyekt
find n istifad sin  icaz  verm si.
Obyektyönlü proqramla rmada dig r sas
xüsusiyy t is dinamik laq ndirm dir (dinamic
binding). Bu xüsusiyy tl  tör n bir obyektin ünvan
tör ndiyi obyektl rd n birinin göst rici (pointer)
yi nin  m nims tm k mümkündür. Bu halda
ünvan  m nims dil n obyekt, göst ricisin
nims dildiyi baza obyekti kimi davranacaq, h mçinin
özün xsus xüsusiyy tl rini d  göst kdir.
Bu  hal  bel rh  etm k  olar:  m n,  bir
mü ssis nin bax  bölm sin  bir avtomobil t mirçisi i
al nacaqd r. Bu i  (göst rici d yi n) Avtomobil
mirçisind n ba qa Avtomobil R ngsaz , Avtomobil
Qaynaqç  v  Avtomobil Elektriki d  müraci t ed  bil r
 bu i  al na bil r. Çünki, bunlar n kökünd  avtomobil
mirçiliyi durur. M lumdur ki, bu i  al nacaq xsin
avtomobil r ngl , lehiml  v  karbürator
nziml  i rind n ba  ç xacaqd r. Bu i i üç
müt ssis birlikd  d  gör  bil r.
ndi d  bu i  Avtomobil Qaynaqç n al nd
rz ed k. Bu halda t mirçid n r ngl k t b olunarsa,
o f rçadan istifad  ed k r ngl  i ini yerin
Etibar Seyidzad
 22
yetir kdir. Çünki t mirçi kimi i  götürül n Avtomobil
Qaynaqç , Avtomobil T mirçisind n öyr ndiyi (miras
ald ) f rça il  r ngl yi bacar r. Lakin lehiml k
b olundu unda, oksigen qayna  il  lehiml kdir.
Çünki sas bacard  i  d  el  budur.
r bu i  Avtomobil Elektriki al nsayd , qaynaq
rini yaln z qövs qayna  il  gör kdi. Çünki, miras
alma yolu il  öyr ndiyi lehiml  i i budur. Bu,
ngl  v  karbürator t nziml  i ri d  ola bil r.
Avtomobil Elektrikinin bildiyi daha bir ey vard r ki, bu
da elektrik i ridir. Lakin t mirçi kimi i  al nan
Avtomobil Elektrikind n bu i i görm si t b olunmaz.
Avtomobil Elektriki i  al nark n görül k i r aras nda
elektrik i ri yoxdur.
Bir obyektin baza obyektinin göst ricisin
nims dil k baza obyekti xüsusiy tl ri göst rm sin
dinamik laq ndirm  deyilir. Ümumi m qs dli
alqoritml rin (s ralama, axtarma kimi) t tbiqind  v  ya
eyni xüsusiyy tli müxt lif xarakterli obyektl rin birg
istifad sind  istifad  oluna bil r. Yaln z bu xüsusiyy t
üçün tör tm liyyat n olmas n vacibliyin  diqq t
edin.
Tör nm  xüsusiyy ti il laq dar olaraq daha bir
xüsusiyy t obyektin bir obyektd n deyil, bir neç
obyektd n tör nmi  olmas r. Buna çoxbazal q v  ya
çoxdan tör nm  (multi inheritance) deyilir. Burada obyekt
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTYÖNLÜ PROQRMALA DIRMA
23
tör ndiyi bütün obyektl rin xüsusiyy tl rini göst rir.
n, dar çi v  Avtomobil T mirçisi obyektl rind n
tör n Müdir obyekti h m dar çi, h m d  Avtomobil
mirçisi kimi davrana bilir. Y ni r ngl , karbürator
nziml , i çi al b maa  ver  bilir. Bu xüsusiyy tl ri
yi dir  v  ya yeni xüsusiyy tl ri t rkibin  ala bilir.
Çox bazal  obyektl rin miyy ti dinamik
laq ndirm  öz ksini tap r. Çoxbazal  obyekt
tör ndiyi bütün obyektl rin göst ricil rin  m nims dil
bil r. Bu, m nims tm  n tic sind sad
nims dildiyi obyektin xüsusiyy tl rini göst rir.
n, Müdir obyekti Avtomobil T mirçisi
göst ricisin  m nims dil rs , Avtomobil T mirçisi kimi
davran r. Yox r dar çi göst rcisin  m nims dil rs ,
dar çi kimi davran r.
Obyektyönlü proqramla rman n sas
anlay lar ndan biri d  proqramlar daxilind  mü yy n
libl rin ( ablonlar n) haz rlan b bir neç  d  istifad
oluna bilm sidir. Bu xüsusiyy ablonlama (template)
deyilir. ablonlar yaz lm  bir proqram kodunun ox ar
hallar üçün istifad  edilm sini ifad  edir. M n, tam
dl rd n ibar t olan bir massivi s ralamaq üçün
proqram kodunun eyni zamanda h qiqi dl ri, s tirl ri
 h tta yeni tör dil k obyektl ri d  s ralaya bil k bir
kild  yaz la bilm si ablonlama xüsusiyy tidir.
Etibar Seyidzad
 24
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
25
II F L
C-D  YEN KL R V  C-Y
LAV R
2.1 Eyni Adl  Müxt lif Arqumentli
Funksiyalar
C v  dig r yüks k s viyy li proqramla rma
dill rind  arqument kimi daxil edilmi  eyni tipli iki
qiym td n n böyüyünü geri qaytaran bir funksiya
yazmaq üçün növb ti üsullardan istifad  etm k olar:
Birinci üsul -  istifad  olunan n böyük aral ql  tip  gör
bir funksiya yaz b, alt tipl ri bu tip  çevirm kd n
ibar tdir. M n,
long double Max(long double A, long double B)
{ return A < B ? B : A; }
long double LD;
double D;
int I;
char C;
Etibar Seyidzad
 26
yin edildikd n sonra
LD = Max(12, 18);
D = (double)Max(12, 18);
I = (int)Max(12, 18);
C = (char)Max(‘C’, ‘H’);
tip çevirm  operatorlar  il  yerin  yetiril  bil r. Bel  ki,
I = (int)Max(12e7, 18.36);
liyyat  heç bir s hv göst rm n komplyasiya
olunur. Lakin icra olunark n mü yy n x talar ba  ver
bil r. S tirl rin n böyüyünün t yin edilm si üçün bu
funksiyadan istifad  etm k olmaz. Bu halda komplyator
hvl ri ola bil r. Bu cür s hvl r miyy tsiz say lsa da,
proqram s hv icra olunur.
kinci üsul - h r tip üçün ayr  bir funksiya
yazmaqdan ibar tdir. Bu halda C qaydalar na uy un
olaraq h r bir funksiya üçün ayr  addan istifad  etm k
laz m g kdir.
#include <string.h>
char Max_char(char A, char B)
{ return A < B ? B : A; }
int Max_int(int A, int B)
{ return A < B ? B : A; }
double Max_double(double A, double B)
{ return A < B ? B : A; }
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
27
char *Max_string(char* A, char* B)
{ return strcmp(A, B) < 0 ? B : A; }
Bu cür t yinl r bütün tipl r üçün yaz la bil r. Bu d
yuxar da göst ril n t yin  uy un olaraq
D = Max_double(12, 18);
I = Max_int(12, 18);
C = Max_char(12, 18);
klind  olmal r. Bu halda tip çevirm liyyat n
aradan qalxm  oldu una diqq t edin. Bunun zind
yaln z funksiya ad  d yi mi dir. Bu üsulla
I = Max_int(12e7, 18.36);
kimi liyyatlar vv lc n yerin  yetirm k d
mümkündür. Böyük funksiyalar n makro s viyy  t yin
edilm sinin proqram n böyüklüyünü art rd  n
ald qda, bu n yax  üsul say la bil r. Bu zaman hans  tip
üçün hans  funksiyadan istifad  edil yini çox yax
bilm k laz md r.
Lakin C++-da bir funksiya eyni adla bir neç  d
yin oluna bil r. H r t yind  funksiya dig rind n f rqli
olaraq müst qil bir funksiya kimi i yir. Bu hadis
üz rin  yükl  v  ya üst-üst  qoyma (overloading) ad
verilir. Bir ad üz rin  iki v  ya daha art q ad
yükl ks , bu
Etibar Seyidzad
 28
overload funksiya_ad ;
klind  göst rilir. Bu kild  tan mlanm  h r
funksiyan n arqument siyah ndak  tip ard ll  daha
vv l t yin edilmi  eyni adl  funksiyalar n arqument
siyah ndak  tip ard ll  il  eyni olmal r.
Buna gör Max funksiyas  a dak  kimi t yin
etm k olar:
// MAXDEC.CPP
#include <string.h>
#include <stdio.h>
overload Max;
int Max(int A, int B)
{ return A < B ? B : A; }
char Max(char A, char B)
{ return A < B ? B : A; }
double Max(double A, double B)
{ return A < B ? B : A; }
char *Max(char* A, char* B)
{ return strcmp(A, B) < 0 ? B : A; }
Bu t yind n sonra
C = Max('C', 'H'); // char C
I = Max(12, 18); // int I
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
29
D = Max(12.4, 18.9); // double D
S = Max("String", "Massiv"); // char *S
nims tm liyyatlar  yerin  yetirm k olar. Bu
nims tm rin yerin  yetirilm sind n sonra h r Max
funksiyas  dig rl rind n f rql nir.
Bel  ki,
char C = Max('C', 'H');
int I = Max(12, 18);
double D = Max(12.4, 18.9);
char *S = Max("String", "Massiv");
char Max(char, char);
int Max(int, int);
double Max(double, double);
char Max(char*, char*);
prototipli funksiyalar ça r. Hans  funksiyan n
ça laca n t yin edilm sind  funksiyan n ad ndan
ba qa, arqument siyah ndak  tipl r v  tipl rin ard ll
sas olmal r. Funksiyan n qaytard  tip is  bir n tic
olaraq ortaya ç r. M n,
int funksiya(char);
char funksiya(int);
int funksiya(int, int);
parametr siyah ndak  müxt lifliy  gör  bir-birind n
rqli olan üç funksiyan  t yin ed rk n,
int funksiya(char);
char funksiya(char);
Etibar Seyidzad
 30
parametr siyah ndak  tip ard ll  eyni oldu u üçün
eyni funksiyan  t yin edir. Qaytar lan tipl r müxt lif
oldu una gör  s hv a kar edilir v  bu cür t yin q bul
edilmir.
Üst-üst  yükl  il laq dar t yin etm
liyyatlar  yerin  yetiril rk n tip t yinedicil rind
müxt lif tipl rin oldu una diqq t edilm lidir. Y ni
int funksiya(int);
int funksiya(unsigned int);
kimi iki tip t yin edil rk n
int funksiya(int);
int funksiya(signed int);
eyni funksiyan  iki d  t yin etm  m nas na g ldiyi
üçün s hv verir. Eyni kild
int funksiya(int);
int funksiya(const int);
bir-birind n f rqli iki t yin olmas na baxmayaraq, const
yeni tip t kil etm diyi üçün birlikd  istifad  edil
bilm zl r.
Yeni t yin edilmi  tipl rd n istifad  ed rk n
funksiyalar üz rin  yükl  aparmaq olar. M n,
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
31
struct Tarix {
           int gun, ay, il;
};
yinind n sonra
struct Tarix Max(struct Tarix A, struct Tarix B)
{ if( A.il == B.il )
      if(A.ay == B.ay )
          return A.gun >= B.gun ? A : B;
      else return A.ay >= B.ay ? A : B;
   else return A.il >= B.il ? A : B;
}
yin edil  bil r.
Borland C++-da overload göst rilm n d  bütün
funksiyalar n üz rin  yükl  apar la bil r. Komplyator
Siz  bununla laq dar x rdarl q ed rs , buna
miyy t verm yin v  ya #progma warn –ovl
drektivind n istifad  ed k bu tipli x rdarl q
lumatlar n qar  ala bil rsiniz.
2.2 Operatorlar n T yini
C++-da  operatorlar  da  funksiya  kimi  q bul  etm k
olar.
Etibar Seyidzad
 32
c = a + b; yerin  c = operator+ (a, b);
c = a - b; yerin  c = operator– (a, b);
c = a + b – d * 4; yerin  c = operator– (operator + (a, b),
      operator* (d, 4));
ifad rini yazmaq olar. Burada operator+, operator- v
operator* h r biri bir funksiyad r. C++-da operator sözü
funksiya ad r. Bu addan istifad  ed rk n ondan sonra
bir operator i ar si yazmaq laz md r. C v C++-da t yin
olunmu  operator i ar ri C dv l 2.1-d  göst rilmi dir.
dv l 2.1 Operatorlar
Operator ar si Operator Ad
+ - * / % Riyazi operator
= += -= *= /= %= ^= &= |= <<= >>= nims tm  operatorlar
^ & | Bit s viyy  operatorlar
<< >> Sürü dürm  operatorlar
< > == != <= >= ! && || ntiqi operatorlar
++ - - + - Art rma/azaltma operatorlar
() Cevirm  operatoru
[] Massiv operatoru
& Ünvan operatoru
sizeof Uzunluq operatoru
new, delete Yadda  operatoru
Operatorlara funksiya kimi bax ld  üçün
funksiyalar üçün n rd  tutulmu  olan üst-üst
yükl liyyat  operatorlar üçün d  istifad  edil
bil r. Bununla da yeni t yin olunan tipl r üçün operator
funksiyalar n üz rin  yükl k olar.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
33
struct vector { double x, y, z; }
double operator*(struct vector A, struct vector B)
{ return A.x * B.x + A.y * B.y + A.z * B.z; }
Bu misalda t yin olunmu vector tipind n as  olaraq iki
vektorun skalyar hasilini hesablayan vurma operatoru da
yin edilmi dir.
struct vector V1 = {1, 2, 3};
struct vector V2 = {7, 8, 2};
double skalyarhasil = V1 * V2;
tirl ri proqram s tirl ridir. Lakin h  tan mlanmad
üçün
struct vector V3 = V1 + V2;
kimi bir s tir istifad  edil  bilm z. Ancaq vector
strukturu üçün toplama operatoru t yin edildikd n sonra
istifad  oluna bil r.
2.3 Aktiv Qiym t Verm k
Müst vi üz rind  qövs, m rk zi (Cx, Cy), radiusu
(R), ba lan c (Sa) v  son (Ea) buca  il  t yin olunur.
Bel  bir qövsün uzunlu u 2 R(Ea-Sa)/360 düsturu il
hesablan r.
Etibar Seyidzad
 34
#include <math.h>
double Qovs(double Cx, double Cy, double R, double Sa,
   double Ea)
{ return 2*M_PI*R*(Ea-Sa)/360; }
Bu cür bir Qovs alt proqram  yaz la bil r. r bu
proqram hiss si tam bir çevr  üçün istifad  olunarsa, Sa
yerin 0, Ea yerin  is 360 yaz lmal r.
double Tam = Qovs(Cx, Cy, R, 0, 360);
double Yarim = Qovs(Cx, Cy, R, 0, 90);
Bel  ki, çevr  çox istifad  olunan oldu u üçün 0 v
360 qiym tl ri vv lc n m lum parametrl rdir. H r
 bu qiym tl ri göst rm  ehtiyac yoxdur. Çevr
üçün
double Tam = Qovs(Cx, Cy, R);
klind  istifad  olunmas  daha q sa yoldur. Bunu
funksiya üz rin  yükl  üsulundan istifad  ed k
yenid n yazmaq mümkündür. Lakin bunun yerin
funksiya prototipi t yin edil rk n,
double Qovs(double Cx, double Cy, double R,double Sa = 0.0,
double Ea = 360.0);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
35
kilnd  parametrl aktiv qiym t verm k  d
mümkündür. Bu t yind n sonra radiusu 50.0 olan  bir
çevr  t yin olunark n
double Tam = Qovs(Cx, Cy, 50.0);
istifad  olunarsa, komplyator vv lc
Qovs(double, double, double)
kimi t yin olunmu  bir funksiya axtaracaqd r. Tapmad
zaman da
Qovs(double, double, double, ...)
kimi v  ilk üç qiym td n sonrak lara aktiv qiym t
verilmi  bir funksiya axtaracaqd r. Tapd  zaman ilk
qiym tl ri d  yazaraq bu funksiyan  ça racaqd r. Y ni
komplyator
double Tam = Qovs(Cx, Cy, 50.0);
mrini
double Tam = Qovs(Cx, Cy, 50.0, 0.0, 360.0);
kimi istifad  ed kdir.
Etibar Seyidzad
 36
Bu funksiyan n bütün parametrl rin  aktiv qiym t
verm k mümkündür. Ya da misalda oldu u kimi, sad
mü yy n parametrl  aktiv qiym t m nims dil  bil r.
Lakin aktiv qiym t verilmi  h r parametrin sa ndak
parametr  d  aktiv qiym t verilm lidir. M n,
void misal(double x = 0, double y = 0); //do ru
void misal(double x, double y = 0); //do ru
void misal(double x = 0, double y); //s hv
Üçüncü misal, aktiv qiym t verilmi x parametrinin
sa ndak  bir parametr  (y parametrin ) aktiv qiym t
verilm diyi üçün istifad  oluna bilm z.
Daha bir hal  n  almaq laz md r ki, aktiv qiym t
veril k ld  edil n prototipl rl , üz rin  yükl
apar lan funksiyalardan ld  edil n prototipl r eyni
deyill r.
double Qovs(double Cx, double Cy, double R, double Sa =
0.0, double Ea = 360.0):
yini il  b rab r
double Qovs(double Cx, double Cy, double R);
double Qovs(double Cx, double Cy, double R, double Sa);
double Qovs(double Cx, double Cy, double R, double Sa,
double Ea);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
37
funksiyalar  birlikd  t yin edil  bilm zl r, çünki,
anla lmazl q yarana bil r.
Qovs(100.0, 120.0, 40.0);
funksiyas n ça lmas  zaman  hans  funksiyaya
müraci t edil yi b lli olmur.
2.4 T qdimat (Referans) Tip
yinedicisi
C-d  bir d yi nin ba qa bir d yi ni göst rm si
üçün göst rici (pointer), m lumatlar n emal  üçün d
göst rici liyyatlar  (pointer aritmetics) anlay ndan
istifad  olunur.
int X = 10, Y = 20;
int *P;
P = &X;
*P = 12; /*  X = 12;  */
X = 14; /*  *P = 14; */
P = &Y;
*P=12; /*  Y = 12;  */
X = 15;
C++-da bu anlay  yerin  t qdimat tipi t yin edilir.
Bu tipdli t yinl rd  d yi n ba qa bir d yi nl
laq ndirilir. Lakin göst ricil rd n f rqli olaraq bu
laq  pozularaq ba qa bir laq  qurula bilm z.
Etibar Seyidzad
 38
int X;
int &R = X; /* & i ar si R-in t qdimat d yi ni
oldu unu göst rir. X m nims dilm si il  d
R v  X bir-biri il laq ndirilir. */
X = 20; /* R = 20; */
R = 40; /* X = 40; */
R++; /* X++;  ++ operatorunun R-in qiym tini bir
vahid art rd na, sonrak  qiym tini
göst rm diyin  diqq t edin. */
qdimat d yi nl rinin t yini zaman  hans  d yi n
il  ba  olduqlar n bildirilm si m cburidir. T qdimat
yi ni sabitl  d laq ndiril  bil r.
int &RR = 2;
qiq td  is  komplyator müv qq ti bir d yi n
yin ed k ona 2 qiym tini  m nims dir  v  sonra  bu
yi nin t qdimat d yi ni t find n göst rilm sini
min edir. Bel  ki,
int Muveqqeti = 2;
int &RR = Muveqqeti;
Lakin proqramç n bu müv qq ti d yi ni
istifad  etm  haqq  yoxdur.
Bu çür t yin etm  müxt lif vaxtlarda eyni m qs d
üçün istifad  edilmi  d yi nl ri birl dirm  köm k
edir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
39
/* REF.CPP */
#include <conio.h>
#include <stdio.h>
double Zaman = 0;
void ZamanYaz()
{ printf("Zaman = %lf\n", Zaman); }
/* ************************************** */
double &Z = Zaman;
void ZamanArtir()
{ Z += 6; }
int main()
{  clrscr();
   ZamanYaz();
   ZamanArtir();
   ZamanYaz();
   ZamanArtir();
   ZamanYaz();
   return 0;
}
Proqram ç
Zaman = 0.000000
Zaman = 6.000000
Zaman = 12.000000
Etibar Seyidzad
 40
Bu, funksiyalardan istifad  ed rk n daha
miyy tlidir. ndi C-d  parametr kimi daxil edil n
yi nin qiym tini bir vahid art ran INC adl  funksiya
 onu ça ran bir proqram yazaq.
/* INC.C */
void INC(double *D)
{ (*D)++; }
int main()
{ double X, *Y, Z;
  X = 6; Z = 8; Y = &Z;
  INC(&X);           /* X = 7;  */
  INC(Y);   /* *Y = 9 ve ya Z = 9 */
  /* INC(*Y); Sehvdir */
  return 0;
}
ndi d C++-da t qdimat t yin edicisi il  bu
proqram  yazaq.
/* INC.CPP */
void INC(double &D)
{ D++; }
int main()
{ double X, *Y, Z;
  X = 6; Z = 8; Y = &Z;
  INC(X);              /* X = 7;  */
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
41
  INC(*Y);   /* *Y = 9 ve ya Z = 9 */
  /* INC(Y); Sehvdir */
  return 0;
}
2.5 Gizl nmi  D yi nl ri Görm k
C- n bildiyimiz kimi bir blok daxilind  t yin
olunmu  d yi nin ad  daha vv l t yin olunmu
yi n ad  il  üst-üst  dü rs , son t yin olunmu
yi n blokun sonuna q r öz funksiyas  yerin
yetir k dig r d yi  müraci tin qar  al r
(ümumi v  lokal d yi n anlay lar  xat rlay n).
/* SCOPE.C */
#include <stdio.h>
int X = 5; /* X int tipinde ve qiymeti 5 */
void f()
{ double X = 27.5e30;   /* X double tipinde ve qiymeti 2.75e31 */
  X = 71;                       /* X double tipinde ve qiymeti 71 */
}
/* X int tipinde */
C++-da X  =  71 m nims dilm sinin lokal deyil,
ümumi t yin olunmu X  m nims dilm sini
Etibar Seyidzad
 42
ist yirsinizs , :: t yinedicisind n, y ni görm  (scope)
operatorundan istifad  etm lisiniz. Bel  ki,
/* SCOPE.CPP */
#include <iostream.h>
static int X = 5; /* X int tipinde ve qiymeti 5 */
void f()
{ double X = 27.5e30;    /* X double tipinde ve qiymeti 2.75e31 */
  cout<<X<<endl;
  X = 71e12; /* X double tipinde ve qiymeti 7.1e13 */
  ::X = 71; /* X int tipinde ve qiymeti 71 (qlobal X-dir) */
}
/* X int tipinde qiymeti 71 */
Uy un olaraq ifad rd  ümumi t yin olunmu
yi nl rin
Y = X * ::X + X + ::X;
klind  istifad si d  mümkündür.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
43
2.6 C++-da Prototipl rin T yin
Edilm si
C++-da C-d  istifad  olunan klassik stild ki
prototip t yinl rin  icaz  verilmir. Bunlar n yerin  daha
müasir prototip t yinl rind n istifad  edilir.
double f(a, b, c);
int a;
double b;
float *c;
{
   ...
   ...
   ...
}
yini s hvdir.
double f(int a, double b, float *c);
{
   ...
   ...
   ...
}
yini do rudur. Sad  prototip t yinind  d
double f(int a, double b, float *c); /* ve ya */
double f(int, double, float*);
yini do rudur.
Etibar Seyidzad
 44
2.7 Struktur Tipl r
struct, union v enum strukturlar  il typedef
yinedicisi istifad  edilm n tip t yinl rinin istifad
edilm si zaman struct, union v enum sözl rinin
yi nin ad ndan vv l göst rilm sinin vacibliyi C++-
da aradan qald lm r.
Tip t yini
struct Telebe
{ char Adi[20];
  int No;
  char Qiymeti;
};
olarsa, C-d  d yi nin t yini
struct Telebe A, B, C;
C++-da is  sad
Telebe A, B, C;
klind  yaz la bil r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
45
2.8 rh Operatoru
Proqram daxilind  proqramç n verdiyi rhl r
növb ti m rh rd  düz li r, d yi iklikl r v  dig r
proqramç lar n proqrama müdaxil si üçün çox
miyy tlidir. Yax  yaz lm  bir proqram daxilind
proqram s tirl rind n daha çox rh s tirl ri olur. Bütün
proqramla rma mühitl rind  oldu u kimi C-d  d rh
operatoru vard r. Bu /* il  ba lay b */ bit n s tirl rdir.
Proqram n ist nil n bir yerind  qoyula bil r. Bu operator
C++-da da istifad  oluna bil r.
C++-da bundan ba qa // i ar si il  ba layan rh
operatorundan da istifad  olunur. Bu i ar  il  ba layan
rh s tirl ri növb ti s tird n davam ed  bilm z.
//SERH.CPP
#include <conio.h>
#include <stdio.h>
main() // Proqrama baslama.
{  clrscr();                     // Ekranin temizlenmesi.
   double PI = 3.14; // Pi-nin qiymeti menimsedilir.
   double X;     // Bucaq qiymeti ucun teyin olunmus deyisken.
   int Err;     // Sehvlere nezaret ucun teyin olunmus deyisken.
   printf("Bucagin qiymetini derece olaraq daxil ediniz.\n");
   Err = scanf("%lf", &X); // X-in qiymeti bucaqla daxil edilmeli.
// Yalniz bir qiymet daxil edilmelidir.
// Err-in qiymeti 1 olmalidir.
   if (Err != 1)// Err-in qiymeti 1-den ferqli olarsa, sehf oxuma bas verir.
   {  fprintf(stderr, "Yalniz heqiqi eded daxil edin.\n");
Etibar Seyidzad
 46
      return 1; // Xetali proqram cixisi.
   }
   fflush(stdin); // Giris yaddasindaki artiq melumatlari silir.
   X *= PI / 180.0; // X radyana cevrilir.
   printf("%lf radyan\n", X);
   return 0; // Proqramdan sehv olmadan cixilir.
} // Proqramin sonu.
2.9 new v  delete Opratorlar
Dinamik yadda dan istifad  ed rk n icra olunan iki
sas liyyat yadda da yer ayr lmas  (malloc, calloc) v
ayr lan bu sah nin istifad  edildikd n sonra rb st (free)
burax lmas r. Bu liyyatlar üçün C-d  prototipl ri
stdlib.h v alloc.h ba q fayllar nda göst ril n
funksiyalardan istifad  edilir.
double *DP = (double*)malloc(sizeof(double));
int *IP = (int*)malloc(sizeof(int));
struct Date {int Gun, Ay, Il;};
struct Date *SDP = (struct Date*)malloc(sizeof(struct Date));
ayr lan bu sah ri s rb st buraxmaq üçün d
free((void*)DP);
free((void*)IP);
free((void*)SDP);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
47
mrl ri istifad  edilir. C++-da bu funksiyalardan ba qa
eyni zamanda
double *DP = new double;
int *IP = new int;
struct Date {int Gun, Ay, Il;};
struct Date *SDP = new struct Date;
istifad  etm k v  ayr lan bu sah ri s rb st buraxmaq
üçün d
delete DP;
delete IP;
delete SDP;
ifad rind n istifad  etm k olar.
Eyni tipd  iki v  daha art q yer ay rmaq üçün
(m n, 100 double tipli elementi olan A massivi üçün)
double *A = new doble[100];
mrind n istifad  etm k olar. Bu liyyat n tic sind
100 double tipli din yerl dirilm si üçün sah
ayr laraq ilk ünvan A-ya m nims dil kdir. Bu
nims tm  n tic sind *(A+3) = 81; v  ya A[3] = 81;
liyyatlar  il  massivin 4-cü elementin  qiym t
nims dilm si mümkündür. Burada massivin h r
elementinin double tipind  olmas na diqq t etm k
laz md r.
Etibar Seyidzad
 48
Bel  bir sah ni s rb st buraxmaq üçün
delete A;
mrind n istifad  etm k kifay tdir. (B zi C++
proqramlar nda delete mri il  yana  massivin ölçüsünü
 göst rm k laz m g  bil r (delete [100]A; kimi).
r ayr lacaq sah double tipli qiym tl rin
göst ricil ri yerl diril ks ,
double **A;
A = new double*;
kimi istifad  olunmal r. Eg r double göst ricil rinin
massivi istifad  edil ks ,
A = new double *[100];
kimi istifad  olunmal r.
Bundan ba qa new v delete operatorlar  üçün
massiv kimi yer ay rmalar nda istifad  edil n
elementl rin say n sabit olmas  vacib deyildir.
Elementl rin say  d yi n ola bildiyi kimi, liyyat
tic sind  d ld  edil  bil r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
C-D  YEN KL R V  C-Y LAV R
49
2.10 inline Makrolar
inline makrolar  parametrik makrolara ox ar kild
icra olunmas na baxmayaraq funksiyalar kimi t yin edil
bil r. M n, funksiya t yini
int max(int a, int b)
{ return a > b ? a : b; }
makro t yini
#define max(a, b) ((a) > (b) ? (a) : (b))
inline t yini a dak  kimidir:
inline int max(int a, int b)
{ return a > b ? a : b; }
inline makrolar n funksiyalara ox ad na diqq t
edin. inline makrolar  t yin ed rk n sanki, bir funksiya
yin etmi  olursunuz. Sad  t yin inline ifad si il
ba lay r.
Dig r makrolardan f rqli olaraq inline makrolar nda
tip n zar ti apar r. M n, yuxar da t yin edilmi
#define makrosunun istifad  edilm si zaman
double d = max(3.8, 3.1);
Etibar Seyidzad
 50
heç bir s hv olmadan icra olunur. inline makrosundan
istifad  edil rs , bunun s hvsiz icra olunaca
gözl k ç tindir. Bel  ki, max(double, double) kimi
yin olunmu  bir funksiya v  ya makro yoxdur. Buna
gör  d double tipli dl r int tipin  çevril k istifad
olunacaq v  n tic  d 3 olacaqd r.
inline makrolar n yaz laca  yer onlar n makro
olmas  n  al naraq t yin edilm lidir. Y ni, proqram
kodu hiss sind  deyil, t yin etm  hiss sind
yerl dirilm lidir. Çünki inline makrolar  kitabxanalarda
saxlan lm r.
inline makrolar  il  sür tli icra olunan sad
nims tm  v  n zar t liyyatlar ndan ibar t
funksiyalar yaz la bil r. inline makrolar  daxilind goto,
for, do-while, while, break, continue, switch, case
mrl rinin istifad  edilm si strukturun böyüm sin
b oldu u üçün, bunlar n istifad  edilm si
qs uy un deyildir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
51
III F L
OBYEKTL R
3.1 Obyekt N dir?
Obyekt (Object), yadda n d yi diril  bil n
qiym tl r v  ya mü yy n funksiyalar  yerin  yetir n
adland lm  sah sidir. Bu bax mdan bütün d yi nl r
bir obyektdir. Obyektl rin davran lar na gör
snifl ndirilm si d sinif (class) anlay  meydana
tirir. Bu bax mdan da veril nl rin tipl ri bir sinfi ifad
edir. B zi m nb rd  sinif yerin  obyekt, obyekt yerin
is nümun  (instance) anlay ndan istifad  edilir.
Obyektl r d yi n v  funksiyalardan ibar t olan
struktur d yi nl ridir. Obyekt  daxil olan d yi nl
üzv d yi nl ri (member variables), funksiyalara da
üzv fonksiyalar  (member functions) ad  verilir.
C++-da obyektl r iki cür t yin olunur: struct v
class sözü  il  ba layan  t yin.  Bunlar  aras ndak  yegan
rq, r ksi göst rilm zs , struct il  t yin olunan
obyektl rin bütün üzv d yi n v  funksiyalar na dig r
obyekt v  funksiyalar müraci t ed k istifad  ed
bil rl r. class il  t yin olunan obyektl rd  is ksi
Etibar Seyidzad
 52
göst rilm diyi halda, yaln z üzvl r bir-birl rini ça ra
bil rl r. Dig r obyekt v  funksiyalar üçün is  ba rlar.
ndi biz yaln z dair  v  halqalar  tan yan, bunlar n
sah  v  çevr ri il laq dar olan obyektl ri t yin
etdikd n sonra istifad  ed n proqram  t rtib ed k.
// DAIRE.CPP
#include <math.h>
struct DAIRE {
    double Diametr;
    double Cevre();
    double Sahe();
};
double DAIRE::Cevre()
{ return Diametr * M_PI; }
double DAIRE::Sahe()
{ return Diametr * Diametr * M_PI / 4; }
Burada:
struct strukturu daxilind  funksiyalar n da t yin
edilm sin ;
funksiyalar n kodla lmas  zaman  heç bir
yin olmadan Diametr d yi ninin istifad
edilm sin ;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
53
kodla lma apar lark n funksiya ad n
vv lin  funksiyan n aid oldu u sinif ad n
DAIRE:: klind lav  edilm sin  diqq t edin.
Funksiya adlar n vv lin  aid olduqlar  sinfin
ad n yaz lmas n s bi dig r sinifl rin d  eyni adl
üzv funksiyalar n ola bil yi ehtimal r. Müxt lif
sinifl  aid eyni adl  funksiyalar  ay rma n yegan  yolu
sinif ad  il  b rab r görm  operatorunun istifad
edilm sidir.
tic  olaraq obyektin kodla lmas  il laq dar
bu qaydalar  qeyd edm k olar:
1. Funksiyalar da strukturun bir hiss siymi  kimi
yi nl rl  birlikd  t yin oluna bil rl r;
2. Funksiya il  eyni struktur daxilind  t yin
olunmu  d yi nl r heç bir t yin olmadan
funksiya t find n istifad  oluna bil rl r;
3. Struktura aid funksiyalar yaz lark n, aid
olduqlar  strukturu göst rm k üçün funksiyan n
ad n vv lin  strukturun ad , aralar na is
görm  operatoru yaz lmal r.
//KVADRAT.CPP
struct KVADRAT {
    double Hundurluk;
    double Cevre();
    double Sahe();
};
Etibar Seyidzad
 54
double KVADRAT::Cevre()
{ return Hundurluk * 4; }
double KVADRAT::Sahe()
{ return Hundurluk * Hundurluk; }
Cevre v Sahe funksiyalar n burada KVADRAT
üçün yenid n t yin edildiyin  diqq t edin.
//OBJECT1.CPP
#include <stdio.h>
#include <conio.h>
#include "daire.cpp"
#include "kvadrat.cpp"
KVADRAT K1, K2;
DAIRE D;
main()
{   clrscr();
    K1.Hundurluk = D.Diametr = 10.0;
    K2.Hundurluk = 6;
    printf("\nOlculer:\nKvadrat\tHundurluk1 = %lf\t"
   "Hundurluk2 = %lf\nDaire\tDiametr = %lf\n",
    K1.Hundurluk, K2.Hundurluk, D.Diametr);
    printf("\nSaheler:\nKvadrat\tSahe1 = %lf\t"
   "Sahe2 = %lf\nDaire\tSahe = %lf\n",
    K1.Sahe(), K2.Sahe(), D.Sahe());
    printf("\nCevreler:\nKvadrat\tCevre = %lf\t"
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
55
   "Cevre2 = %lf\nDaire\tCevre = %lf\n",
    K1.Cevre(), K2.Cevre(), D.Cevre());
    printf("\nKvadrat halqanin sahesi = %lf\n", K1.Sahe() - K2.Sahe());
    return 0;
}
3.2 Layih ndirici
yi nl r kimi, obyektl ri d  t yin ed rk n
onlara ba lan c qiym t verm k olar. Bunun üçün obyekt
sinfi t yin edil rk n, obyektin yarad lmas  zaman
istifad  edil k xüsusi bir funksiya obyekt sturukturu il
rab r t yin edilir. Bu funksiyan  dig r funksiyalardan
rql ndir n sas xüsusiyy ti ad n t yin olunan sinif
ad  il  eyni olmas r. Bu funksiya heç bir qiym ti geri
qaytarm r. Bu funksiyaya layih ndirici (constructor)
deyilir.
//DAIRECON.CPP
#include <math.h>
struct DAIRE
{  double Diametr;
   DAIRE(double); // Layihelendiricinin teyin edilmesi
   double Cevre();
   double Sahe();
};
Etibar Seyidzad
 56
DAIRE::DAIRE(double C) // Layihelendiricinin
yazilmasi
{  Diametr = C > 0 ? C : -C; }
double DAIRE::Cevre()
{ return Diametr * M_PI; }
double DAIRE::Sahe()
{ return Diametr * Diametr * M_PI / 4; }
Bu  t yind  bundan  vv lki  misala  lav  olaraq
DAIRE sinfinin layih ndiricisi t yin edilmi dir.
//OBJECT2.CPP
#include <conio.h>
#include <stdio.h>
#include "dairecon.cpp"
main()
{  clrscr();
   DAIRE Xarici(30); // Layihelendiricinin istifade edilmesi
   DAIRE Daxili(20);
   printf("\nDaire diametrleri\nXarici -> %lf\tDaxili -> %lf\n",
  Xarici.Diametr, Daxili.Diametr);
   printf("\nDaire halqasinin sahesi = %lf\n",
  Xarici.Sahe() - Daxili.Sahe());
   return 0;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
57
Proqram ç
Daire diametrleri
Xarici -> 30.000000 Daxili -> 20.000000
Daire halqasinin sahesi = 392.699082
Bu cür istifad  il Diametr üzv d yi nin  müraci t
sad ir. Dig r t fd n layih ndiricinin i  qo ulmas
avtomatik olaraq h yata keçirilir. Bunun üçün
proqramç n lav  c htl r etm sin  ehtiyac qalm r.
3.3 Müraci t Haqq
Bir obyektin d yi n v  funksiyalardan ibar t
üzvl rinin dig r obyektl r t find n birba a istifad
edilm si üçün, bu obyektl r dig r obyektl  qar
qoruna bil rl r.
Bu qorunma 4 müxt lif halda ola bil r:
1. Bir üzv d yi n v  ya üzv funksiyas n yaln z
üzvü oldu u obyekt daxilind  istifad  edilm si -
xüsusi (private);
2. Bir üzvün obyekt xaricind  yaln z o obyektd n
tör n obyektl r t find n istifad  edil  bilm si
- qorunmu  (protected);
3. Bir üzvün bütün obyektl r t find n ortaq
istifad  edil  bilm si - ümumi (public);
Etibar Seyidzad
 58
4. Bir obyektin ba qa bir obyekti “dostu” elan
ed k üzvl rinin ham n bu obyekt t find n
istifad  edilm sin  icaz  verm si - dost (friend).
Bunlardan ilk üçü çox istifad  edilir.
//ADSTRC.H
struct Adlar
{  private:
     char Ad[20];
     int Yas;
     void Boyuk();
   public:
     Adlar(char*, int);
     int Yaz();
     int NormalYaz();
};
struct il  obyekt t yinl rind  istifad  haqq
ba lan cda public olur. ksi göst rilm dikd  bu bel  d
qal r. class il  obyekt t yinl rind  is  ba lan cda private
olur. Bundan ba qa struct class vasit sil  obyekt (sinif)
yinl ri aras nda f rq yoxdur. Yuxar dak  misaldan
göründüyü kimi hans  üzvün hans  istifad çi
viyy sind  t yin edil yini, t yind n vv l private:,
protected: v  ya public: kimi ifad rd n istifad  ed k
mü yy nl dirm k mümkündür.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
59
Yuxar dak  misalda Ad v Yas d yi nl ri il
Boyuk funksiyas private, dig r üzv funksiyalar is public
kimi t yin olunmu dur.
Eyni obyekti class açar sözünd n istifad  ed k
dak  kimi t yin etm k olar:
//ADCLASS.H
class Adlar
{
   char Ad[20];
   int Yas;
   void Boyuk();
   public:
     Adlar(char*, int);
     int Yaz();
     int NormalYaz();
};
struct v class t yinl rinin müqayis sini a dak
kimi göst rm k olar:
struct ad
{
  ...
  ...
  ...
};
class ad
{ public:
     ...
     ...
     ...
};
Etibar Seyidzad
 60
class ad
{
  ...
  ...
  ...
};
struct ad
{ private:
     ...
     ...
     ...
};
Üzv funksiyalar n struct v  ya class il
kodla lmas  aras nda el  bir f rq yoxdur.
Üzv funksiyalar n dig r üzvl ri, xüsusil  d  üzv
yi nl rini sanki, lokal d yi nl r kimi istifad
etdikl rin  diqq t edin.
//ADDEC.CPP
#define __STRUCT
#ifdef __STRUCT
#include "adstrc.h"
#else
#include "adclass.h"
#endif
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
Adlar::Adlar(char* N, int Y)
{  strcpy(Ad, N);
   Yas = Y;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
61
void Adlar::Boyuk()
{  char *p;
   for(p = Ad; *p; ++p)
       if(islower(*p))
  *p = toupper(*p);
}
int Adlar::Yaz()
{  char t[20];
   int i;
   strcpy(t, Ad);
   Boyuk();
   i = NormalYaz();
   strcpy(Ad, t);
   return i;
}
int Adlar::NormalYaz()
{  return puts(Ad); }
Adlar A("Kenan Seyidzade", 7);
Adlar B("KAMRAN Resulov", 8);
main()
{  clrscr();
   A.Yaz();
   B.Yaz();
   A.NormalYaz();
   B.NormalYaz();
   return 0;
}
Proqram ç
KENAN SEYIDZADE
KAMRAN RESULOV
Etibar Seyidzad
 62
Kenan Seyidzade
KAMRAN Resulov
Bel  bir proqram daxilind A.Boyuk() kimi müraci t
hv q bul edil kdir. Bu funksiyan n mövcud olmas na
baxmayaraq, main() funksiyas n ona müraci t haqq
yoxdur.
3.4 Yoxedici (Destructor)
Layih ndirici nec  ki, obyektin mövcud olmas
hal nda onu proqrama haz rlay r, yoxedici funksiyas  da
obyekt proqram xaricind  qald  zaman onun
hdudla rd  v  ya d yi dirdiyi kompüter
mühitl rinin yenid n nizamlanmas  t min edir. Bu
funksiyaya, xüsusil  obyektin dinamik yadda dan
istifad  etdiyi zaman ehtiyac olur.
r hans  bir yoxedicinin ad  t yin olundu u
obyektin tipi (sinfi) il  eynidir. Yaln z layih ndiricinin
ad  il  qar rmamaq üçün vv lin  “~”  (tilde) i ar si
qoyulur. Bu funksiya h r hans  bir qiym t hasil etm diyi
kimi, heç bir parametri d  yoxdur.
// MASSIV.CPP
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
63
class Massiv
{  int *p; //Massivin ilk elementinin gostericisi
   int Olcu; //Massivin olcusu
public:
   Massiv(int s); //Layihelendirici s elementli bir massiv yaradir
   ~Massiv(); //Yoxedici
   int Getir(int i); //Massivin i-ci elementinin qiymetini verir
   void Menimset(int i, int d);
//Massivin i-ci elementine d-ni menimsedir
   void Sehv(char* msg); //Sehv mesajlarini gosterir
   double Orta(); //Massivin orta qiymetini hesablayir
};
Massiv::Massiv(int s)
{  printf("Layihelendirici islemeye basladi.\n");
   if (s <= 0) Sehv("Menfi ededler olcu ola bilmez!");
   if ((p = new int [Olcu = s]) == NULL)
      Sehv("Massive yer ayrila bilmedi!");
   printf("Layihelendirici isini dayandirdi.\n\n");
}
Massiv::~Massiv()
{  printf("Yoxedici islemeye basladi.\n");
   if (p != NULL) delete p;
   printf("Yoxedici isini dayandirdi.\n");
}
int Massiv::Getir(int i)
{  if (i < 0 || i > Olcu)
Etibar Seyidzad
 64
       Sehv("Massivin olcusu xaricinde!");
   return p[i];
}
void Massiv::Menimset(int i, int d)
{  if (i < 0 || i > Olcu)
       Sehv("Massivin olcusu xaricinde!");
   else p[i] = d;
}
void Massiv::Sehv(char* msg)
{  fprintf(stderr, "\a%s\n", msg);
   exit(4);
}
double Massiv::Orta()
{  int i;
   double t;
   for (i = 0, t = 0; i < Olcu; i++)
 t += p[i];
   return t / Olcu;
}
// ********************** Misallar **************
Massiv A(3);
void Misal1()
{  printf("\n1-ci Misal\tLokal teyin etme\n\n");
   Massiv B(5);
}
#pragma warn -aus  // 'C' is assigned a value that is never used
// mesajinin qarsisini alir
void Misal2()
{  printf("\n2-ci Misal\tLokal gosterici teyin etme\n\n");
   Massiv *C = new Massiv(5);
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
65
#pragma warn +aus
void Misal3()
{  printf("\n3-cu Misal\tLokal gosterici teyin etme ve silme\n\n");
   Massiv *D = new Massiv(5);
   delete D;
}
main()
{  clrscr();
   printf("main funksiyasi icra olunmaga basladi.\n");
   Misal1();
   Misal2();
   Misal3();
   printf("\nUzvlerin istifade olunmasi\n\n");
   Massiv E(4);
   int i;
   for (i = 0; i < 3; i++)
A.Menimset(i, rand());
   for (i = 0; i < 4; i++)
E.Menimset(i, rand());
   for (i = 0; i < 3; i++)
printf("A[%d] = %d\n", i, A.Getir(i));
printf("\nOrta qiymetler\n\n A = %lf,\t E = %lf\n\n",
 A.Orta(), E.Orta());
printf("main funksiyasi icrasini tamamladi.\n\n");
return 0;
}
Etibar Seyidzad
 66
Proqram ç
main funksiyasi icra olunmaga basladi.
1-ci Misal Lokal teyin etme
Layihelendirici islemeye basladi.
Layihelendirici isini dayandirdi.
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
2-ci Misal Lokal gosterici teyin etme
Layihelendirici islemeye basladi.
Layihelendirici isini dayandirdi.
3-cu Misal Lokal gosterici teyin etme ve silme
Layihelendirici islemeye basladi.
Layihelendirici isini dayandirdi.
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
Uzvlerin istifade olunmasi
Layihelendirici islemeye basladi.
Layihelendirici isini dayandirdi.
A[0] = 346
A[1] = 130
A[2] = 10982
Orta qiymetler
 A = 3819.333333, E = 9364.500000
main funksiyas  icras  tamamlad .
A üçün
B üçün
B üçün
C üçün
D üçün
D üçün
E üçün
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
67
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
E üçün
A üçün
3.5 Standart Obyekt Tipl ri
C-d int, char, double kimi tan nan standart tipl rün
r biri C++-da bir sinif kimi istifad  oluna bil r. Bunlara
dak  kimi qiym tl r m nims tm k olar. Bu cür
obyektl  m nims dil k qiym t, sinifl  uy un
olmal r. r uy un deyils , onlar  uy unla rmaq
laz md r. Bu da b zi s hvl  yol aça bil r.
int x = 5; yerin int x(5);
double pi = 3.14; yerin double pi(3.14);
int Y = X; yerin int Y(X);
float *f;
f = (float*)malloc(sizeof(float));
*f = 7.0/2.0;
yerin float *f = new float(7.0/2.0);
3.6 Layih ndirici Üz rin  Yükl
Bir layih ndirici, üzvü oldu u obyektin ba lan c
ziyy tini nizamlayark n proqramç n ist kl ri
müxt lif ola bil r. Bunun üçün d  müxt lif
layih ndiricil rin istifad  edilm si laz m ola bil r. Bunu
yerin  yetirm k  üçün  F sil 2-d rh edil n üz rin
Etibar Seyidzad
 68
yükl  üsulu layih ndiricil r üçün d  istifad  oluna
bil r.
n, bundan vv lki misalda baxd z
massiv sinfinin layih ndiricisi veril n miqdarda yer
ay rd . r massivin ölçüsü göst rilm zs , 100 oldu u
bul edilsin v  ölçüsünd n as  olmayaraq massivin h r
bir elemenitin -1000 di m nims dilsin. Yen  laz m
rs , ba lan c qiym t d  veril  bil r.
Bunun üçün üç layih ndiriciy  ehtiyac vard r:
1. Heç bir qiym tin verilm si hal ;
2. Ölçünün verilm si hal ;
3. r ikisinin verilm si hal .
//MAS3CON.CPP
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
class Massiv
{  int *p; //Massivin ilk elementinin gostericisi
   int Olcu; //Massivin olcusu
public:
   Massiv(); //Layihelendirici Ilk qiymeti -1000 olan 100
//elementli massiv yaradir.
   Massiv(int s); //Layihelendirici Ilk qiymeti -1000 olan s elementli
//massiv yaradir.
   Massiv(int s, int d); //Layihelendirici Ilk qiymeti d olan s elementli
                 //massiv yaradir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
69
   ~Massiv(); //Yoxedici
   int Getir(int i); //Massivin i-ci elementinin qiymetini verir
   void Menimset(int i, int d);  //Massivin i-ci elementine d-ni
               //menimsedir
   void Sehv(char* msg); //Sehv mesajlarini gosterir
   double Orta(); //Massivin orta qiymetini hesablayir
};
Massiv::Massiv()
{  int s = 100; //Qebul edilen massivin olcusu 100;
   if ((p = new int [Olcu = s]) == NULL)
      Sehv("Massive yer ayrila bilmedi!");
      for (; s;)
   p[--s] = -1000;
}
Massiv::Massiv(int s)
{  if (s <= 0) Sehv("Menfi ededler olcu ola bilmez!");
   if ((p = new int [Olcu = s]) == NULL)
      Sehv("Massive yer ayrila bilmedi!");
   for (; s;)
p[--s] = -1000;
   //s ededini Olcu uzv deyiskenine yazdigi ucun saygac olaraq
   //istifade edilmisdir.
}
Massiv::Massiv(int s, int d)
{  if (s <= 0) Sehv("Menfi ededler olcu ola bilmez!");
   if ((p = new int [Olcu = s]) == NULL)
      Sehv("Massive yer ayrila bilmedi!");
   for (; s;)
p[--s] = d;
   //s yene saygac olaraq istifade edilmisdir.
}
Etibar Seyidzad
 70
Massiv::~Massiv()
{  printf("Yoxedici islemeye basladi.\n");
   if (p != NULL) delete p;
   printf("Yoxedici isini dayandirdi.\n");
}
int Massiv::Getir(int i)
{  if (i < 0 || i > Olcu)
       Sehv("Massivin olcusu xaricinde!");
   return p[i];
}
void Massiv::Menimset(int i, int d)
{  if (i < 0 || i > Olcu)
       Sehv("Massivin olcusu xaricinde!");
   else p[i] = d;
}
void Massiv::Sehv(char* msg)
{  fprintf(stderr, "\a%s\n", msg);
   exit(4);
}
double Massiv::Orta()
{  int i;
   double t;
   for (i = 0, t = 0; i < Olcu; i++)
 t += p[i];
   return t / Olcu;
}
// ********************** Misallar **************
Massiv A(3);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
71
void Misal1()
{  printf("\n1-ci Misal\tLokal teyin etme\n\n");
   Massiv B(5);
}
#pragma warn -aus // 'C' is assigned a value that is never used
// mesajinin qarsini alir
void Misal2()
{  printf("\n2-ci Misal\tLokal gosterici teyin etme\n\n");
   Massiv *C = new Massiv(5);
}
#pragma warn +aus
void Misal3()
{  printf("\n3-cu Misal\tLokal gosterici teyin etme ve silme\n\n");
   Massiv *D = new Massiv(5);
   delete D;
}
main()
{  clrscr();
   printf("main funksiyasi icra olunmaga basladi.\n");
   Misal1();
   Misal2();
   Misal3();
   printf("\nUzvlerin istifade olunmasi\n\n");
   Massiv E(4);
   int i;
   for (i = 0; i < 3; i++)
A.Menimset(i, rand());
   for (i = 0; i < 4; i++)
E.Menimset(i, rand());
Etibar Seyidzad
 72
   for (i = 0; i < 3; i++)
printf("A[%d] = %d\n", i, A.Getir(i));
printf("\nOrta qiymetler\n\n A = %lf,\t E = %lf\n\n",
 A.Orta(), E.Orta());
printf("main funksiyasi icrasini tamamladi.\n\n");
return 0;
}
Proqram ç
main funksiyasi icra olunmaga basladi.
1-ci Misal Lokal teyin etme
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
2-ci Misal Lokal gosterici teyin etme
3-cu Misal Lokal gosterici teyin etme ve silme
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
Uzvlerin istifade olunmasi
A[0] = 346
A[1] = 130
A[2] = 10982
Orta qiymetler
 A = 3819.333333, E = 9364.500000
main funksiyas  icras  tamamlad .
A üçün
B üçün
D üçün
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
73
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
Yoxedici islemeye basladi.
Yoxedici isini dayandirdi.
E üçün
A üçün
Bu t yind n sonra Massiv sinfinin müxt lif hallar
üçün a dak lar  qeyd etm k olar:
Massiv X(10, 5);
10 elementli bir massiv obyekti yadda da
yerl dirilir v  h r element 5 qiym ti m nims dilir.
Massiv Y(20);
20 elementli massiv obyekti yarad r v  bütün
elementl  ba lan c qiym t olaraq -1000 m nims dilir.
Massiv Z;
Heç bir ba lan c rt verilm diyi üçün Z massivi
üçün 100 elementlik yer ayr r v  h r element -1000
qiym ti m nims dilir.
Layih ndirici üz rin  yükl r ba lan c rtl r
müxt lif olmas na baxmayaraq, eyni davran  hadis ri
yin etm k üçün çox istifad  edil n bir yoldur.
Layih ndirici xaricind  yoxedici funksiyas ndan ba qa
Etibar Seyidzad
 74
bütün üzv funksiyalar üz rin  yükl liyyat
aparmaq mümkündür.
Bununla b rab r üzv funksiyalar n v
layih ndiricinin parametrl rin  aktiv qiym t verm k
mümkündür. Bel  ki, yuxar da göst ril n misalda oldu u
kimi üç layih ndirici t yin etm kd ns , sad
Massiv(int s, int d);
layih ndiricisini t yin edib, s v d-y  aktiv qiym t
verils  idi,
Massiv(int s = 100, int d = -1000);
kimi t yin olunmu  kod eyni qalmaqla eyni i i gör
bil rdi.
3.7 Obyektl  M nims tm
Bir qayda olaraq obyektl  m nims tm  ehtiyac
yoxdur. Obyektl r üzv funksiyalar t find n n zar t
olunmal rlar. r obyekt üçün m nims tm  operatoru
“=” yenid n t yin edilm zs , m nims tm r
layih ndiricinin ça lmas klin  çevril k t tbiq
edilir. Bu da yaln z obyekt ilk d  yarad lark n yerin
yetirilir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
75
n, Massiv X = 18; m nims dilm si Massiv
X(18); kimi istifad  edilir. Bu da X-e 18 elementlik yer
ayr lmas  v  h r element -1000 m nims dilm si
dem kdir.
r Massiv X = “Setir”; m nims dil rs , Massiv
X(“Setir”); müraci ti  yaranacaqd r  ki,  bu  da  s hv
olacaqd r.
r bir obyekt  eyni sinf  daxil olan ba qa bir
obyekt m nims tm k t b olunarsa, vv lc  bel  bir
nims tm nin olub olmayaca na n zar t edilir. T yin
olunmu sa, operator funksiya icra olunur. T yin
olunmam sa, layih ndirici siyah nda bel  bir
layih ndiricinin olub olmamas na bax r. r orada
da yoxdursa, m nims dil k obyektin üzv d yi nl ri
dig rin  bir-bir köçürülür.
//AD2.CPP
#include <conio.h>
#include <stdio.h>
#include <string.h>
class Adlar
{  char Ad[30];
   int Yas;
public:
   Adlar(char*, int);
   void Deyisdir(char*);
   void Yaz();
Etibar Seyidzad
 76
};
Adlar::Adlar(char* ad, int yas)
{  strcpy(Ad, ad);
   Yas = yas;
}
void Adlar::Deyisdir(char* YeniAd)
{  strcpy(Ad, YeniAd); }
void Adlar::Yaz()
{  printf("\nObyekt\n\nAdi  : %s\nYasi : %d\n", Ad, Yas); }
main()
{  clrscr();
   Adlar A("Etibar Seyidzade", 35);
   Adlar B = A;
   A.Yaz();
   B.Yaz();
   printf("\nA-nin adi deyisdirildi.\n\n");
   A.Deyisdir("Seyidzade Etibar Vaqif oglu");
   A.Yaz();
   B.Yaz();
   return 0;
}
Proqram ç
Obyekt
Adi   : Etibar Seyidzade
Yasi : 35
Obyekt
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
77
Adi   : Etibar Seyidzade
Yasi : 35
A-nin adi deyisdirildi.
Obyekt
Adi   : Seyidzade Etibar Vaqif oglu
Yasi : 35
Obyekt
Adi   : Etibar Seyidzade
Yasi : 35
Misalda B  =  A m nims dilm si il A-n n saxlad
qiym tl r B-y  m nims dilmi  olur.
Proqram a dak  kimi yaz larsa,
//AD3.CPP
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
class Adlar
{  char *Ad;
   int Yas;
public:
   Adlar(char*, int);
   ~Adlar();
   void Deyisdir(char*);
   void Yaz();
};
Etibar Seyidzad
 78
Adlar::Adlar(char* ad, int yas)
{  Ad = new char[strlen(ad)+1];
   if(!Ad) // if(Ad == NULL) menasinda
     abort();
   strcpy(Ad, ad);
   Yas = yas;
}
Adlar::~Adlar()
{  if(Ad) // if(Ad !== NULL) menasinda
   {  delete Ad;
      Ad = NULL;
   }
}
void Adlar::Deyisdir(char* YeniAd)
{  if(Ad) delete Ad;
   Ad = new char[strlen(YeniAd)+1];
   if(!Ad) abort();
   strcpy(Ad, YeniAd);
}
void Adlar::Yaz()
{  printf("\nObyekt\n\nAdi  : %s\nYasi : %d\n", Ad, Yas); }
main()
{  clrscr();
   Adlar A("Etibar Seyidzade", 35);
   Adlar B = A;
   A.Yaz();
   B.Yaz();
   printf("\nA-nin adi deyisdirildi.\n\n");
   A.Deyisdir("Seyidzade Etibar Vaqif oglu");
   A.Yaz();
   B.Yaz();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
79
   return 0;
}
Proqram ç  a dak  kimi olacaqd r:
Obyekt
Adi   : Etibar Seyidzade
Yasi : 35
Obyekt
Adi   : Etibar Seyidzade
Yasi : 35
A-nin adi deyisdirildi.
Obyekt
Adi   : Seyidzade Etibar Vaqif oglu
Yasi : 35
Obyekt
Adi   : Seyidzade Etibar Vaqif oglu
Yasi : 35
Göründüyü kimi heç bir problem yoxdur. H tta A
il B üzvl ri bir-biri il laq li olduqlar  üçün misalda
oldu u kimi birinin ad d yi ikliyind n dig rinin d
ri olacaqd r. Yox edil rk n Ad göst ricisinin
göst rdiyi yadda  sah si vv lc  obyektl rin biri
find n, sonra da eyni sah  ikinci obyekt t find n
rb st burax r. Eyni sah nin iki d  s rb st
Etibar Seyidzad
 80
burax lmas  is  çox güman ki, növb ti m rh rd
böyük s hvl  yol açacaqd r. Bel  hallar n meydana
lm si üçün m nims tm  operatoru t yin edilm li v
ya layih ndiricil rin daxilin  ba qa bir layih ndirici
lav  edilm lidir.
//AD4.CPP
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
class Adlar
{  char *Ad;
   int Yas;
public:
   Adlar(char*, int);
   Adlar(Adlar&);
   ~Adlar();
   void Deyisdir(char*);
   void Yaz();
};
Adlar::Adlar(char* ad, int yas)
{  Ad = new char[strlen(ad)+1];
   if(!Ad) // if(Ad == NULL) menasinda
     abort();
   strcpy(Ad, ad);
   Yas = yas;
}
Adlar::Adlar(Adlar&Obyekt)
{  Ad = new char[strlen(Obyekt.Ad)+1];
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
81
   if(!Ad) abort();
   strcpy(Ad, Obyekt.Ad);
   Yas = Obyekt.Yas;
}
Adlar::~Adlar()
{  if(Ad) // if(Ad !== NULL) menasinda
   {  delete Ad;
      Ad = NULL;
   }
}
void Adlar::Deyisdir(char* YeniAd)
{  if(Ad) delete Ad;
   Ad = new char[strlen(YeniAd)+1];
   if(!Ad) abort();
   strcpy(Ad, YeniAd);
}
void Adlar::Yaz()
{  printf("\nObyekt\n\nAdi  : %s\nYasi : %d\n", Ad, Yas); }
main()
{  clrscr();
   Adlar A("Etibar Seyidzade", 35);
   Adlar B = A;
   A.Yaz();
   B.Yaz();
   printf("\nA-nin adi deyisdirildi.\n\n");
   A.Deyisdir("Seyidzade Etibar Vaqif oglu");
   A.Yaz();
   B.Yaz();
   return 0;
}
Etibar Seyidzad
 82
Proqram ç
Obyekt
Adi   : Etibar Seyidzade
Yasi : 35
Obyekt
Adi   : Etibar Seyidzade
Yasi : 35
A-nin adi deyisdirildi.
Obyekt
Adi   : Seyidzade Etibar Vaqif oglu
Yasi : 35
Obyekt
Adi   : Etibar Seyidov
Yasi : 34
nims tm  il laq dar bu problem m nims tm
olmasa bel , obyektl rin funksiyalara parametr kimi
gönd rilm si zaman  meydana g lir.
long Axtar(Adlar X);
prototipli funksiyaya
adlar A(“Seyidzade Kenan”, 8);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL R
83
kimi bir parametr ötürüldüyü zaman proqram sanki,
X = A; m nims dilm si ba  vermi dir kimi davranacaq v
haqq nda söhb t aç lan probleml r meydana g kdir.
Buna gör  d AD4.CPP proqram nda oldu u kimi
problemin qar  almaq laz m g kdir.
Obyektl rin t yin edilm si üçün bu s bd n laz m
n dig r layih ndiricil rl  b rab r daha iki
layih ndiri d  olur:
1. Standart layih ndirici (default constructor)  -
Sinif_ad (); klind  t yin edil n bu
layih ndirici heç bir ilkin rt verilm diyi halda
istifad  olunur;
2. Köçürm  layih ndiricisi (copy constructor)  -
Sinif_ad (Sinif_ad &); klind  t yin edil n bu
layih ndirici is vv lc n t yin edilmi  bir
hadis nin qiym tl rini yeni yarad lmaqda olan
hadis  ötürür. vv lki obyektin bir nüsx sini
xar r.
Etibar Seyidzad
 84
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
85
IV F L
OBYEKTL N
XÜSUS YY TL
4.1 Obyekt Üzvl ri Olan Obyektl r
Bir obyektin üzv d yi nl ri aras nda dig r
obyektl r d  ola bil r. stifad  edilib edilm sind n
as  olamayaraq bu obyektl rin dig r d yi nl rd n
rqi yoxdur.
class A
{   int I;
    ...
    public:
    A();
    A(A&);
    A(int);
    ...
    ...
};
class B
{   A a, b;
    ...
    public:
    B();
    B(B&);
    B(int, int);
Etibar Seyidzad
 86
    ...
    ...
};
kimi t yin edilmi  iki sinifd n birincisinin
kodla lmas nda indiy  q r rh etdikl rimiz lav
edil k yeni bir ey yoxdur. kinci sinfin
kodla lmas nda is
B::B()
{   ....
    ....
}
kimi bir layih ndiricinin kodla lmas nda a v b
obyektl ri üçün standart layih ndiricil r avtomatik
olaraq ça r. r bunun yerin  ba qa bir
layih ndiricinin istifad  olunmas  t b olunarsa,
B::B()
:a(33),
 b(12)   { ... }
B::B(int u, int v)
:a(u),
 b(v)   { ... }
klind  layih ndirici ba n yaz lmas ndan sonra
“:” i ar si, üzv obyektl rin ist nil n layih ndiricil ri
aras na is  “,” qoyularaq yaz la bil r. Layih ndiricisi
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
87
yin olunmayan obyektl r üçün is  standart
layih ndirici avtomatik olaraq ça lacaqd r.
//DOST1.CPP
#include <conio.h>
#include <stdio.h>
#include <math.h>
class Noqte
{  float X, Y, Z;
public:
   Noqte(float = 0, float = 0, float = 0);
   Noqte(Noqte&);
   int Dasi(float, float, float);
   int Yaz();
   float Mesafe(Noqte&);
};
Noqte::Noqte(float _x, float _y, float _z)
{
   X = _x;
   Y = _y;
   Z = _z;
}
Noqte::Noqte(Noqte& N)
{
  X = N.X;
   Y = N.Y;
   Z = N.Z;
}
int Noqte::Dasi(float dx, float dy, float dz)
{  X += dx;
Etibar Seyidzad
 88
   Y += dy;
   Z += dz;
   return 0;
}
int Noqte::Yaz()
{  printf("(%f, %f, %f)", X, Y, Z);
   return 0;
}
#define DIFSQR(p) ((p-Ikinci.##p)*(p-Ikinci.##p))
float Noqte::Mesafe(Noqte& Ikinci)
{  return sqrt(DIFSQR(X) + DIFSQR(Y) + DIFSQR(Z));  }
#undef DIFSQR
class Duzxett
{  Noqte Baslangic, Bitis;
public:
   Duzxett(Noqte&, Noqte&);
   Duzxett(Duzxett&);
   float Uzunluq();
   int Yaz();
};
Duzxett::Duzxett(Noqte& A, Noqte& B)
:Baslangic(A),
 Bitis(B)
{}
Duzxett::Duzxett(Duzxett& D)
:Baslangic(D.Baslangic),
 Bitis(D.Bitis)
{}
float Duzxett::Uzunluq()
{  return Baslangic.Mesafe(Bitis);  }
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
89
int Duzxett::Yaz()
{  printf("[");
   Baslangic.Yaz();
   printf("-");
   Bitis.Yaz();
   printf("]");
   return 0;
}
main()
{  clrscr();
   Noqte A;
   Noqte B(30, 40, 50);
   A.Yaz();
   printf("\n");
   B.Yaz();
   printf("\n\niki noqte arasindaki mesafe = %f\n\n", A.Mesafe(B));
   B.Dasi(10, -10, 60);
   Duzxett D(Noqte(10, 20, 30), B);
   D.Yaz();
   printf("\n\nduz xettin uzunlugu = %f\n\n", D.Uzunluq());
   return 0;
}
Proqram ç
(0.000000, 0.000000, 0.000000)
(30.00000, 40.00000, 50.00000)
iki noqte aras ndaki mesafe = 70.710678
[(10.00000, 20.00000, 30.00000)-(40.00000, 30.00000, 110.00000)]
Etibar Seyidzad
 90
duz xettin uzunlu u = 86.023253
4.2 Friend (Dost) T yinedicisi
Bir sinfin üzvl rinin dig r sinif v  funksiyalardan
qorunmas  b n m nfi hallara g tirib ç xar r. Bu
üzvl rin bütün istifad  aç lmas  da b n probleml r
xara bil r. Bu bax mdan bir sinfin üzvl ri qorunark n
zi sinif v  funksiyalardan qorunmay b, xüsusi (private
yinli) üzvl ri, bu sinif v  funksiyalar t find n istifad
oluna bil r. Qada an olunmas na baxmayaraq, bütün
xüsusi üzvl  müraci t hüququ veril n funksiyalara
dost-funksiya (friend-function), sinifl  is dost-sinif
(friend-class) deyilir.
//DOST2.CPP
#include <conio.h>
#include <stdio.h>
#include <math.h>
class Noqte
{  float X, Y, Z;
public:
   Noqte(float = 0, float = 0, float = 0);
   Noqte(Noqte&);
   int Dasi(float, float, float);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
91
   friend int Yaz(Noqte&);
   friend float Mesafe(Noqte&, Noqte&);
};
Yaz Mesafe üzv funksiyas  deyildir. Normal
olaraq prototipl ri Noqte sinfinin xaricind  t yin
olunmal r. Bu iki funksiya v zif rin  gör Noqte
sinfinin xüsusi d yi nl rin  müraci t etm li
olduqlar ndan bu sinif t find n friend olaraq t yin
edilmi dir.
DOST2.CPP  davam
Noqte::Noqte(float _x, float _y, float _z)
{
   X = _x;
   Y = _y;
   Z = _z;
}
Noqte::Noqte(Noqte& N)
{
   X = N.X;
   Y = N.Y;
   Z = N.Z;
}
int Noqte::Dasi(float dx, float dy, float dz)
{  X += dx;
   Y += dy;
   Z += dz;
   return 0;
}
int Yaz(Noqte& N)
Etibar Seyidzad
 92
{  printf("(%f, %f, %f)", N.X, N.Y, N.Z);
   return 0;
}
float Mesafe(Noqte& Birinci, Noqte& Ikinci)
{  return sqrt((Birinci.X - Ikinci.X) * (Birinci.X - Ikinci.X) +
       (Birinci.Y - Ikinci.Y) * (Birinci.Y - Ikinci.Y) +
       (Birinci.Z - Ikinci.Z) * (Birinci.Z - Ikinci.Z) );
}
Yaz v Mesafe funksiyalar  üzv funksiyas
olmad qlar  üçün kodla lark n “Noqte::” ifad si
ba q daxilind  olmamal r. Olarsa, bu s hv q bul
edil kdir.
DOST2.CPP  davam
class Duzxett
{  Noqte Baslangic, Son;
public:
   Duzxett(Noqte&, Noqte&);
   Duzxett(Duzxett&);
   float Uzunluq();
   friend int Yaz(Duzxett&);
};
Duzxett::Duzxett(Noqte& A, Noqte& B)
:Baslangic(A),
 Son(B)
{}
Duzxett::Duzxett(Duzxett& D)
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
93
:Baslangic(D.Baslangic),
 Bitis(D.Son)
{}
float Duzxett::Uzunluq()
{  return Mesafe(Baslangic, Son);  }
int Yaz(Duzxett& D)
{  printf("[");
   Yaz(D.Baslangic);
   printf("-");
   Yaz(D.Son);
   printf("]");
   return 0;
}
Yaz v Mesafe üzv funksiyas  olmad qlar  üçün
istifad  edil rk n Baslangic.Mesafe(Son); v  ya
Baslang c.Yaz(Son); klind  istifad  edilm diyin
diqq t edin.
DOST2.CPP  davam
main()
{  clrscr();
   Noqte A, B(30, 40, 50);
   Yaz(A);
   printf("\n");
   Yaz(B);
   printf("\n\niki noqte arasindaki mesafe = %f\n\n", Mesafe(A, B));
   B.Dasi(10, -10, 60);
   Duzxett D(Noqte(10, 20, 30), B);
Etibar Seyidzad
 94
   Yaz(D);
   printf("\n\nduz xettin uzunlugu = %f\n\n", D.Uzunluq());
   return 0;
}
Bu proqram icra olunmas  bax ndan vv lkind n
rql nmir. Sad  proqram n yaz lmas nda istifad
olunan funksiyalar n, istifad  olunma m ntiqi
müxt lifdir. Bu cür t yinl r kitabxana yaratmaq üçün
daha çox istifad  oluna bil n funksiyalar n yaz lmas na
köm k edir.
Proqram ç
(0.000000, 0.000000, 0.000000)
(30.00000, 40.00000, 50.00000)
iki noqte aras ndaki mesafe = 70.710678
[(10.00000, 20.00000, 30.00000)-(40.00000, 30.00000, 110.00000)]
duz xettin uzunlu u = 86.023253
Bir sinfin ba qa bir sinfi dost elan etm si is
dak  kimi h yata keçirilir:
class A
{   friend class B;
    ...
    ...
    ...
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
95
};
class B
{   ....
    ....
    ....
};
Bir sinfin iki v  daha art q dost-sinif v  dost-
funksiyas  ola bil r. Dost-sinif, dost-funksiya t yinl rinin
private, public v  ya protected viyy rind  olmas n
el  bir miyy ti yoxdur.
Dost-sinif t yinl rinin m qs di dost elan edil n
sinfin (m n, B sinfi), dost elan ed n sinfin (m n, A
sinfi) bütün xüsusi üzvl rin  müraci t haqq  t min
etm kdir. Bel likl , aralar nda heç bir ox arl n
olmamas na baxmayaraq bir sinfin dig r sinifd n istifad
etm si t min olunmu  olur. Bu haqq sad friend il
yin olunmu  sinifl  verilir. Bu sinifd n tör n
sinifl rin v  ya bu sinfin dost elan etdiyi dig r dost-sinif
 dost-funksiyalar  eyni hüquqdan faydalana bilm zl r.
Dost-sinif t yini birt fli t yindir. Y ni, A B-ni dost
elan etmi dir, B A-n n xüsusiyy tl rini istifad  ed  bil r.
Lakin A  B-nin xüsusiyy tl rini istifad  ed  bilm z.
Çünki, B A-n  dost elan etm mi dir.
Dost-funksiya t yini layih ndirici (constructor) v
yoxedici (destructor) funksiyas  il  m nims tm  “=”
Etibar Seyidzad
 96
operatoru qar nda t sirsizdir. Bu funksiyalar üzv
funksiyalar olmaq m cburiyy tind dirl r.
Dig r bir f rq d , dost funksiyalar n dost olduqlar
bir sinfin üzvl rin  birba a müraci t etm ridir.
class Noqte
{  float X, Y, Z;
public:
   Noqte(float, float, float);
friend void Yaz(Noqte&);
};
yinind n sonra
#include <stdio.h>
void Yaz(Noqte&)
{   printf(“(%d, %d, %d)”, X, Y, Z);  }
kimi kodla la bilm z. Ona gör  ki, Yaz funksiyas n
istifad  etdiyi X, Y, Z d yi nl rinin n  olduqlar  b lli
deyildir. (Biz  gör  bu d yi nl r Noqte sinfinin
yi nl ridir. Lakin Yaz funksiyas  bu d yi nl ri
birba a istifad  ed  bilm z. r a dak  kimi
kodla rma apar larsa,
#include <stdio.h>
void Yaz(Noqte& _noqte)
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
97
{   printf(“(%d, %d, %d)”, _noqte.X, _noqte.Y, _noqte.Z);  }
X, Y, Z-in _noqte obyektinin üzvl ri oldu u ba a
dü ül kdir; Bu üzvl rin private t yininin qar
olaraq Yaz funksiyas n dost t yini bu xüsusi üzvl
müraci ti t min edir.
4.3 Obyekl rin Operatorlara
Yükl nm si
yin olunmu  yeni sinifl rin operatorlara
yükl nm si mümkündür.
class Vector
{   public:
        float X, Y, Z;
        Vector(float = 0, float = 0, float = 0);
        Vector(Vector&);
};
Vector::Vector(float a, float b, float c)
{   X = a;
    Y = b;
    Z = c;
}
Vector::Vector(Vector& _vector)
{   X = _vector.X;
    Y = _vector.Y;
    Z = _vector.Z;
}
Etibar Seyidzad
 98
Vector sinfini t yin etdikd n sonra indi d  iki
vektorun c mi v  f rqi üçün + v - operatorlar  t yin
ed k.
Vector& operator+(Vector& A, Vector& B)
{   return Vector(A.X + B.X, A.Y + B.Y, A.Z + B.Z);  }
Vector& operator-(Vector& A, Vector& B)
{   return Vector(A.X - B.X, A.Y - B.Y, A.Z - B.Z);  }
Bu t yinl rd n sonra
Vector A(3, 4);
Vector B(8, 6.5 / 3, 1);
Vector C = A + B;
Vector D = A - B;
float f = 67;
Vector E = A – Vector(16, 1, -10) + Vector(f, f * 3, f / 4);
ifad rini yazmaq olar.
Bir vektoru h qiqi dl  geni n vurma
operatorunu a dak  kimi yaza bil rik:
Vector& operator*(Vector& A, float R);
{  return Vector(A.X * R, A.Y * R, A.Z * R);  }
Bu cür t yind n sonra
Vector A(4, 5, 3);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
99
Vector B = A * 2;
do ru
Vector C = 2 * A;
is  s hvdir. Çünki, Vector& operator*(Vector&, float); il
Vector il float qiym tinin hasili t yin edilmi dir. float il
Vector qiym tl rinin hasili ayr qda t yin edilm lidir.
inline Vector& operator*(float R, Vector& A)
{  return A * R;  }
Bir vektorun istiqam tini t rs çevir n unary
operatorunu t yin etm k üçün
Vector& operator-(Vector& A)
{  return Vector(-A.X, -A.Y, -A.Z);  }
yazmaq olar.
Bir sinfin xüsusi (private) üzvl rinin d  operator
funksiyalar  daxilind  istifad  olunmas  t b olunarsa,
bu operator funksiyalar n dost (friend) kimi t yin
olunmas  laz md r.
class Vector
{  float X, Y, Z;
   public:
Etibar Seyidzad
100
Vector(float = 0, float = 0, float = 0);
Vector(Vector&);
   friend Vector& operator+(Vector&, Vector&);
   friend Vector& operator-(Vector&, Vector&);
   friend Vector& operator*(Vector&, Vector&);
   friend Vector& operator*(Vector&, float);
   friend Vector& operator*(float, Vector&);
   friend Vector& operator-(Vector&);
};
Vector& operator+(Vector& A, Vector& B)
{  return Vector(A.X + B.X, A.Y + B.Y, A.Z + B.Z);  }
Operatorlar n ilk parametrl rinin sinfin özünün
olmas  hal nda onlar  üzv funksiya kimi t yin edib
istifad  etm k d  mümkündür.
class Vector
{  float X, Y, Z;
   public:
Vector(float = 0, float = 0, float = 0);
Vector(Vector&);
Vector& operator+(Vector&);
Vector& operator-(Vector&);
Vector& operator*(Vector&);
Vector& operator*(float);
   friend Vector& operator*(float, Vector&);
Vector& operator-();
};
Vector& Vector::operator+(Vector& B)
{  return Vector(X + B.X, Y + B.Y, Z + B.Z);  }
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
101
Vector& Vector::operator-()
{  return Vector(-X, -Y, -Z);  }
4.4 this Lokal D yi ni
//THISNKT.CPP
#include <stdio.h>
class Noqte
{  float X, Y, Z;
   public:
     Noqte(float, float, float);
   friend void Yaz(Noqte&);
     void Hesab();
};
Noqte::Noqte(float x, float y, float z)
{  X = x;
   Y = y;
   Z = z;
}
void Noqte::Hesab()
{  printf("Bu noqte ");
   Yaz(Noqte(X, Y, Z));
   printf(" movqeyindedir\n");
}
void Yaz(Noqte& _noqte)
{  printf("(%f, %f, %f)", _noqte.X, _noqte.Y, _noqte.Z);  }
main()
{  Noqte A(1, 2, 3);
   A.Hesab();
Etibar Seyidzad
102
   return 0;
}
Bu misalda bundan vv lki misala lav  olaraq
Hesab üzv funksiyas ndan istifad  edilmi dir. Yaz
funksiyas  yaln z üzvün koordinatlar , Hesab
funksiyas  is  “Bu noqte (x, y, z) movqeyindedir”
lumat  ekrana ç xaracaqd r. Hesab funksiyas
nöqt nin koordinatlar  ekrana ç xarark n Yaz
funksiyas  ça rmal , ça rark n d  yaz lacaq nöqt ni
parametr olaraq gönd rm lidir.
Burada Yaz funksiyas na parametr verm k üçün
ox ar bir obyekt yarad r. Bu liyyat vaxt v lav
yadda  t b edir. Buna baxmayaraq layih ndiricil r
r zaman ox ar obyekt yarada bilmirl r.
Lakin Hesab v  buna ox ar bütün funksiyalar hans
obyekt  aid olduqlar  haqq nda m lumata malikdirl r. Bu
lumat üzv funksiyas n aid oldu u obyektin
göst ricisi m lumat ndan ibar tdir. Bu göst ricinin ad
r bir obyekt üçün this q bul olunur. Bu d yi n üzv
funksiyalar  üçün avtomatik olaraq t yin olunur.
Baxd z misalda Hesab funksiyas  üçün bu t yin
Noqte *const this klind dir.
stifad si a dak  kimidir:
void Noqte::Hesab()
{  printf("Bu noqte ");
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
103
   Yaz(*this);
   printf(" movqeyindedir\n");
}
this göst ricisind n istifad  ed k obyektin üzv
funksiya v  d yi nl rin  müraci t etm k d
mümkündür. H tta, b n m cburidir. Üzv funksiya
daxilind  obyektinkil rl  eyni adda olan d yi nl r
varsa, bu funksiya obyektin eyni adl  d yi nl rin
müraci t ed  bilm z. Bu halda görm (scope::)
operatorundan da istifad  etm k olmaz. Bel  hallarda this
yi nind n istifad  edilir.
Noqte::Noqte(float X, float Y, float Z)
{  this->X = X;
   this->Y = Y;
   this->Z = Z;
}
4.5 Ümumi Ortaq D yi nl r
r obyekt malik oldu u m lumatlar  bütün
obyektl rd n  qoruyur.  r  b zi  m lumatlar n  bütün
proqramla rma üzvl ri t find n s rb st istifad
edilm si t b olunarsa, bu d yi nl r qlobal
yi nl r kimi t yin edilir.
r bir d yi nin mü yy n bir sinf  m nsub olan
obyektl r t find n istifad  edilm si t b olunarsa, bu
Etibar Seyidzad
104
ist k sinif t yini daxilind  bildirilir. Bu d yi nin t yini
zaman  tipd n vv l static sözü  lav  edil k  yerin
yetirilir.
//STATIC1.CPP
#include <conio.h>
#include <stdio.h>
class Misal
{  int a;
   static int b;
   public:
     Misal(int a, int b)
     { this->a = a;
       this->b = b;
     }
     int De_a()
     { return a; }
     int De_b()
     { return b; }
};
int Misal::b;
main()
{  clrscr();
   Misal A(5, 10), B(8, 15);
   printf("A a = %d, b = %d\n", A.De_a(), A.De_b());
   printf("B a = %d, b = %d\n", B.De_a(), B.De_b());
   printf("A a = %d, b = %d\n", A.De_a(), A.De_b());
   return 0;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
105
Proqram ç
A a = 5, b = 15;
B a = 8, b = 15;
A a = 5, b = 15;
Bu t yin il b d yi ninin bütün Misal
obyektl rind  ortaq istifad  edil yi, dig r obyektl rin
is  bu d yi  birba a müraci t ed  bilm yi
bildirilir. Lakin bu t yin kifay t deyildir. b d yi ni
bundan ba qa sinif xaricind  d
int Misal::b;
klind  t yin edilm lidir.
Bir qayda olaraq d yi nl rin t yini a dak  kimidir:
class sinif_ad
{  static tip1 d yi n1;
   static tip2 d yi n2;
   ...
};
tip1 sinif_ad ::d yi n1;
tip2 sinif_ad ::d yi n2;
...
r laz m g rs , bu d yi nl  ba lan c
qiym t d  m nims tm k olar.
int Misal::b = 30;
Etibar Seyidzad
106
Obyektl r üçün istifad  olunan static açar sözü C-
ki lokal d yi nl r il  eyni m ntiq  malikdir. Y ni
obyekt, proqram icra olunma a ba lad  zaman varl
ortaya qoyur: yadda dan yer ist yir v  ilk qiym tini al r.
Proqram icras  tamamlad qdan sonra varl na son
qoyulur. Lokal t yinl r kimi funksiya icra olunma a
ba lad  anda varl  göst rib, icras  tamamlad qdan
sonra varl na son vermir. Eyni formada üzv
yi nl ri d  obyekt mövcud oldu u anda
(layih ndirici icra olunduqdan sonra) varl  göst rib,
obyekt yox oldu u anda (yoxedici icra olunduqdan
sonra) varl qlar na son qoyulur. static il  t yin edil n bu
üzvl r d  eyni kild  obyektl rin ömür müdd tind n
as  qalmayaraq, proqram n ömür müdd tind n as
hala g lirl r.
static d yi nl r ola bildiyi kimi, static obyektl rin
olamas  da mümkündür.
int Mesafe(float a)
{  static Noqte A(3, 7, -12);
   ...
}
Yaln z burada diqq t edilm si vacib olan hal, h r
hans  bir obyekt mövcud olmazdan vv l, static obyektl r
mövcud olaca  üçün bu obyektl r yarad lark n mövcud
olmayan d yi nl rd n istifad  olunmamal r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
107
int Mesafe(float a)
{  static Noqte A(a, 7, -a);     //Sehv. a-nin qiymeti yoxdur.
   ...
   Noqte B(a, 7, -a); //Do ru. B static deyildir.
   ...
}
4.6 Statik (Static) Funksiyalar
Üzv d yi nl r kimi üzv funksiyalar da static
olaraq  t yin  edil  bil rl r.  Bu  t yin  bax ndan  üzv
funksiyalar  iki müxt lif qrupa ay rmaq olar: statik
(static) v avtomatik (auto) funksiyalar. Normal olaraq
r hans  bir t yin olmazsa, t yin olunmayan bütün üzv
funksiyalar  avtomatik funksiya kimi q bul edilir.
Avtomatik funksiyalar n sas xüsusiyy ti, üzv olduqlar
sinfin bütün üzv d yi n v  funksiyalar  birba a
istifad  ed  bilm ridir. Virtual funksiyalar da daxil
olmaqla, indiy  kimi t yin edib istifad  etdiyimiz bütün
üzv funksiyalar n avtomatik funksiya oldu unu
xat rlayaraq, yaz lark n üzv d yi n v  funksiyalar
nec  istifad  etdikl rin  diqq t edin.
Statik funksiyalar da üzv funksiyas  kimi t yin
edilib istifad  olunmalar na baxmayaraq avtomatik
funksiyalardan iki lam tin  gör  f rql nirl r. Birincisi,
statik funksiyalar üzvü olduqlar  sinfin üzv d yi n v
Etibar Seyidzad
108
funksiyalar ndan avtomatik olanlar  birba a istifad  ed
bilm zl r. kincisi, statik funksiyalar  ça rmaq üçün bir
obyekt  ehtiyac vard r.
Statik funksiyalar sinif daxild  t yin edil rk n
funksiya prototipinin vv lin static açar sözü lav
edilir. Funksiyan n gövd sinin yaz lmas  is  dig r
funksiyalar kimidir. Yaln z sinfin üzv d yi n v
funksiyalar ndan statik kimi t yin edilm nl r birba a
istifad  oluna bilm zl r. Bundan ba qa this lokal
yi ni d  funksiyalar n daxilind  istifad  oluna
bilm z.
class sinif_ad
{  ...
   static funksiya_tipi funksiya_ad (parametr_siyah );
   ...
};
{  ...
   funksiya_tipi sinif_ad ::funksiya_ad (parametr_siyah );
   ...
   ...
}
Statik funksiyalar iki formada ça la bil r: r
statik funksiyan n aid oldu u sinfin bir obyekti
mövcuddursa, bu obyekt saslanaraq bir statik funksiya
sanki, avtomatik bir funksiya kimi ça la bil r. V  ya
statik funksiyan n ad ndan vv l aid oldu u sinfin ad
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
109
:: görm  (scope) operatorunu yazaraq, statik
funksiyan  ça rmaq mümkündür.
//STATIC.CPP
#include <conio.h>
#include <stdio.h>
class Static_Misal
{  int X;
   static int Y;
   public:
     Static_Misal(int);
     int X_Qiymeti();
     void Auto_Yaz();
     static void Static_Yaz();
     static void Static_Message();
};
int Static_Misal::Y = 300;
Static_Misal::Static_Misal(int x)
{  X = x;  }
int Static_Misal::X_Qiymeti()
{  return X;  }
//avtomatik funksiyanin yazilmasi
void Static_Misal::Auto_Yaz()
{  printf("x = %d\t", X);
   printf("** %d **\n", X_Qiymeti());
   printf("\ny = %d\n", Y);
Etibar Seyidzad
110
   //Static funksiya avtomatik funksiyadan cagrilir
   Static_Message();
}
//statik funksiyanin yazilmasi
void Static_Misal::Static_Yaz()
{  /*
   printf("x = %d\t", X);
   //Error: Memeber X cannot be used without an object
   //Sehv:  X uzvu obyekt olmadan istifade oluna bilmez
   printf("** %d **\n", X_Misal());
   //Error: Use . or -> to call 'Static_Misal::X_Qiymeti()'
   //Sehv:  'Static_Misal::X_Qiymeti()' cagirilarken
   //. ve ya -> istifade edin
   //Qeyd: Bunun ucun da yeni bir obyekte ehtiyac vardir.
   */
   printf("\ny = %d\n", Y);
   //Static funksiyasi static funksiyasindan cagirilir
   Static_Message();
}
void Static_Misal::Static_Message()
{  printf("\nStatic_Misal, Static_Message funksiyalari\n");  }
main()
{  clrscr();
   Static_Misal A(8);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
111
   A.Auto_Yaz();
   A.Static_Yaz();
   printf("\n");
   //Static_Misal::Auto_Yaz();
   //Error: Use . or -> to call "Static_Misal::Auto_Yaz()'
   //Sehv:  'Static_Misal::Auto_Yaz()' cagrilarken
   //. ve ya -> istifade edin
   Static_Misal::Static_Yaz();
   return 0;
}
Proqram ç
x = 8    ** 8 **
y = 300
Static_Misal, Static_Message funksiyasi
y = 300
Static_Misal, Static_Message funksiyasi
y = 300
Static_Misal, Static_Message funksiyasi
Etibar Seyidzad
112
4.7 const Funksiyalar
Bir obyektd n bir m lumat  almaq üçün istifad
olunan üzv funksiyalar n, yaz lark n s hv n d  olsa,
üzv d yi nl rini d yi dirm si arzuolunmazd r.
Daxilind  bu cür funksiyalar n t yin edilm si zaman  bu
ist k parametr siyah ndan sonra const (sabit) açar sözü
yaz laraq bildirilir. T yin edil rk n sonunda const (sabit)
açar sözü olan funksiyalar lumat funksiyas
adland r. Bu funksiyalar üzv d yi nl rinin
qiym tl rini d yi dir  bilm dikl ri kimi, funksiyas
olmayan dig r funksiyalar  da ça ra bilm zl r.
class sinif_ad
{  ...
   int const_funksiyas (parametr_siyah ) const;
   ...
}
int sinif_ad ::const_funksiyas (parametr_siyah ) const
{  ...
   return qiym t;
}
4.8 ç-iç  T yinl r
Sinfin t yin edilm si zaman  yeni bir sinif v  ya tip
 t yin etm k olar. T yin edil n bu yeni tip, t yin
olundu u sinfin ad  il  b rab r istifad  edilir. Bu da t yin
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
113
olundu u sinfin ad ndan sonra görm  (:: scope)
operatoru v  ad n yaz lmas  il  yerin  yetirilir.
sinif_ad ::tip_ad
sinif_ad ::enum_qiym ti
//ARRAYNST.CPP
#include <conio.h>
#include <stdio.h>
struct Uzv
{  int X;
   char *Ad;
   Uzv(char* ad = "XxXxX", int a = 0)
   {  Ad = ad; X = a;  }
   void Yaz()
   {  printf("::Uzv %s %d\n", Ad, X);  }
};
class Massiv
{  public:
     struct Uzv
     {  int X, Y;
Uzv(int a = 0, int b = 0)
{  X = a; Y = b;  }
void Yaz()
{  printf("Massiv::Uzv %d %d\n", X, Y);  }
     };
     Uzv A[10]; //Massiv daxilinde teyin olunan Uzv obyekti
     ::Uzv B[10];
Etibar Seyidzad
114
 //Massiv xaricinde teyin olunan Uzv obyekti
 //Her iki teyinetmeye diqqet edin
   public:
     Massiv(char *, int, int);
};
Massiv::Massiv(char* n, int t, int s)
{  for(int i = 0; i < 10; i++)
   {  A[i].X = t;
      A[i].Y = s;
      B[i].Ad = n;
      B[i].X = s;
   }
}
main()
{  clrscr();
   Massiv::Uzv K;
   K.Yaz();
   //K Massiv daxilinde teyin edilen obyektdir.
   Uzv H;
   H.Yaz();
   //H Massiv xaricinde teyin edilen obyektdir.
   //Burada ::Uzv H seklinde istifade edile biler.
   return 0;
}
Proqram ç
Massiv::Uzv 0 0
::Uzv XxXxX 0
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
115
4.9 Obyekt Göst ricil ri
Bir obyektin göst rici kimi t yin olunmas C-d
oldu u kimidir:
Massiv *A;
Noqte *C;
Noqte **D;
Bu cür t yinl rd  obyekt deyil, sad , obyekti
göst n  bir  göst rici  vard r.  Buna gör  d  t yin  zaman
layih ndiricinin, proqram bloku tamamland qdan sonra
da yoxedicinin icra olunaca  gözl k olmaz. Bu ist k
proqramç  t find n t yin olunur.
main()
{  Massiv massiv(20, 10);
   Massiv *massivPtr = &massiv;
   ...
   ...
   return 0;
} //massiv obyekti özü yox olur.
r obyekt göst ricil ri üçün yadda da dinamik
olaraq bir yer ayr larsa, bunun üçün new v  ayr lm  bu
obyektin silinm si üçün d delete operatorunun istifad
edilm si laz md r.
main()
{  Massiv *massiv = Massiv(10, 20);
Etibar Seyidzad
116
   Massiv *massivPtr;
   massivPtr = new Massiv(30, 40);
   ...
   ...
   delete massivPtr;
   ...
   ...
   int PaketSayi = 30;
   int PaketUzunlugu = 6*;
   massivPtr = new Massiv(PaketSatisi *PaketUzunlugu, 0);
   ...
   ...
   delete massivPtr;
   delete massiv;
   return 0;
}
new operatoru yer ay rd  obyektin
layih ndiricisini, delete operatoru  da  bu  obyektin
yoxedicisini avtomatik çal r. Buna gör  d new
operatoru istifad  edil rk n obyektin
layih ndiricil rind n biri new operatorundan sonra
yaz r. delete opertorunun istifad  edilm sind  is
sad  obyekt göst ricisi verilir. Burada new il  yer
ayr lmam  obyektl ri delete il , new il  yer ayr lm
olsalar bel , eyni obyekti bir d n art q silm k olmaz.
Massiv massiv(20, 30);
…
delete massiv;
Massiv* massivPtr = new Massiv(20, 30);
...
delete massivPtr;
delete massivPtr;
 Yuxar da göst ril nl rin h r biri s hv  yol aça bil r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
117
4.10 Obyekt Massivi
Standart (default) layih ndiriciy  malik olmaq
rti il  bir sinfin obyektl rind n ibar t olan massiv ld
etm k mümkündür.
//MASARRAY.CPP
#include <conio.h>
#include <stdio.h>
class Massiv
{  public:
     int Olcu;
     float *f;
     Massiv(int n = 50);
     ~Massiv();
};
Massiv::Massiv(int n)
{  static say = 0;
   f = new float(Olcu = n);
   printf("%d\tolcu %d\n", ++say, Olcu);
}
Massiv::~Massiv()
{  printf("Yoxedici\tolcu = %d\n", Olcu);
   delete f;
}
main()
{  clrscr();
   Massiv *A = new Massiv(20);
//20 elementlik bir Massiv gostericisi
   Massiv *B = new Massiv;
//50 elementlik bir Massiv gostericisi
Etibar Seyidzad
118
   Massiv *C = new Massiv[10];
//50 elementden ibaret Massivlerin massivi
   *(A -> f + 5) = 1.00;
//A-nin gosterdiyi Massivin 5-ci elementi
   *(B -> f + 5) = 2.00;
//B-nin gosterdiyi Massivin 5-ci elementi
   *((C + 8) -> f + 5) = 3.00;
//C-nin gosterdiyi massivlerin 8-ci sirasindaki
//Massivin 5-ci elementi
   *(C[8].f + 5) = 4.00;
//C-nin gosterdiyi massivlerin 8-ci sirasindaki
//Massivin 5-ci elementi
   delete A;
//Bir Massiv obyekti silinir. (20 elementli)
   delete B;
//Bir Massiv obyekti silinir. (50 elementli)
   delete []C;
//10 Massiv obyekti silinir. (Her biri 50 elementli)
   return 0;
}
Burada delete [ ]C; yerin delete [10]C; kimi C
massivinin ölçüsü d  yaz la bil r. Lakin bu mr massivi
tamamil  sildiyi üçün möt riz rin daxilind  veril n
massivin ölçüsünü n  almayacaqd r. V  komplyator
bunu Siz  “Array size for ‘delete’ ignored” m lumat  il
bildir kdir. Bu s hvd n qurtulmaq üçün ”#pragma
warn dsz-“ direktivind n istifad  ed  bil rsiniz.
Burada delete [ ]C; yerin delete C; mri istifad
edil rs , C-nin ilk elementi silin kdir ki, bu da
xo ag lm z hallar n yaranmas na s b olacaqd r. Buna
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKTL N XÜSUS YY TL
119
gör  d delete mrind n bu kild  istifad  etm k
qs uy un deyildir.
r istifad  etm k ist diyiniz obyektin standart
layih ndiricisi yoxdursa v  ya yarad lacaq obyektl r
bir-birind n f rqli xüsusuyy tl r da yacaqlarsa, bu halda
obyekt göst ricil ri massivind n istifad  etm k
qs uy undur.
//MASPTRAR.CPP
#include <conio.h>
#include <stdio.h>
class Massiv
{  public:
     int Olcu;
     float *f;
     Massiv(int n = 50);
     ~Massiv();
};
Massiv::Massiv(int n)
{  static say = 0;
   f = new float(Olcu = n);
   printf("%d\tolcu %d\n", ++say, Olcu);
}
Massiv::~Massiv()
{  printf("Yoxedici\tolcu = %d\n", Olcu);
   delete f;
}
#define MasOlcu 10
Etibar Seyidzad
120
main()
{  clrscr();
   int i;
   //Gostericiler ucun yer ayirma
   Massiv **A = new Massiv*[MasOlcu];
   //Her bir gostericinin gosterdiyi obyekti yaratmaq ve menimsetmek
   for(i = 0; i < MasOlcu; i++)
      A[i] = new Massiv(i * 2 + 10);
   //Istifade edilmesi
   *(A[2] -> f + 5) = 1.0;
   //Her bir obyekti bir-bir silme emeliyyati
   for(i = MasOlcu - 1; i >= 0; i--) delete A[i];
   //Gosterici sahelerini silme emeliyyati
   delete []A;
   return 0;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
121
V F L
OBYEKT TÖR TM K
5.1. Tör tm liyyat
Bir sinf saslanaraq onun yerin  yetirdiyi i in
mahiyy tini d yi dirm k v  ya inki af etdirm k kimi icra
olunan liyyatlara tör tm  (derivation) deyilir.
Tör tm liyyat n yerin  yetirilm si üçün t yin
olunmu  bir sinif mövcud olmal r. Tör tm
liyyat nda istifad  olunan bu mövcud sinf baza sinfi
(base class) deyilir. Tör tm  n tic sind  meydana g n
obyekt  is tör nmi  sinif (derivated class) ad  verilir.
Ba qa sözl  baza sinfin valideyn (parent), tör nmi  sinf
is aq (child) ad  verilir.
da göst rilmi  iki metodla sinif tör tm k  olar:
1. Bir sinfin üzv funksiyalar ndan birinin
zif rini ba qa bir formada yerin  yetir k
klind  d yi dirm kl ;
2. Obyektin v zif rini art raraq yeni üzv
funksiyalar  etm k, y ni inki af etdirm kl .
Obyekt tör rk n bu iki metodun h r ikisi ayr -
ayr qda v  ya b rab r istifad  oluna bil r.
Etibar Seyidzad
122
5.2 Sinifl rin Tör dilm si
//MESAJ.CPP
#include <stdio.h>
#include <string.h>
class Mesaj
{  char *mesaj[5];
   public:
     Mesaj();
     ~Mesaj();
     int Deyisdir(int, char* = "");
     int Xeber(int);
};
Mesaj::Mesaj()
{  int i;
   for(i = 0; i < 5; i++)
   {  mesaj[i] = new char[1];
      strcpy(mesaj[i], "");
   }
}
Mesaj::~Mesaj()
{  int i;
   for(i = 0; i<5; i++) delete mesaj[i];
}
int Mesaj::Deyisdir(int i, char *mes)
{  if(i < 0 || i > 5)
     return -1;
   delete mesaj[--i];
   mesaj[i] = new char[strlen(mes) + 1];
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
123
   strcpy(mesaj[i], mes);
   return 0;
}
int Mesaj::Xeber(int n)
{  if(n < 0 || n > 5)
   {  printf("\nDaxili sehv: Xeberdarliq mesajinin nomresi sehvdir\n");
      return -1;
   }
   printf("%s\n", mesaj[n-1]);
   return 0;
}
Bu sinifl rin t tbiqi n tic sind  a dak  proqram
yazaraq növb ti n tic ni ld  etm k olar:
//MMESAJ.CPP
#include <conio.h>
#include "mesaj.cpp"
Mesaj Xeberd;
main()
{  clrscr();
   Xeberd.Deyisdir(1, "\nYoxlama xeberdarligi");
   Xeberd.Deyisdir(2, "\nCixis xeberdarligi");
   Xeberd.Xeber(1);
   Xeberd.Xeber(21);
   Xeberd.Xeber(2);
   Xeberd.Xeber(1);
   return 0;
}
Proqram ç
Etibar Seyidzad
124
Yoxlama xeberdarligi
Daxili sehv: Xeberdarliq mesajinin nomresi sehvdir
Cixis xeberdarligi
Yoxlama xeberdarligi
ndi is  x rdarl q m saj n nömr si t k is ,
proqram Enter düym sini s xana q r gözl sin, cüt is
gözl n icras  tamamlas n. Xeber hiss si istisna
olmaqla bu strukturun dig r funksiyalar  eyni qals n. Bu
halda Mesaj sinfini  baza  kimi  q bul  edib Sehv sinfini
tör tm k daha m qs uy undur.
//SEHV.CPP
#include "mesaj.cpp"
#include <conio.h>
#include <stdlib.h>
struct Sehv : Mesaj
{  Sehv() { }
   int Xeber(int);
};
int Sehv::Xeber(int N)
{  int Err = Mesaj::Xeber(N);
   if(N % 2)
   {  printf("\nDavam etmek ucun ENTER duymesini sixin.");
      while(getch() != 13);
      printf("\n");
   }
   else
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
125
   {  printf("\nProqram icrasin  davam etdire bilmir.\n");
      exit(N);
   }
   return Err;
}
Yeni sinfin t yin edilm si zaman  baza sinfinin sas
sinif ad ndan sonra yaz ld na diqq t edin. class Sehv :
Mesaj t yini Sehv sinfinin Mesaj sinfind n tör ndiyini
göst rir. Dig r bir halda r laz m g rs , yeni sinfin
layih ndirici v  yoxedici funksiyalar  dig r üzv
funksiyalar ndan f rqli olaraq tör nmi  olduqlar  sinfin
layih ndirici v  ya yoxedici funksiyalar  avtomatik
olaraq istifad  verirl r.
Sehv sinfi üçün Xeber funksiyas  yenid n
yaz lark n Mesaj sinfinin Xeber funksiyas na ehtiyac
oldu u zaman, bu ehtiyac Mesaj sinfinin Xeber
funksiyas n Mesaj::Xeber klind  ça lmas  il
öd nilmi  olur. Bu ça  yerin  yetirm k vacib deyildir.
Eyni formada “u aq” sinfinin “valideyn” sinfind n olan
bir funksiyan  ça rmas sas nda ça lan funksiyan n
ad  öz funksiyalar n ad  il  üst-üst  dü ürs , bu
funksiyan sas sinfin “valideyn”l rind n olmaq rti il
:: (görm ) operatorundan istifad  ed k ça rmaq
mümkündür. Mesaj::Deyisdir() kimi.
ndi d  bundan vv lki misal Sehv sinfi il  yenid n
yazaq:
Etibar Seyidzad
126
//MSEHV.CPP
#include <conio.h>
#include "sehv.cpp"
Sehv Xeberd;
main()
{  clrscr();
   Xeberd.Deyisdir(1, "\nYaxlama xeberdarligi");
   Xeberd.Deyisdir(2, "\nCixis xeberdarligi");
   Xeberd.Xeber(1);
   Xeberd.Xeber(21);
   Xeberd.Xeber(2);
   Xeberd.Xeber(1);
   return 0;
}
Proqram ç
Yaxlama xeberdarligi
Davam etmek ucun ENTER duymesini sixin.
Daxili sehv: Xeberdarliq mesajinin nomresi sehvdir
Davam etmek ucun ENTER duymesini sixin.
Cixis xeberdarligi
Proqramin icrasi tamamlandi.
Bu misalda Sehv sinfi üçün Deyisdir funksiyas n
varm  kimi istifad  edilm sin  diqq t edin. H qiq td
is Sehv sinfi Deyisdir v zif sini Mesaj sinfinin t tbiq
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
127
etdiyi metoddan istifad  ed k yerin  yetirir. Xeber
zif si oldu u zaman is Sehv bunu öz metodlar na
gör  yerin  yetirir. Sehv v zif sini yerin  yetir rk n
Mesaj-dan da faydalana bilir.
5.3 Müraci t Haqlar  v  Nüfuz Etm
Bir sinfin üzvl rin  (d yi n v  metodlar na)
müraci t ed  bil n xarici agentl r üç sinf  bölünür. Bir
tör dilmi  sinif, baza sinfi daxilind ki qorunmu
(protected) v  t bii ki, ümumi (public) kimi t yin edilmi
üzvl  müraci t hüququna malikdir.
Tör dilmi  sinif baza q bul edil k yeni bir
obyektin tör dilm si t b olundu unda, son tör dil n
sinif ilk tör dil n sinf  bu sinfin mü yy n etdiyi
hüquqlar il  müraci t ed  bil kdir. Lakin bu halda sas
bazan n üzvl rin  müraci t hüququ nec  olacaqd r?
Burada tör dil n sinfin, özünd n tör n sinifl
vv lki sinifl rd n qalan miras  nec  t hvil ver yini
mü yy n etm k laz md r. Bu o sinfin nüfuz etm
qabiliyy tini mü yy n edir.
class A { ... };
class B : public A { ... };
class C : private A { ... };
class D : A { ... };
class E : A { ... };
Etibar Seyidzad
128
Burada A t yin edilmi  baza sinfidir. B, C, D v E is
A-dan tör nmi  sinifl rdir. B-nin t yin edilm si zaman
A-n n vv lind ki public ifad si B-nin A-dan t hvil ald
miras  eyni hüquqlarla (A-n n B-y  verdiyi hüquqlarla)
özünd n sonrak lara t hvil verm si m nas na g lir.
C d A-dan tör nm sin  r n onun t yin
edilm si zaman private ifad sind n istifad  edildiyi üçün
C A-dan ald  bütün xüsusiyy tl ri özünd n tör n
sinifl private kimi t hvil ver kdir. Burada A-n n
public xüsusiyy tl rinin bel B-d n tör nl r üçün
istifad  edilm sinin qada an olmas na diqq t edin.
Nüfuz etm  public
public public
protected protected
private private
Nüfuz etm  private
public private
protected private
private private
D v E sinifl rinin t yin edilm si a dak  kimidir:
class D : public A { ... };
class E : private A { ... };
Buna s b, vv lc n qeyd edildiyi kimi class
vasit sil  edil n t yinl rd  müraci t hüququ mü yy n
edilm diyi zaman private, struct vasit sil  edil n
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
129
yinl rd  is public oldu unun avtomatik q bul
edilm sidir.
5.4 Dinamik Yükl
Baza sinfi v  tör dilmi  sinif aras ndak miyy tli
olan laq rd n biri d  baza sinfinin göst ricisin
tör dilmi  sinfin ünvan n m nims dil  bilm sidir. Bu
dinamik yükl  (dinamic binding) qaydas n meydana
lm sini t min ed n bir hadis dir. Lakin bu
nims tm  dinamik yükl nin meydana g lm si
üçün kifay t deyildir. Bunu bir misal il  izah ed k:
//CLASSPOI.H
#include <stdio.h>
#include <conio.h>
class Baza
{  protected:
     int X, Y;
   public:
     Baza(int C)
     {  X = C; Y = 2 * C;  }
     void Goster()
     { printf("Baza X = %d\tY = %d\n", X, Y);  }
};
class Toremis:public Baza
{  public:
     int Z;
Etibar Seyidzad
130
     Toremis(int e) : Baza(e)
     {  Z = X + Y;  }
     void Goster()
     {  printf("Toremis X = %d\tY = %d\tZ = %d\n", X, Y, Z);  }
};
main()
{  clrscr();
   Baza A(1);
   Toremis B(2);
   Baza *C;
   printf("A.Goster\n\t");
   A.Goster();
   printf("B.Goster\n\t");
   B.Goster();
   printf("C = &A\nC->Goster\n\t");
   C = &A;
   C -> Goster();
   printf("C = &B\nC->Goster\n\t");
   C = &B;
   C -> Goster();
   return 0;
}
Proqram ç
A.Goster
    Baza X = 1 Y = 2
B.Goster
    Toremis X = 2 Y = 4 Z = 6
C = &A
C->Goster
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
131
      Baza X = 1 Y = 2
C = &B
C->Goster
      Baza X = 2 Y = 4
Bu misalda tör dil n sinfin daxilind  baza sinfinin
üzvü olan Goster() funksiyas  yenid n t yin olunmu dur.
Bu t yin do rudur (B obyektinin Goster() xüsusiyy tinin
olmas na diqq t edin). Bel  ki, baza sinfinin göst ricisin
tör dilmi  sinif m nims dildikd n sonra göst ricid n
Goster() xüsusiyy tini verm si t b olunarsa, bu ancaq
tör dilmi  sinfin obyektinin m lumatlar  il  baza sinfinin
imkanlar n ortaya qoyulmas  ola bil r. Bu hal
komplyatorun komplyasiya zaman  davran lar ndan
qaynaqlan r.
Bunun qar  alma n n yax  yolu baza sinfi
yin edil rk n tör dil n sinifl rin d yi dir kl ri
metodlar  x yali (virtual) t yin etm kdir. Bu s bd n d
bu cür metodlar n prototip t yin etm rin virtual
açarsözü il  ba lamaq laz md r.
Buna gör  d  laz m olan s liliyi ld  etm k
üçün yuxar dak  misalda Baza sinfinin üzv funksiyas
olan void Goster() funksiyas virtual sözü il  ba layaraq
virtual void Goster() kimi t yin edilm lidir. Bu cür t yin
etm  yerin  yetirildikd n sonra tör dil n sinifl r üçün
virtual t yin etm nin h yata keçirilm sinin v  ya
keçirilm sinin heç bir miyy ti yoxdur. X yali üzv
Etibar Seyidzad
132
sahib olan sinifd n tör nmi  sinifl rin eyni adl  üzvl ri d
yali xüsusiyy t da rlar.
//CLASSPOI.H duzeldilmis hissesi
class Baza
{  protected:
     int X, Y;
   public:
     Baza(int C)
     {  X = C; Y = 2 * C;  }
    virtual void Goster()
     { printf("Baza X = %d\tY = %d\n", X, Y);  }
};
Proqram ç  (düz li n sonra)
A.Goster
    Baza X = 1 Y = 2
B.Goster
    Toremis X = 2 Y = 4 Z = 6
C = &A
C->Goster
      Baza X = 1 Y = 2
C = &B
C->Goster
      Baza X = 2 Y = 4
Bu  i  prinsipini  bu  cür  rh  etm k  olar: virtual
açarsözü olmadan edil n t yinl rd  obyektin yaln z
lumat sah ri (d yi nl ri) yadda da saxlan r.
Metodlar  üçün  is  komplyator  q rar  verir.  Lakin  metod
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
133
yali t yin edil rs , bu, metodun yadda dak  yerin  aid
lumatda (ba lan c ünvan ) obyektin dig r m lumat
sah ri il  birlikd  yadda da saxlan r. Bel  bir metod
ça ld  zaman da yadda dak  bu yer il laq dar olan
lumat istifad  edil k haqq nda söhb t aç lan
obyektin metoduna müraci t etm si t min olunur.
Xüsusil  d  bir sinfin metodlar  xaricind  yoxedicil rinin
 x yali olaraq t yin edilm sin  imkan verilir.
Layih ndiricil r is  x yali olaraq t yin edil  bilm z.
5.5 Qaydal  Funksiyalar
Obyektl rl  proqramla rma zaman sas n bütün
obyektl r ümumi kild  deyil, eyni liyyatlar üçün
rd  tutulanlar t snifl ndiril k baza obyektind n
tör dilir. Ümumi xüsusiyy tl r d  mümkün olmad qca
baza  obyekti  daxilind  c ml k  yen  bu  obyekt  üçün
yaz r. Bundan sonra sas obyektl r yaz laraq proqram
ortaya ç r.
n, yril rl laq dar bir proqramda çevr
radiusu, ellips radiusu, qövs kimi yril rin olmas  v  bu
yril rin f zadak  yerl rinin v  uzunluqlar n
hesablanmas  t b oluna bil r.
Eyri
Qovs Cevre_Radiusu Ellips_Radiusu
Etibar Seyidzad
134
Bu halda bütün obyektl ri bir Eyri sinfind n
tör tm k mümkündür. liyyatlar  yerin  yetirm k
üçün Eyri sinfinin yril rin yeri v  ölçül ri il laq dar
üzv funksiyalar  olmal r.
//EYRI.CPP
class Eyri
{  protected:
     int _X, _Y;
   public:
     Eyri();
     Eyri(const Eyri&);
     Eyri(int, int);
   virtual char* Ad() const;
     int Yer_X() const;
     int Yer_Y() const;
   virtual void Yer_X(int);
   virtual void Yer_Y(int);
   virtual int Uzunluq() const;
};
Eyri::Eyri()
{  _X = _Y = 0; }
Eyri::Eyri(const Eyri& eyri)
{  _X = eyri._X;
   _Y = eyri._Y;
}
Eyri::Eyri(int x, int y)
{  _X = x;
   _Y = y;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
135
char* Eyri::Ad() const
{  return "EYRI";  }
int Eyri::Yer_X() const
{  return _X;  }
int Eyri::Yer_Y() const
{  return _Y;  }
void Eyri::Yer_X(int x)
{  _X = x;  }
void Eyri::Yer_Y(int y)
{  _Y = y;  }
Lakin Uzunluq funksiyas  yazmaq laz m g ldiyi
zaman Eyrin-in uzunlu unun n  oldu u v  ya nec
hesablanaca  mü yy n olmad  üçün Uzunluq
funksiyas  ancaq sonradan yaz lmaq rti il  müv qq ti
bir funksiya kimi yaz la bil r.
EYRI.CPP  davam
int Eyri::Uzunluq() const
{  return 0;  }
Bu cür t yinl rin üç sas m nfi c ti vard r:
1. Sonradan istifad  edilm sin  baxmayaraq t yin
olunan bu funksiyalar, proqram daxilind
istifad  olunmayacaqlar na baxmayaraq
proqram n böyüm sin  s b olacaqlar;
Etibar Seyidzad
136
2. Proqramç lar istifad  etm dikl ri bu proqram
parçalar  yazmal  olacaqlar;
3. kd  yaz lmas  unuduldu u zaman s hv
tic r ver kdir.
Bu hallardan qurtulman n yolu is , sinif daxilind
bu cür sonradan yaz lmas  t b olunan funksiyalar  t yin
etdikd n sonra “= 0“ ifad sini yazmaqd r. Bu yaz  bel ,
bir funksiyan n olmas n vacibliyini, ancaq onun bu
rh  yaz lmayaca  v  sonrak  m rh rd  bu
sinifd n tör n sinifl rin h min funksiyan  t yin ed k
funksiyas nda yazacaqlar  bildirir. Bu funksiyalar
sonradan tör n sinifl r daxilind  yaz lacaqlar  üçün
onlar yali (virtual) t yin edilm lidirl r. Bu funksiyalar
yali funksiyalardan f rql ndirm k üçün onlara x yali
kor funksiya (pure virtual) v  ya qaydal  funksiya ad
verilir.
Daxilind  bu cür funksiyalar olan sinifl rd n obyekt
yarad la bilm z. Bu sinifl r ümumi m qs dl r üçün
istifad  edilir. Bu cür sinifl müc rr d (abstract) sinif
ad  verilir. Yuxar dak  misalda Eyri sinfi abstarakt
sinifdir. Proqram daxilind Eyri ad nda  bir  obyekt  ola
bilm z. Ancaq Eyri-d n tör nmi  h qiqi sinifl rin (Xett,
Cevre_Qovsu kimi) obyektl ri ola bil r.
Proqram n strukturu yrinin müxt lif liyyatlar
üçün bir obyektd  ehtiyac duyuldu u zaman müc rr d
sinfin obyektl rinin yerin  göst ricil ri v  ya t qdimatlar
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
137
ola bil r. T bii ki, bu halda göst rici v  ya t qdimatlara
qiqi obyektl r m nims dilm lidir.
n,
main()
{   Eyri A1;
    ...
    return 0;
}
kimi bir proqram, müc rr d sinif obyektind n istifad
etdiyi üçün yaz la bilm diyi halda
main()
{   Eyri* Eptr = new Line(100, 100, 300, 600);
    ...
    return 0;
}
 ya
main()
{   Eyri*& Eptr = new Line(100, 100, 300, 600);
    ...
    delete Eref;
    return 0;
}
proqramlar  yaz laraq istifad  oluna bil rl r.
Etibar Seyidzad
138
5.6 Misallar
5.6.1 Curve
Qaydal  funksiyalar üçün veril n misal
tamamlayaq.
//EYRI2.CPP
class Eyri
{  protected:
     int _X, _Y;
   public:
     Eyri();
     Eyri(const Eyri&);
     Eyri(int, int);
   virtual char* Ad() const = 0;
     int Yer_X() const;
     int Yer_Y() const;
   virtual void Yer_X(int);
   virtual void Yer_Y(int);
   virtual int Uzunluq() const = 0;
};
Eyri::Eyri()
{  _X = _Y = 0; }
Eyri::Eyri(const Eyri& eyri)
{  _X = eyri._X;
   _Y = eyri._Y;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
139
Eyri::Eyri(int x, int y)
{  _X = x;
   _Y = y;
}
int Eyri::Yer_X() const
{  return _X;  }
int Eyri::Yer_Y() const
{  return _Y;  }
void Eyri::Yer_X(int x)
{  _X = x;  }
void Eyri::Yer_Y(int y)
{  _Y = y;  }
//********************************************
#include <math.h>
#include <stdlib.h>
class Cevre_Qovsu : public Eyri
{  protected:
     int _Radius;
     int _BaslangicBucagi;
     int _SonBucagi;
   public:
     Cevre_Qovsu();
     Cevre_Qovsu(const Cevre_Qovsu&);
     Cevre_Qovsu(int, int, int = 1, int = 0, int = 360);
     Cevre_Qovsu(int);
     virtual char* Ad() const;
     virtual int Uzunluq() const;
};
Cevre_Qovsu::Cevre_Qovsu()
Etibar Seyidzad
140
{ _Radius = 1;
  _BaslangicBucagi = 0;
  _SonBucagi = 360;
}
Cevre_Qovsu::Cevre_Qovsu(const Cevre_Qovsu& qovs) : Eyri(qovs)
{ _Radius = qovs._Radius;
  _BaslangicBucagi = qovs._BaslangicBucagi;
  _SonBucagi = qovs._SonBucagi;
}
Cevre_Qovsu::Cevre_Qovsu(int x, int y, int r, int a, int b) : Eyri(x, y)
{ _Radius = r;
  _BaslangicBucagi = a;
  _SonBucagi = b;
}
Cevre_Qovsu::Cevre_Qovsu(int r)
{ _Radius = r;
  _BaslangicBucagi = 0;
  _SonBucagi = 360;
}
char* Cevre_Qovsu::Ad() const
{  return "Cevre Qovsu";  }
int Cevre_Qovsu::Uzunluq() const
{ return (int) 1.0 * _Radius * 2 * M_PI *
       abs(_SonBucagi - _BaslangicBucagi)/360.0;
}
#define SQR(a) ((float)(a) * (float)(a))
class Xett : public Eyri
{  protected:
     int _SonX;
     int _SonY;
   public:
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
141
     Xett();
     Xett(const Xett&);
     Xett(int, int, int, int);
     Xett(int, int);
     virtual char* Ad() const;
     virtual int Uzunluq() const;
};
Xett::Xett()
{  _SonX = 1;
   _SonY = 1;
}
Xett::Xett(const Xett& xett) : Eyri(xett)
{  _SonX = xett._SonX;
   _SonY = xett._SonY;
}
Xett::Xett(int x1, int y1, int x2, int y2) : Eyri(x1, y1)
{  _SonX = x2;
   _SonY = y2;
}
Xett::Xett(int x, int y)
{  _SonX = x;
   _SonY = y;
}
char* Xett::Ad() const
{  return "Xett";  }
int Xett::Uzunluq() const
{  return sqrt(SQR(_SonX - Yer_X()) + SQR(_SonY - Yer_Y()));  }
//*******************************************************
#include <conio.h>
#include <stdio.h>
Etibar Seyidzad
142
Eyri *EyriMassivi[20];
void Hesab()
{  int i;
   printf("%3s %-22s %5s %5s %5s\n%30s %5s\n"
 "___ _______________________________________\n",
 "No","Eyri Tipi","Yer","","Olcu","X","Y");
   for(i = 0; i < 20; i++)
      if(EyriMassivi[i])
      {  printf("%2d %-22s %5d %5d %5d\n",
 i, EyriMassivi[i]->Ad(),EyriMassivi[i]->Yer_X(),
 EyriMassivi[i]->Yer_Y(),EyriMassivi[i]->Uzunluq());
      }
}
main()
{  clrscr();
   randomize();
   int i = 0;
   for(i = 0; i < 20; i++)
      if(random(2))
EyriMassivi[i] = new Xett(random(100), random(100),
  random(200), random(300));
      else
      {  int baslangicbucagi = random(180);
 int sonbucagi = baslangicbucagi + random(180);
EyriMassivi[i] = new Cevre_Qovsu(random(300), random(300),
  random(100), baslangicbucagi,
  sonbucagi);
      }
   Hesab();
   for(i = 0; i < 20; i++)
      if(EyriMassivi[i])
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
143
delete EyriMassivi[i];
   return 0;
}
5.6.2 LineDemo
ttin qrafik ekranda t yin olunmas  v  uc
nöqt sinin h t etdiril k canland lmas
(animasiyas ) üçün yaz lan bir proqrama edil n lav r
il  iki x td n ibar t olan qrup t yini v  eyni proqram n
tbiqi il laq dar misallar  gözd n keçir k:
//LINE.CPP
#include <graphics.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <dos.h>
class Graphics
{  public:
     Graphics();
     virtual ~Graphics();
     virtual void Enter();
     virtual void Leave();
   protected:
     virtual char* getBGIPath();
     virtual void MessageOnExit();
};
Etibar Seyidzad
144
Graphics::Graphics()
{ }
void Graphics::Enter()
{  int grDrv;
   int grMode;
   char* grPath = "";
   int grErr = grOk;
   do
   {  grDrv = DETECT;
      grMode = 0;
      initgraph(&grDrv, &grMode, grPath);
      if((grErr = graphresult()) != grOk)
      {  printf("Error %s\n", grapherrormsg(grErr));
 grPath = getBGIPath();
 if(grPath == NULL) break;
      }
   }
   while(grErr != grOk);
   if(grErr != grOk)
     abort();
}
Graphics::~Graphics()
{ }
void Graphics::Leave()
{  MessageOnExit();
   closegraph();
}
void Graphics::MessageOnExit()
{  settextjustify(BOTTOM_TEXT, LEFT_TEXT);
   outtextxy(0, getmaxy(), "Pres Any Key to EXIT Graph Mode");
   getch();
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
145
char* Graphics::getBGIPath()
{  static char Path[67];
   printf("Enter BGI path or \'.\'for end :");
   scanf("%s", Path);
   if(Path[0] == '.')
     return NULL;
   return Path;
}
//**********************************************************
class Line
{  int X1, Y1, X2, Y2;
   int Status;
   public:
     Line();
     Line(const Line&);
     Line(int, int);
     Line(int, int, int, int);
     int StartX() const;
     int EndX() const;
     int StartY() const;
     int EndY() const;
     virtual void MoveRel(int, int);
     virtual void Show();
     virtual void Hide();
     virtual int isVisible();
     virtual void StartPointRel(int, int);
     virtual void EndPointRel(int, int);
   protected:
     virtual void Draw();
     virtual void Clear();
};
Etibar Seyidzad
146
Line::Line()
{  X1 = Y1 = Y2 = 0;
   X2 = 1;
   Status = 0;
}
Line::Line(const Line& L)
{  X1 = L.X1;
   Y1 = L.Y1;
   X2 = L.X2;
   Y2 = L.Y2;
   Status = L.Status;
}
Line::Line(int x, int y)
{  X1 = Y1 = 0;
   X2 = x, Y2 = y;
   Status = 0;
}
Line::Line(int a, int b, int c, int d)
{  X1 = a;
   Y1 = b;
   X2 = c;
   Y2 = d;
   Status = 0;
}
int Line::StartX() const
{  return X1;  }
int Line::EndX() const
{  return X2;  }
int Line::StartY() const
{  return Y1;  }
int Line::EndY() const
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
147
{  return Y2;  }
int Line::isVisible()
{  return Status;  }
void Line::Show()
{  Status = 1;
   Draw();
}
void Line::Hide()
{  Status = 0;
   Clear();
}
void Line::MoveRel(int Dx, int Dy)
{  StartPointRel(Dx, Dy);
   EndPointRel(Dx, Dy);
}
void Line::StartPointRel(int dx, int dy)
{  int S = isVisible();
   if(S) Hide();
   X1 += dx;
   Y1 += dy;
   if(S) Show();
}
void Line::EndPointRel(int dx, int dy)
{  int S = isVisible();
   if(S) Hide();
   X2 += dx;
   Y2 += dy;
   if(S) Show();
}
void Line::Draw()
{  int C = getcolor();
   setcolor(RED);
Etibar Seyidzad
148
   line(X1, Y1, X2, Y2);
   setcolor(C);
}
void Line::Clear()
{  int C = getcolor();
   setcolor(getbkcolor());
   line(X1, Y1, X2, Y2);
   setcolor(C);
}
void DemoStartPoint(Line& L)
{  int i;
   for(i = 0; i < 23; i++)
   {  L.StartPointRel(10, 0);
      delay(100);
   }
}
class LineGroup : public Line
{  Line& L1;
   Line& L2;
   public:
     LineGroup(const LineGroup&);
     LineGroup(Line& a, Line& b);
     void MoveRel(int, int);
     void Show();
     void Hide();
     int isVisible();
     virtual void StartPointRel(int, int);
     virtual void EndPointRel(int, int);
   private:
     int StartX() const;
     int EndX() const;
     int StartY() const;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
149
     int EndY() const;
};
LineGroup::LineGroup(const LineGroup& LG)
 : L1(LG.L1),
   L2(LG.L2)
{ }
LineGroup::LineGroup(Line& a, Line& b)
 : L1(a),
   L2(b)
{ }
void LineGroup::MoveRel(int dx, int dy)
{  L1.MoveRel(dx, dy);
   L2.MoveRel(dx, dy);
}
void LineGroup::Show()
{  L1.Show();
   L2.Show();
}
void LineGroup::Hide()
{  L1.Hide();
   L2.Hide();
}
int LineGroup::isVisible()
{  return L1.isVisible();  }
void LineGroup::StartPointRel(int dx, int dy)
{  L1.StartPointRel(dx, dy);
   L2.StartPointRel(dx, dy);
}
void LineGroup::EndPointRel(int dx, int dy)
{  L1.EndPointRel(dx, dy);
   L2.EndPointRel(dx, dy);
Etibar Seyidzad
150
}
//****************************************************
void LineDemo()
{  cleardevice();
   Line A(300, 300);
   A.Show();
   Line B(100, 200, 300, 300);
   B.Show();
   getch();
   A.Hide();
   getch();
   A.Show();
   getch();
   DemoStartPoint(A);
   DemoStartPoint(B);
///////////// LineGroup //////////////
   LineGroup Group(A, B);
   Group.Show();
   getch();
   Group.Hide();
   getch();
   Group.Show();
   getch();
   DemoStartPoint(Group);
   getch();
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
151
main()
{  clrscr();
   Graphics graphicsMedia;
   graphicsMedia.Enter();
   LineDemo();
   graphicsMedia.Leave();
   return 0;
}
ndi d Line sinfi sas nda Box (qutu) sinfini t yin
edib eyni m qs dl  istifad  ed k. Bunun üçün LINE.CPP
proqram na qal n (bold) sitild  yaz lm  s tirl ri a dak
kimi lav  ed k:
//BOX.CPP
#include <graphics.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <dos.h>
class Graphics
{  public:
     Graphics();
     virtual ~Graphics();
     virtual void Enter();
     virtual void Leave();
   protected:
     virtual char* getBGIPath();
     virtual void MessageOnExit();
Etibar Seyidzad
152
};
Graphics::Graphics()
{ }
void Graphics::Enter()
{  int grDrv;
   int grMode;
   char* grPath = "";
   int grErr = grOk;
   do
   {  grDrv = DETECT;
      grMode = 0;
      initgraph(&grDrv, &grMode, grPath);
      if((grErr = graphresult()) != grOk)
      {  printf("Error %s\n", grapherrormsg(grErr));
 grPath = getBGIPath();
 if(grPath == NULL) break;
      }
   }
   while(grErr != grOk);
   if(grErr != grOk)
     abort();
}
Graphics::~Graphics()
{ }
void Graphics::Leave()
{  MessageOnExit();
   closegraph();
}
void Graphics::MessageOnExit()
{  settextjustify(BOTTOM_TEXT, LEFT_TEXT);
   outtextxy(0, getmaxy(), "Pres Any Key to EXIT Graph Mode");
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
153
   getch();
}
char* Graphics::getBGIPath()
{  static char Path[67];
   printf("Enter BGI path or \'.\'for end :");
   scanf("%s", Path);
   if(Path[0] == '.')
     return NULL;
   return Path;
}
class Line
{  int X1, Y1, X2, Y2;
   int Status;
   public:
     Line();
     Line(const Line&);
     Line(int, int);
     Line(int, int, int, int);
     int StartX() const;
     int EndX() const;
     int StartY() const;
     int EndY() const;
     virtual void MoveRel(int, int);
     virtual void Show();
     virtual void Hide();
     virtual int isVisible();
     virtual void StartPointRel(int, int);
     virtual void EndPointRel(int, int);
   protected:
     virtual void Draw();
     virtual void Clear();
};
Etibar Seyidzad
154
Line::Line()
{  X1 = Y1 = Y2 = 0;
   X2 = 1;
   Status = 0;
}
Line::Line(const Line& L)
{  X1 = L.X1;
   Y1 = L.Y1;
   X2 = L.X2;
   Y2 = L.Y2;
   Status = L.Status;
}
Line::Line(int x, int y)
{  X1 = Y1 = 0;
   X2 = x, Y2 = y;
   Status = 0;
}
Line::Line(int a, int b, int c, int d)
{  X1 = a;
   Y1 = b;
   X2 = c;
   Y2 = d;
   Status = 0;
}
int Line::StartX() const
{  return X1;  }
int Line::EndX() const
{  return X2;  }
int Line::StartY() const
{  return Y1;  }
int Line::EndY() const
{  return Y2;  }
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
155
int Line::isVisible()
{  return Status;  }
void Line::Show()
{  Status = 1;
   Draw();
}
void Line::Hide()
{  Status = 0;
   Clear();
}
void Line::MoveRel(int Dx, int Dy)
{  StartPointRel(Dx, Dy);
   EndPointRel(Dx, Dy);
}
void Line::StartPointRel(int dx, int dy)
{  int S = isVisible();
   if(S) Hide();
   X1 += dx;
   Y1 += dy;
   if(S) Show();
}
void Line::EndPointRel(int dx, int dy)
{  int S = isVisible();
   if(S) Hide();
   X2 += dx;
   Y2 += dy;
   if(S) Show();
}
void Line::Draw()
{  int C = getcolor();
   setcolor(RED);
   line(X1, Y1, X2, Y2);
Etibar Seyidzad
156
   setcolor(C);
}
void Line::Clear()
{  int C = getcolor();
   setcolor(getbkcolor());
   line(X1, Y1, X2, Y2);
   setcolor(C);
}
void DemoStartPoint(Line& L)
{  int i;
   for(i = 0; i < 23; i++)
   {  L.StartPointRel(10, 0);
      delay(100);
   }
}
class LineGroup : public Line
{  Line& L1;
   Line& L2;
   public:
     LineGroup(const LineGroup&);
     LineGroup(Line& a, Line& b);
     void MoveRel(int, int);
     void Show();
     void Hide();
     int isVisible();
     virtual void StartPointRel(int, int);
     virtual void EndPointRel(int, int);
   private:
     int StartX() const;
     int EndX() const;
     int StartY() const;
     int EndY() const;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
157
};
LineGroup::LineGroup(const LineGroup& LG)
 : L1(LG.L1),
   L2(LG.L2)
{ }
LineGroup::LineGroup(Line& a, Line& b)
 : L1(a),
   L2(b)
{ }
void LineGroup::MoveRel(int dx, int dy)
{  L1.MoveRel(dx, dy);
   L2.MoveRel(dx, dy);
}
void LineGroup::Show()
{  L1.Show();
   L2.Show();
}
void LineGroup::Hide()
{  L1.Hide();
   L2.Hide();
}
int LineGroup::isVisible()
{  return L1.isVisible();  }
void LineGroup::StartPointRel(int dx, int dy)
{  L1.StartPointRel(dx, dy);
   L2.StartPointRel(dx, dy);
}
void LineGroup::EndPointRel(int dx, int dy)
{  L1.EndPointRel(dx, dy);
   L2.EndPointRel(dx, dy);
Etibar Seyidzad
158
}
//****************************************************
void LineDemo()
{  cleardevice();
   Line A(300, 300);
   A.Show();
   Line B(100, 200, 300, 300);
   B.Show();
   getch();
   A.Hide();
   getch();
   A.Show();
   getch();
   DemoStartPoint(A);
   DemoStartPoint(B);
///////////// LineGroup //////////////
   LineGroup Group(A, B);
   Group.Show();
   getch();
   Group.Hide();
   getch();
   Group.Show();
   getch();
   DemoStartPoint(Group);
   getch();
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
159
//***********************************************************
class Box : public Line
{  public:
     Box();
     Box(const Box&);
     Box(int, int);
     Box(int, int, int, int);
   protected:
     virtual void Draw();
     virtual void Clear();
};
Box::Box()
{ }
Box::Box(const Box& box) : Line(box)
{  }
Box::Box(int x, int y) : Line(x, y)
{  }
Box::Box(int a, int b, int c, int d) : Line(a, b, c, d)
{ }
void Box::Draw()
{  int C = getcolor();
   setcolor(GREEN);
   rectangle(StartX(), StartY(), EndX(), EndY());
   setcolor(C);
}
void Box::Clear()
{  int C = getcolor();
   setcolor(getbkcolor());
   rectangle(StartX(), StartY(), EndX(), EndY());
   setcolor(C);
}
Etibar Seyidzad
160
void BoxDemo()
{  cleardevice();
   Box Abox(300, 300);
   Abox.Show();
   Box Bbox(100, 200, 300, 300);
   Bbox.Show();
   getch();
   Abox.Hide();
   getch();
   Abox.Show();
   getch();
   DemoStartPoint(Abox);
   DemoStartPoint(Bbox);
///////////// BoxGroup //////////////
   LineGroup Group(Abox, Bbox);
   Group.Show();
   getch();
   Group.Hide();
   getch();
   Group.Show();
   getch();
   DemoStartPoint(Group);
   getch();
}
main()
{  clrscr();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
161
   Graphics graphicsMedia;
   graphicsMedia.Enter();
   LineDemo();
BoxDemo();
   graphicsMedia.Leave();
   return 0;
}
5.7 C++ Metod Ça  Sistemi
ndi d  x yali funksiyalar n i  prinsipini rh
ed k. Bunun üçün C-d n bildiyimiz kimi bir funksiya
yaz ld  zaman, yadda da komplyator t find n
mü yy n edilib ça lark n onun mövqeyin  avtomatik
keçid ba  verir. Lakin x yali funksiyalar üçün bu
mümkün deyildir.
Eyri misal nda oldu u kimi t yin olunmu  baza
sinfinin göst ricil rin Xett m nims dildiyi zaman
ça lan Uzunluq funksiyas  x ttin uzunlu unu
hesablayark n, Cevre_Qovsu m nims dilib uzunlu u
soru uldu u zaman, bu d  d  çevr  qövsü üçün
hesablamalar  apararaq geri gönd rir. Bu cür sinifl raras
müqayis ni aparmaq üçün sinifl rin h r biri üçün x yali
funksiya c dv ll ri (virtual function table) yarad r.
Etibar Seyidzad
162
class Eyri
{  protected:
      int _X, _Y;
   public:
      Eyri();
      Eyri(const Eyri&);
      Eyri(int, int);
   vitual char* Adlar() const = 0;
   int Yer_X() const;
   int Yer_Y() const;
   virtual void Yer_X(int);
   virtual void Yer_Y(int);
   virtual int Uzunluq() const = 0;
};
yinin  uy un olaraq a dak  c dv l haz rlan r.
No Ad Ünvan
1 Adlar NULL
2 Yer_X Eyri::Yer_X
3 Yer_Y Eyri::Yer_Y
4 Uzunluq NULL
dv ld ki NULL qiym tl ri qaydal  funksiyalar
göst rir.
Xett sinfi t yin edil rk n ox ar bir c dv l onun üçün
 haz rlan r. Xett sinfi Eyri sinfind n tör ndiyi üçün bu
dv vv lc Eyri sinfinin qiym tl ri köçürülür. Sonra
is Xett sinfi üçün yaz lan x yali funksiyalar bu
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
163
dv ld n tap laraq ünvan qiym tl ri d yi dirilir.
Tör n sinif üçün d  yeni t yin edil n x yali funksiyalar
varsa, bunlar da c dv lin sonuna s tir lav  edil k
daxil edilir.
No Ad Ünvan
1 Ad Xett::Ad
2 Yer_X Eyri::Yer_X
3 Yer_Y Eyri::Yer_Y
4 Uzunluq Xett::Uzunluq
Buna ox ar liyyatlar tör n bütün sinifl r üçün
yerin  yetirilir. Bu sinifl rd n birinin obyekti yarad ld
zaman bu sinifl r virtual funksiyaya malik olduqlar
üçün hans  c dv lin istifad  edil yi d  daxil olmaqla
eyni zamanda c dv l göst ricisini d  saxlay rlar.
n, Xett v Cevre_Qovsu obyektl rini yaradaq:
Xett D;
Cevre_Qovsu C;
D [VTP Xett][_X][_Y][Son_X][Son_Y]
C [VTP Cevre_Qovsu][_X][_Y][_Radius][_BaslangicBucagi][
_SonBucagi]
VTP  VirtualTablePointer
Göründüyü kimi h r bir t yin  x yali funksiyan n
dv l göst ricisi (VTP) daxildir. Bu m lumat h r bir
obyektin aid oldu u sinfin funksiya c dv lini göst rir.
Etibar Seyidzad
164
yali funksiyalar ça lark n da el  bu c dv ld n
faydalanaraq ça rma liyyatlar  yerin  yetirilir.
n, D obyekti üçün Uzunluq funksiyas
ça ld  zaman, D-nin VTP qiym ti il Xett sinfinin
dv lin  v  bu c dv lin 4-cü s tri vasit sil  d
Xett::Uzunluq funksiyas na müraci t edil kdir. Bu cür
birba a olmayan müraci tl r C proqramlar na nisb n
sür tin a  dü sin  s b olur.
5.8 Mövcud Olandan Tör n Sinifl r
lum oldu u kimi obyektyönlü
proqramla rmada tör dilmi  sinfin yaln z bir baza
sinfin  malik olma m cburiyy ti yoxdur. Bir sinif bir neç
sinifd n tör  bil r. Bu halda tör n sinif tör ndiyi
sinfin bütün üzvl rin  müraci t edib onlar  istifad  ed
bil r. Bu hal bütün sinifl rin xüsusiyy tl rinin t k bir
sinifd  c ml nm sini t min etdiyi üçün daha güclü
sinifl rin yaranmas na s b olur. Bu cür t yinl r çox
bazal q adland r.
C++-da bu cür t yinl rd  baza sinifl rinin virtual,
olub olmamas ndan as  olmayaraq eyni metodlardan
(eyni ad v  parametr siyah na malik olan
funksiyalardan) ibar t olmas  zaman  tör n sinif
daxilind  bu metodlar n yenid n t yin edilm sin  ehtiyac
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
165
vard r. Bu t yin il  baza sinifl rind n biri v  ya ham
ça la bil yi kimi, metod yenid n d  yaz la bil r.
Çox bazal q xüsusiyy tinin üstünlükl rind n biri
 tör n sinfin obyektinin baza sinifl rind n h r hans
birinin göst ricisin  m nims dil  bilm sidir. Bu halda
tör n sinfin obyekti m nims dildiyi sinif kimi
davranaraq özün  aid qabiliyy tl rini nümayi  etdirir.
//MULTINT2.CPP
#include <conio.h>
#include <stdio.h>
class A
{  public:
     A()
     { }
     void A_Xususi()
     {  printf("Bu A sinfinin A_Xususiyyetidir.\n");  }
     void Yaz()
     {  printf("Bu A sinfinin Yazilmasidir.\n");  }
     virtual void Goster()
     {  printf("Bu A sinfinin Gosterilmesidir.\n");  }
};
class B
{  public:
     B()
     { }
     void B_Xususi()
     {  printf("Bu B sinfinin B_Xususiyyetidir.\n");  }
Etibar Seyidzad
166
     virtual void Yaz()
     {  printf("Bu B sinfinin Yazilmasidir.\n");  }
     virtual void Goster()
     {  printf("Bu B sinfinin Gosterilmesidir.\n");  }
};
class C : public A, public B
{   public:
      C()
      { }
     void C_Xususi()
     {  printf("Bu C sinfinin C_Xususiyyetidir.\n");  }
     void Yaz()
     {  printf("Bu C sinfinin Yazilmasidir.\n");  }
     void Goster()
     {  printf("Bu C sinfinin Gosterilmesidir.\n");  }
};
main()
{  clrscr();
   C obyekt;
   obyekt.A_Xususi();
   obyekt.B_Xususi();
   obyekt.C_Xususi();
   obyekt.Yaz();
   obyekt.Goster();
   printf("\n");
   A *APtr;
   APtr = &obyekt;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
OBYEKT TÖR TM K
167
   APtr->A_Xususi();
   APtr->Yaz();
   APtr->Goster();
   printf("\n");
   B *BPtr;
   BPtr = &obyekt;
   BPtr->B_Xususi();
   BPtr->Yaz();
   BPtr->Goster();
   return 0;
}
Proqram ç
Bu A sinfinin A_Xususiyyetidir.
Bu B sinfinin B_Xususiyyetidir.
Bu C sinfinin C_Xususiyyetidir.
Bu C sinfinin Yazilmasidir.
Bu C sinfinin Gosterilmesidir.
Bu A sinfinin A_Xususiyyetidir.
Bu A sinfinin Yazilmasidir.
Bu C sinfinin Gosterilmesidir.
Bu B sinfinin B_Xususiyyetidir.
Bu C sinfinin Yazilmasidir.
Bu C sinfinin Gosterilmesidir.
Etibar Seyidzad
168
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
ABLONLAR HAZIRLAMAQ
169
VI F L
ABLONLAR HAZIRLAMAQ
6.1 ablonlar
Bir proqram kodunun müxt lif hallar üçün t krar
yaz lmas  yerin  q lib kimi haz rlan b istifad  edilm sin
ablonlama (template) ad  verilir. M n, float tipli
elementl rd n ibar t massiv il double tipli v  h tta int,
char v  ya long tipli elementl rd n ibar t massivl rin
kiçikd n böyüy  s ralanmas  alqoritmas  aras nda heç bir
rq yoxdur. Bu halda h r bir tip üçün ayr  bir s ralama
funksiyas n yaz lmas  art q bir i dir. Yaln z bir proqram
kodu il  proqram yazmaq h m proqramç n yükünü
azald r, h m d  g kd  edil k d yi iklikl rd  eyni
qs d üçün bir çox proqram kodunun d yi dirilm si
cburiyy tini aradan qald r.
Bu bax mdan C dilind  bu cür kodla rmalar
makrolar n köm yi il  apar r v  bu hal ümumi (generic)
yinl r adland r. Bir misala baxaq:
//GENSORT.C
Etibar Seyidzad
170
#define IMP_SORT(Tip)
void imp_sort_##Tip(Tip Mas[], unsigned int Olcu)
{
   int Nezaret = 1;
   int i;
   Tip c;
   while (Nezaret)
   {
      Nezaret = 0;
      for( i = 1; i < Olcu; i++ )
 if(Mas[i-1]>Mas[i])
 {  c = Mas[i-1];
    Mas[i-1] = Mas[i];
    Mas[i] = c;
    Nezaret = 1;
 }
   }
}
IMP_SORT(float);
IMP_SORT(double);
IMP_SORT(int);
IMP_SORT(long);
#define SORT(Tip, Mas, Olcu) imp_sort_##Tip(Mas, Olcu)
#include <conio.h>
#include <stdio.h>
double D[5] = {3.4, 7, -2.5, 4.1, 0.5};
long L[5] = {6, 2, 90, 34, 45};
int i;
main()
{  clrscr();
   SORT(double, D, 5);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
ABLONLAR HAZIRLAMAQ
171
   SORT(long, L, 5);
   printf("\nlong\t\tdouble\n");
   for(i = 0; i < 5; i++)
      printf("%ld\t\t%lf\n", L[i], D[i]);
   return 0;
}
Misalda IMP_SORT makrosu il  s ralama
funksiyalar n ümumi bir ablonu ç xard lm , t yin
olunma s trinin alt nda is  yeni bir makrodan istifad
ed k mövcud tipl r üçün s ralama funksiyalar ld
edilmi dir. Bu funksiyalar n ça lmas  üçün d SORT
adl  dig r bir makro yaz lm r.
Ümumil dirilmi  bu makro t yinl rinin m nfi
tl ri is  a dak lard r:
ralanacaq bir massivin elementl rinin tipi
parametr siyah na birba a yaz lmal r. ks
halda s hv ba  verir;
r massivin elementl rinin tipi
yi diril ks , bu massivi s ralamaq üçün
istifad  edil n SORT funksiyalar  da
yi dirilm lidir;
ralanacaq h r massivin elementl ri IMP_SORT
il  uy un tipd  t yin edilm lidir. M n, char
tipli bir massiv s ralanmadan vv l bütün
Etibar Seyidzad
172
funksilar n xaricind  (qlobal olaraq)
IMP_SORT(char); s tri yaz lmal r.
6.2 ablon Funksiyalar
ndi d C++-da ablon xüsusiyy  malik eyni
proqram  yazaq.
//TMPSORT.CPP
template <class Tip>
void SORT(Tip Mas[], unsigned int Olcu)
{
   int Nezaret = 1;
   int i;
   Tip c;
   while(Nezaret)
   {
     Nezaret = 0;
     for( i = 1; i < Olcu; i++ )
if(Mas[i-1]>Mas[i])
{
   c = Mas[i-1];
   Mas[i-1] = Mas[i];
   Mas[i] = c;
   Nezaret = 1;
}
   }
}
#include <conio.h>
#include <stdio.h>
main()
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
ABLONLAR HAZIRLAMAQ
173
{
   clrscr();
   double D[5] = {3.4, 7, -2.5, 4.1, 0.5};
   long L[5] = {6, 2, 90, 34, 45};
   SORT(D, 5u);
   SORT(L, 5u);
   int i;
   printf("\nlong\t\tdouble\n");
   for(i = 0; i < 5; i++)
      printf("%ld\t\t%lf\n", L[i], D[i]);
   return 0;
}
Proqram ç
long double
2 -2.500000
6 0.500000
34 3.400000
45 4.100000
90 7.000000
Bununla mövcud olan bütün tipl r üçün SORT
funksiyas  t yin edilir.
Burada SORT funksiyas n ça lmas na n r
yetirs niz, s ralanacaq massivin elementl rinin tipl rin
aid heç bir m lumat görm ksiniz. Çünki art q
komplyator SORT funksiyas n ça lmas  zaman
birinci parametrin tipini istifad  ed k hans  funksiyan
ça raca na özü q rar verir.
Etibar Seyidzad
174
template ifad si C++ n acar sözüdür. template il
yin edil n funksiyalarda vv lc n proqram kodunun
yi sin  s b olan tipl r t yin edil k onlara
simvolik bir ad verilir. Bu t yin template açar sözü il
rab r a dak  simvolik adlar lav  edil k ba lan r.
template<class simvolik_ad1 [, class simvolik_ad2 ...]>
Bu t yind n sonra funksiya, simvolik adlardan da
istifad  edil k C++ qaydalar na gör  yaz r.
template il ld  edil n funksiyalarla istifad çinin
özünün t yin etdiyi obyektl rin istifad  edilm si d
mümkündür.
//TMPMAX.CPP
#include <conio.h>
#include <iostream.h>
template <class T>
T Max(T a, T b)
{  return a > b ? a: b; }
class A
{  int N, M;
   public:
     A()
     {  N = 0; M = 1; }
     A(int a, int b)
     {  N = a; M = b; }
     A(const A& K)
     {  N = K.N; M = K.M; }
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
ABLONLAR HAZIRLAMAQ
175
   friend int operator>(const A& a, const A& b)
   {  return a.N % a.M > b.N % b.M; }
   friend ostream& operator<<(ostream& Stream, const A& a)
   {  Stream<<a.N % a.M;
      Stream<<"("<<a.N<<" mod "<<a.M<<")";
      return Stream;
   }
};
main()
{  clrscr();
   A Bir(34, 9);
   A Iki(456, 13);
   cout<<"Bir = "<<Bir<<endl;
   cout<<"Iki = "<<Iki<<endl;
   cout<<"En boyuk qiymet ->"<<Max(Bir, Iki)<<endl;
   return 0;
}
Proqram ç
Bir = 7(34 mod 9)
Iki = 1(456 mod 13)
En boyuk qiymet ->7(34 mod 9)
Burada template il  t yin edil n funksiyan n
simvolik adla veril n obyektd n n  gözl diyin  diqq t
etm k laz md r. Max funksiyas  obyektin öz sinfind n
dig r obyekt il  müqayis  edilm sini v  “böyükdürmü?”
sual n cavabland lmas  gözl yir. Buna gör  d A
Etibar Seyidzad
176
sinifi t yin edil rk n operator > funksiyas  da t yin
edilmi dir.
6.3 ablon Obyektl r
zi obyektl r icra olundu u zaman istifad
etdikl ri d yi nl rin tipl ri müxt lif hallarda d yi
bil r. Bu obyektl r üçün d  funksiyalardak na ox ar
ablonlar haz rlay b istifad  etm k olar. Obyekt t yinl ri
iki v  daha çox hiss n (üzv v  dost funksiya
yinl rind n) t kil olundu u üçün funksiya t yinind n
nisb n f rql nir.
//TMPARRAY.CPP
#include <conio.h>
#include <iostream.h>
#include <stdlib.h>
template <class Tip>
class Array
{  Tip *Mas;
   unsigned int Olcu;
   public:
     Array(unsigned int);
     Array(const Array&);
     ~Array()
     {  if (Mas) delete Mas;  }
     Tip& operator[](unsigned int);
   virtual void PrintHeader(ostream& Stream) const
     {  Stream<<'{';  }
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
ABLONLAR HAZIRLAMAQ
177
   virtual void PrintSeperator(ostream& Stream) const
     {  Stream<<',';  }
   virtual void PrintTrailer(ostream& Stream) const
     {  Stream<<'}';  }
   virtual void Print(ostream&) const;
};
Burda sinif t yini funksiyalarda oldu u kimi
template ifad si il  ba lam r. Simvolik tip ad na
saslanaraq t yinl r edilmi dir. Buradak  istifad  qaydas
da funksiyalarda oldu u kimidir. Lakin inline il
kodla lmayan funksiyalar üçün sonradan
kodla lark n template ifad sini sinif t yinind  oldu u
kimi kodla lacaq funksiyalar n vv lin  yazmaq
laz md r. Burada diqq t edil k hal simvolik tip
adlar n eyni olmas  deyil, sinif t yinind ki kimi tip
ad n bu t yin daxilind  d  eyni ard ll qla
yaz lmas r.
TMPARRAY.CPP  davam
template <class Tip>
Array<Tip>::Array(unsigned int B)
{  Mas = new Tip[Olcu = B];
   if(!Mas) abort();
}
Etibar Seyidzad
178
Burada n ri c lb ed n, template ifad sind n
ba qa, t yin edil n üzv funksiyas n hans  obyekt  aid
oldu unu göst n görm  (scope) operatorunun
yaz lmas ndak  d yi iklikdir. Normal halda Array::
klind  olmas  laz m g n t yin Array::<Tip>:: klind
edilmi dir. Buna s b Array-in sinif t yini deyil, müxt lif
Array sinfinin ablonu olmas r. Ba qa sözl  t yin
edilm kd  olan üzv funksiya Array<Tip> kimi t yin
olunmu  bir ablonun üzvüdür.
Dig r t fd n t yin edilm kd  olan
layih ndiricinin ad n sad Array oldu una diqq t
edin.
TMPARRAY.CPP  davam
template <class Tip>
Array<Tip>::Array(const Array<int> &A)
{  Mas = new Tip[Olcu = A.Olcu];
   if(!Mas) abort();
   int i;
   for(i = 0; i < Olcu; i++)
      Mas[i] = A.Mas[i];
}
yin edilm kd  olan üzv funksiyan n parametrl ri
köçürm  layih ndiricisind  oldu u kimi ablondan
ld  edil k bir obyekti göst ks , bu Array kimi
deyil, Array<Tip> klind  yaz lmal r. Bu, ablondan
ld  edil k sinfin üzv v  ya dost funksiyas n daxilin
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
ABLONLAR HAZIRLAMAQ
179
eyni sinifd n bir obyektin parametr kimi girm si
dem kdir.
TMPARRAY.CPP  davam
template <class Tip>
Tip& Array<Tip>::operator[](unsigned int I)
{  static Tip Komekci;
   if(I < Olcu) return Mas[I];
   return Komekci;
}
template <class Tip>
void Array<Tip>::Print(ostream& Stream) const
{  PrintHeader(Stream);
   int i;
   for(i = 0; i < Olcu - 1; i++)
   {  Stream<<Mas[i];
      PrintSeperator(Stream);
   }
   Stream<<Mas[Olcu - 1];
   PrintTrailer(Stream);
}
ablon t yin edildikd n sonra onun vasit sil
obyektl r t yin edil rk n art q simvolik tip adlar n
zin  h qiqi adlar t yin etm  il  b rab r yaz lmal r.
n, double v unsigned long int elementli
massivl r üçün
Array<double> MassivD;
Etibar Seyidzad
180
Array<unsigned long int> MassivULI;
klind  olmal r.
TMPARRAY.CPP  davam
main()
{  clrscr();
   Array<int>I(5);
   I[0] = 1; I[1] = 3; I[2] = 5; I[3] = 7; I[4] = 9;
   cout<<endl;
   I.Print(cout);
   cout<<endl;
   return 0;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
181
VII F L
AXINLAR
7.1 Ax n N dir?
Ax n (Stream) – m lumatlar n ard l formada
ax  t min ed n, m lumatlar  istifad  etm zd n vv l
 sonra onlar n saxlanmas  ard l formada
nizamlayan mexanizmdir (sinif v  ya obyekt). Ax nlar
giri  v  ya ç  m qs dil  istifad  edilir. Ax nlar n sas
miyy ti ist r standart tipd  olsun, ist rs  d
proqramç  t find n t yin edilmi  olsun, h r tipd  olan
yi nin (obyektin) ax na yaz b oxuna bilm sidir. C-
 yaz lan proqramlarda oldu u kimi yazma v  oxuma
liyyatlar nda format s trin  ehtiyac yoxdur.
7.2 Standart Ax nlar
C++-da t yin olunmu  standart ax nlar
dak lard r:
Ax n Simvolik fayl DOS fayl stifad  m qs di
cin stdin con standart giri
cout stdout con standart ç
Etibar Seyidzad
182
Ax n Simvolik fayl DOS fayl stifad  m qs di
cerr stderr con hv m saj
clog con çap
r hans  bir ax ndan veril nl ri oxumaq üçün >>
(sa a sürü dürm ), ax na veril nl ri yazmaq üçün <<
(sola sürü dürm ) operatorundan istifad  edilir.
ndi buca n qiym tini d  il  daxil ed n v
radyan il  ekrana ç xaran bir C v C++ proqram  yazaraq
bunlar  müqayis  ed k.
//BUCAQ.C
#include <stdio.h>
#include <math.h>
#include <conio.h>
double d, r;
main()
{  clrscr();
   printf("Bucaq (derece) : ");
   scanf("%lg", &d);
   r = d / 180.0 * M_PI;
   printf("\n%lg%c = %lg rad\n",
             d, 248, r);
  return 0;
}
//BUCAQ.CPP
#include <iostream.h>
#include <math.h>
#include <conio.h>
double d, r;
main()
{  clrscr();
   cout <<"Bucaq (derece) : ";
   cin >>d;
   r = d / 180.0 * M_PI;
   cout <<d<<(char)248<<" = "
<<r<<" rad"<<endl;
  return 0;
}
Bu iki proqram n müqayis sind n göründüyü kimi
printf(“mesaj”); ifad si cout<<”mesaj”; ifad sin  çevrilmi ,
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
183
cout printf il  eyni funksiyan  yerin  yetirmi dir.
printf("%d, %lf\n", 5, 1.4); kimi bir ifad  d
cout<<5<<”,”<<1.4<<”\n”; klin  çevril k format
yinedicil ri göst rilm mi dir. Bel likl , format
yinedicisinin ist diyi tip il  uy un g n qiym tin
tipl rinin uy unsuzlu undan meydana g  bil k
hvl r aradan qald lm r. Bununla b rab r növb ti
paraqraflarda gör yimiz kimi formatl  ç  üçün C-nin
imkanlar ndan da istifad  oluna bil r.
Giri  (oxuma) mrl rind  is scanf(“%lg”, &d); kimi
bir ifad nin yerin cin>>d; ifad si yaz laraq format
ifad si v & ünvan operatorundan istifad  edilm mi dir.
Ax nlar n istifad  edilm si zaman  ax na iki v  daha
art q arqumentin daxil edilm si, ya da oxunmas  laz m
rs , arqumentl r aras nda uy un istiqam tl ndirm
ar ri qoyaraq liyyatlar  yerin  yetirm k
mümkündür.
int X, Y;
double Z;
unsigned int U;
cin >>X>>Z>>U>>Y;
cout <<X<<’*’<<Y;
cout <<’=’<<(X*Y)<<’\n’;
 ya
cin >>X;
cin >> Z;
Etibar Seyidzad
184
cin >> U;
cin >> Y;
cout <<X<<’*’<<Y<<’=’<<(X*Y)<<’\n’;
eyni liyyatlar  yerin  yetir n iki proqram hiss sidir.
<< v >> operatorlar  ax nlarla istifad  ed rk n
ard ll qlar na diqq t etm k laz md r. Bel  ki,
cout <<X = Y<<’\n’;
ifad sind liyyatlar n prioritet s ras  n  al narsa,
(cout <<X) = (Y<<’\n’);
klind  icra olunur. Bu da complyasiya s hvi verir.
Çünki (cout<<X) liyyat  n tic sind X-in qiym ti
ekrana ç xar laraq cout qiym ti al r. kinci halda ifad
cout = (Y<<’\n’); hal  al r. Bu ifad nin sa  t fi d
hesabland qdan sonra ( r, t bii ki, hesablana bil rs )
cout-a bir qiym t m nims dilm  c hd edilir. Bu cür
nims tm  operatoru t yin olunmad  üçün s hv ba
verir. Bel  hallarda ifad  möt riz rin köm yi il  aç k
kild  yaz lmal r.
cout <<(X = Y)<<’\n’;
Yen  d  sa a v  ya sola sürü dürm
liyyatlar n ax nlarla birlikd  istifad  edilm si
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
185
hvl  yol aça bil yi üçün möt riz rd n istifad
etm k m qs uy undur.
int X = 3;
cout <<X<<1<<’\n’;
cout <<(X<<1)<<’\n’;
Proqram n tic sinin ekran görünü ü
31
6
olacaqd r. lk s tir 3 il 1-in ard l yaz lmas , ikinci
tir is 3-ün bir bit sola sürü dürülm si v  n tic nin
ekrana ç xar lmas  t min edir.
7.3 Ax nlara Nizamlanm  M lumat
Yaz lmas
7.3.1 Geni lik N zar ti
Ekrana ç xar lacaq m lumat n ax n üz rind
mü yy n sayda simvol uzunlu unu doldurmas  t b
olunarsa, bu ax n üçün width() üzv funksiyas ndan
istifad  edilir. M n, ekrana ç xar lacaq ist nil n bir
din 12 simvol uzunlu unda olmas  üçün
Etibar Seyidzad
186
cout.width(12);
cout<<56;
ifad sind n istifad  edilir. width ifad si sad  özünd n
sonrak  m lumat sah sinin yaz lmas na t sir edir. Daha
sonrak  m lumatlar n ekrana ç xar lmas nda m nas
olmaz. r laz m g rs , dig r m lumatlar  da ekrana
xarmazdan vv l eyni ifad n istifad  edilm lidir.
Lakin m lumat veril n geni liy  s xmazsa, bu
geni lik n  al nm r v  ehtiyac oldu u q r sah
istifad  edil k ekrana ç xar r.
vv lc n verilmi  geni lik qiym tini
mü yy nl dirm k üçün parametrsiz width() funksiyas
istifad  edil k bundan sorak  yazma (ekrana ç xarma)
liyyat nda m lumat üçün ayr lacaq  sah nin
geni liyini t yin etm k olar.
int Genislik = cout.width();
width() funksiyalar n hans n istifad
edilm sind n as  olmayaraq n tic  ax n üçün daha
vv lki add mlarda t yin olunan yazma geni liyinin
qiym ti geri gönd ril kdir. H r yazma liyyat ndan
sonra yazma geni liyi s r olacaqd r. Yazma geni liyinin
r olmas  ax na ehtiyac oldu u q r yazma sah sini
istifad  etm  imkan  verir.
int width();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
187
int width(int);
7.3.2 Yerl  N zar ti
lumat yaz lark n, onun geni liyi veril n
geni likd n az olarsa, m lumatlar sa a s laraq
yaz r. Sol t fl ri is  bo  burax r.
r m lumatlar  yaln z sa a s lm  deyil,
ist  uy un olaraq sa a v  ya sola s laraq yazmaq
b olunarsa, ax nlar n m nsub olduqlar ios::adjustfield
parametri ios::left v  ya ios::right kimi göst rilm lidir. Bu
bax mdan ios::adjustfield parametrin  m nims tm k
üçün setf() funksiyas ndan istifad  etm k olar. M n,
cout.setf(ios::left, ios::adjustfield);
cout.widht(14);
cout<<56;
cout.setf(ios::right, ios::adjustfield);
cout.width(14);
cout<<56;
Burada ios::right m lumat n veril n geni lik
daxilind  sa a, ios::left is  sola s lmas  t min
edir.
Etibar Seyidzad
188
7.3.3 Bo luq N zar ti
lumatlar n mü yy n bir geni likd ki sah  sa a
 ya sola s laraq yaz lmas  n tic sind  sol v  ya
sa  t fd  istifad  olunmam  sah r qal r. Bu sah r
çox zaman bo  saxlansa da, b n doldurula da bil r.
Bunun üçün fill() üzv funksiyas ndan istifad  edilir.
n, yaz lacaq qiym tl rin sa a s lm  olmas
 solda qalan bo  sah rin d  s rla doldurulmas  t b
olunarsa,
cout.setf(ios::right, ios::adjustfield);
cout.fill(‘0’);
cout.width(14);
cout<<78<<”\n”;
kimi bir proqram hiss si yaz la bil r.
fill() funksiyas n t siri yeni bir fill() funksiyas n
istifad  edilm sin  kimidir. Buna gör  d  doldurulma
cburiyy tinin aradan qald lmas  üçün fill(32); v  ya
fill(‘ ‘); s tirl ri yaz lmal r.
fill() funksiyas  h r zaman vv lki hal nda istifad
edilm n sah  doldurulacaq simvolu qaytarir. r
doldurma simvolu d yi dirilm zs  v  sad  hans
simvolun oldu unu mü yy nl dirm k laz m g rs ,
parametrsiz fill() funksiyas ndan istifad  etm k olar.
char EvvelkiSimvol = cout.fill();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
189
cout.fill(‘!’);
...
cout.fill(EvvelkiSimvol);
r iki fill() funksiyas n prototipi a dak  kimidir:
char fill();
char fill(char);
7.3.4 Tam dl rin saslar na N zar t
Tam dl r 3 formada: onluq (decimal), kkizlik
(octal) v onalt q (hexadecimal) say sisteml rind
yaz la bil rl r. Tam dl r ax nlara bu say
sisteml rind n birind  yaz la bil r. sas n onluq say
sistemind , laz m g ldiyi zaman da dig r say
sisteml rind  yaz la bil r. Bunun üçün setf() üzv
funksiyas ndan istifad  edilir. setf() funksiyas  il  ax nlar
üçün t yin olunmu ios::basefield parametrin ios::dec,
ios::oct v  ya ios::hex qiym tl rind n biri 
edilm lidir.
int x = 36;
cout.setf(ios::dec, ios::basefield);
cout<<x<<”\n”;
cout.setf(ios::oct, ios::basefield);
cout<<x<<”\n”;
cout.setf(ios::hex, ios::basefield);
cout<<x<<”\n”;
Etibar Seyidzad
190
tic
36
44
24
qiym tl ri ax nda (cout oldu u üçün ekranda)
görün kdir.
7.3.5 H qiqi  N zar t
qiqi dl r yaz lark n onluq nöqt n sonra
neç  r min yaz laca n t yin olunmas , laz ms z
rin qar ql q v  nizams z bir görünü
yaratmas n qar  al r. Bu precision() üzv funksiyas
il  t yin edilir. Bu funksiya il  nöqt n sonra görün k
ml rin say  t yin edilir. Geri qaytarma qiym ti kimi
is vv lki sas qiym t qaytar r.
double X = 7.7881881;
cout.precision(3);
cout<<X<<”\n”
tic
7.788
 ya
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
191
double X = 7.7881881;
cout.precision(2);
cout<<X<<”\n”
tic
7.79
kimi görün kdir.
Buradan göründüyü kimi at lan r ml r
yuvarlaqla r.
qiqi dl rin yaz lmas nda, sas qiym t
xaricind miyy tli olan qiym tin nizamlanm
olmas r. H qiqi dl r iki müxt lif formada göst ril
bil r: ±x.xxxxE±xxxx klind  müh ndislik görünü ü
(scientific) v ±xxxx.xxxx klind ki normal görünü
(fixed).
Ax nlar üçün nizamlama liyyatlar n yerin
yetirilm si ancaq onlar üçün t yin edilmi ios::floatfield
parametrin ios::fixed v  ya ios::scientific qiym tl rind n
birinin yaz lmas  il  mümkündür. ios::fixed normal
görünü , ios::scientific is  müh ndislik görünü ü
üçündür.
double X = 567.8990;
cout.setf(ios::fixed, ios::floatfield);
cout<<X<<”\n”;
cout.setf(ios::scientific, ios::floatfield);
Etibar Seyidzad
192
cout<<X<<”\n”
tic  ax ndak  görünü
567.899
5.67899e+2
kilnd  olur.
7.4 Ax nlardan Nizamlanm
lumat Oxunmas
Ax nlardan m lumatlar n oxunmas  üçün yen  d
vv lki paraqrafda rh edil n nizamlanm  m lumat
yazma funksiyalar ndan istifad  ed  bil rsiniz.
Bunlardan yaln z tam dl rin saslar n göst rilm si
miyy tlidir. Dig rl rinin heç bir t siri yoxdur.
Tam di ax ndan oxumaq üçün bu din
vv lind 0o, 0O, 0x, 0X kimi i ar r yoxdursa, daxil
edilmi dl r onluq d kimi q bul edilir. dl rin
vv lind 0o v  ya 0O yaz larsa, onlar n s kkizlik, 0x v
ya 0X yaz larsa, onlar n onalt q say sitemind  yaz ld
bul edilir. Bu halda oxunacaq h r hans  bir din sas
göst ril rs , ax nda olan d d  eyni sasda olmal r.
ks halda s hv q bul edilir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
193
Misal 1:
#include <conio.h>
#include <iostream.h>
main()
{  clrscr();
   int Integer;
   cin>>Integer;
   cout<<”\n”<<Integer<<”\n”;
  return 0;
}
Proqram giri  v  ç
45
45
Misal 2:
#include <conio.h>
#include <iostream.h>
main()
{  clrscr();
   int Integer;
   cin.setf(ios::oct, ios::basefield);
   cin>>Integer;
   cout<<”\n”<<Integer<<”\n”;
  return 0;
}
Etibar Seyidzad
194
Proqram giri  v  ç
45
37
Misal 3:
#include <conio.h>
#include <iostream.h>
main()
{  clrscr();
   int Integer;
   cin.setf(ios::hex, ios::adjustfield);
   cin>>Integer;
   cout<<”\n”<<Integer<<”\n”;
  return 0;
}
Proqram giri  v  ç  1
45
69
Proqram giri  v  ç  2
0x45
69
Proqram giri  v  ç  3
0o45 <s hfdir
0
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
195
7.5 S hvl  N zar t
r hans  bir ax n il  yerin  yetiril n liyyatlarda
hvin ba  verm si zaman  ax n özü-özlüyünd  bir i
görmür. Yaln z s hvin ba  verdiyi haqq nda m lumat
özünd  saxlay r. Daha sonra özünd n soru ulan b zi
lumatlara bu m lumata saslanaraq cavab verir.
Bu suallar a dak lard r:
Funksiya (TRUE) S rdan f rqli qaytarma qiym tinin s bi
int bad() hv ba  vermi .
int fail() liyyat s hv s bind n yar mç q qalm sa.
int good() cra olunan liyyatlardan sonra heç bir s hv
olmam sa.
int eof() Oxuma m qs dli ax ndan fayl sonu simvolu
oxunmu sa.
hvin s bi m lum olub düz ldildikd n sonra
liyyatlar n davam etdirilm si t b olunarsa,
meydana g n s hvin sonrak  m rh rd  d  s hv kimi
qiym tl ndirilm si üçün ax na aid s hv m lumat
silinm lidir. Bunun üçün void clear(); funksiyas ndan
istifad  olunur.
7.6 Fayl Üz rind ki Ax nlar
Fayllar n ax n kimi istifad  edilm si üçün b zi
funksiyalar t yin edilmi dir. Bu funksiyalar  istifad
Etibar Seyidzad
196
etm k üçün fstream.h ba q fayl  proqram koduna lav
edilm lidir.
7.6.1 Fayla Yazma
lumatlar n fayllara yaz lmas  üçün ofstream()
sinfind n istifad  edilir. Bu sinfin 4 müxt lif
layih ndiricisi vard r.
ofstream();
Bu layih ndirici yaln z yazma m qs dli ax n t yin
edir. Bu ax n hans  fayl oldu u open() üzv funksiyas
il  mü yy n edilir. open() funksiyas n strukturu
void open(char* fayl_ad , int tip);
klind dir. fayl_ad  aç lacaq fayl n liyyat sisteminin
xüsusiyy tl rin  uy un olaraq verilmi  ad r. tip is
yazma m qs dli fayllar üçün ios::out v  ya ios::app
olmal r. ios:app r fayl mövcuddursa, yeni
lumatlar n fayl n sonuna lav  edilm sini, ios::out is
lumatlar n fayl n ba lan ndan etibar n daxil
edilm sini t min edir. Bu halda fayldak  mövcud  olan
lumatlar silinir.
Ax nlar aç lma rejimind n as  olmayaraq close()
üzv funksiyas  il  ba lanmal r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
197
#include <fstream.h>
main()
{  ofstream Output;
   Output.open("misal1.dat", ios::out);
   if (Output.bad())
   {  cerr<<"Fayl acilmir.\n";
      return 1;
   }
   Output<<"Axina yazma\n";
   Output<<8<<' '<<7.78<<"\n";
   Output.close();
   return 0;
}
MISAL1.DAT fayl na yaz lan m lumatlar
Axina yazma
8 7.78
ofstream(char* fayl_ad );
Bu layih ndirici d fayl_ad  il  veril n fayl n
ax nla laq ndiril k istifad  edilm sini t min edir.
#include <fstream.h>
main()
{  ofstream Output("misal2.dat");
Etibar Seyidzad
198
   if (Output.bad())
   {  cerr<<"Fayl acilmir.\n";
      return 1;
   }
   Output<<"Axina yazma\n";
   Output<<8<<' '<<7.78<<"\n";
   Output.close();
   return 0;
}
MISAL2.DAT fayl na yaz lan m lumatlar
Axina yazma
8 7.78
ofstream(int handle);
Bu layih ndirici daha vv l aç lm  bir fayl n ax n
kimi aç b istifad  edilm si üçün t yin edilmi  bir
layih ndiricidir. Bu layih ndirici il  b rab r istifad
edil n handle il  veril n fayl bu t yind n sonra sad
ax n kimi istifad  edilm lidir. ks halda fayl daxilind
hv m lumatlara rast g  bil rsiniz.
ofstream(int handle, char* buffer, int uzunluq);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
199
Bundan vv l rh edilmi  layih ndirici kimi eyni
qs dl r üçün istifad  edil n bu layih ndirici buffer
il  veril n uzunluq uzunlu undak  aral q yadda  vasit si
il  fayla yazma liyyat  yerin  yetirir. Y ni aral q
yadda  dolana q r m lumatlar  bu yadda a yaz r.
Yadda  dolduqdan sonra bu m lumatlar n ham  fayla
yaz r. Sonra aral q yadda a yeni m lumatlar vv ld n
yazma a ba lay r.
//OFSTR3.CPP
#include <io.h>
#include <fcntl.h>
#include <fstream.h>
main()
{  int OutputHandle = open("misal3.dat", O_RDWR);
   write(OutputHandle, "Kohne idareetme\n", 12);
   ofstream Output(OutputHandle);
   Output<<"Axina yazma\n";
   Output<<8<<' '<<7.78<<"\n";
   Output.close();
   return 0;
}
MISAL3.DAT fayl na yaz lan m lumatlar
Kohne idareetme
Axina yazma
8 7.78
Etibar Seyidzad
200
7.6.2 Fayldan Oxuma
Fayylar n ax n olaraq t yin edilm si üçün ifstream()
sinfind n istifad  olunur. Bu sinfin d ofstream() sinfind
oldu u kimi dörd müxt lif layih ndiricisi vard r.
ifstream();
Bu layih ndirici, yaln z oxuma m qs dli ax n
yin edir. Bu ax n hans  fayl oldu u open() üzv
funksiyas  il  t yin edilir. open() funksiyas n yaz
bundan vv lki paraqraflarda oldu u kimidir. Yaln z tip
kimi t yin olunmu  ikinci parametr oxuma m qs dli
fayllar üçün ios::in olmal r. Ax n nec  aç lmas ndan
as  olmayaraq close() üzv funksiyas  il  ba lanmal r.
//IFSTR1.CPP
#include <conio.h>
#include <fstream.h>
main()
{  clrscr();
   ifstream Input;
   int X, Y;
   double D, E;
   char *Setir;
   Input.open("input.dat", ios::in);
   if (Input.rdstate())
   {  cerr<<"Fayli acma xetasi.\n";
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
201
      return 1;
   }
   Input>>X>>D;
   Input>>Y>>E;
   Input>>Setir;
   Input.close();
   cout<<endl<<Setir<<endl;
   cout<<"Tam ededler\t"<<X<<'\t'<<Y<<endl;
   cout<<"Heqiqi ededler\t"<<D<<'\t'<<E<<endl;
   return 0;
}
INPUT.DAT fayl
3 67.8
90 12e34
Misal
Proqram ç
Misal
Tam ededler 3 90
Heqiqi ededler 67.8 1.2e+35
ifstream(char * fayl n_ad );
Bu layih ndirici fayl n_ad  il  veril n fayl  ax nla
laq ndir k istifad  edilm sini t min edir. Bu halda
fayl n_ad  adl  fayl mövcud olmal r.
ifstream(int handle);
Etibar Seyidzad
202
Bu layih ndirici vv lc n oxuma m qs di il
aç lm  fayl n ax n kimi istifad  edilm si üçün t yin
olunmu  layih ndiricidir. Bu layih ndirici il  birlikd
istifad  edil n handle il  verilmi  fayl bu t yind n sonra
yaln z ax n kimi istifad  edilm lidir. ks halda fayl
daxilind  s hv m lumatlara rast g  bil rsiniz.
ifstream(int handle, char *buffer, int uzunluq);
ifstream(int handle); layih ndiricisi il  eyni
qs dl r üçün istifad si mümkün olan bu
layih ndirici buffer il  veril n uzunluq uzunlu undak
aral q yadda  vasit sil  fayldan oxuma liyyat
yerin  yetirir. vv lc  aral q yadda  dolana q r
fayldan bu yadda a m lumat oxunur. Sonra oxuma
liyyat  bu yadda  üz rind n icra olunur.  Aral q
yadda dak  m lumatlar n ham  oxunduqdan sonra bu
yadda a fayldan yeni m lumatlar oxunaraq liyyat
davam etdirilir.
7.7 Obyektl r v  Ax nlar
Proqramç n özünün t yin ed yi obyektl ri
ax nlara << operatoru il  yaz b v >> operatoru il  oxuya
bilm si üçün bu obyektl r (sinifl r) üçün uy un
operatorlar  da t yin etm lidir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
203
Bu operator funksiyalar  ümumi kild  a dak
kimi olmal r:
ostream& operator<<
(ostream& Stream, const YeniClass& Obyekt);
istream& operator>>
(istream& Stream, const YeniClass& Obyekt);
//POINT.CPP
#include <iostream.h>
class Point
{  int _X, _Y;
   public:
     Point(int x = 0, int y = 0);
     int X() const;
     int Y() const;
     void X(int);
     void Y(int);
     void MoveRel(int, int);
     virtual void Draw() const;
};
ostream& operator<<(ostream&, const Point&);
istream& operator>>(istream&, Point&);
//********************************************
#include <graphics.h>
Etibar Seyidzad
204
Point::Point(int x, int y)
{  _X = x;
   _Y = y;
}
int Point::X() const
{  return _X;  }
int Point::Y() const
{  return _Y;  }
void Point::X(int x)
{  _X = x;  }
void Point::Y(int y)
{  _Y = y;  }
void Point::MoveRel(int dx, int dy)
{  _X += dx;
   _Y += dy;
   if(_X < 0 || _X > getmaxx())
     _X = getmaxx() / 2;
   if(_Y < 0 || _Y > getmaxy())
     _Y = getmaxy() / 2;
}
void Point::Draw() const
{  line(_X - 2, _Y - 2, _X + 2, _Y + 2);
   line(_X - 2, _Y + 2, _X + 2, _Y - 2);
}
ostream& operator<<(ostream& stream, const Point& point)
{  stream<<point.X()<<' '<<point.Y();
   return stream;
}
istream& operator<<(istream& stream, Point& point)
{  int x, y;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
205
   stream>>x>>y;
   point.X(x);
   point.Y(y);
   return stream;
}
//********************************************
class PointArray
{  Point *_Array;
   int _Size;
   public:
     PointArray(int);
     ~PointArray();
     int Size() const;
     void Read();
     void Write();
     void Load(char*);
     void Save(char*);
     void Draw() const;
     void Animate() const;
   protected:
     void Create(int);
     void Destroy();
};
//********************************************
#include <fstream.h>
#include <stdio.h>
#include <stdlib.h>
Etibar Seyidzad
206
#include <conio.h>
PointArray::PointArray(int size)
{  Create(size);  }
PointArray::~PointArray()
{  Destroy();  }
int PointArray::Size() const
{  return _Size;  }
void PointArray::Read()
{  cout<<"\nNoqtelerin X ve Y qiymetlerini\n";
   cout<<"aralarina bosluq qoyaraq daxil edin\n";
   int i;
   for(i = 0; i < _Size; i++)
   {  cout<<i+1<<">";
      cin>>_Array[i];
   }
}
void PointArray::Write()
{  cout<<"Noqtenin qiymeleri\n";
   int i;
   for(i = 0; i < _Size; i++)
      cout<<i+1<<'\t'<<_Array[i]<<endl;
}
void PointArray::Load(char* fname)
{  ifstream Input(fname);
   if(Input.rdstate())
      return;
   Destroy();
   int size;
   Input>>size;
   Create(size);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
207
   int i;
   for(i = 0; i < _Size; i++)
      Input>> _Array[i];
}
void PointArray::Save(char* fname)
{  ofstream Output(fname);
   if(Output.rdstate()) return;
   int i;
   Output<<_Size<<endl;
   for(i = 0; i < _Size; i++)
      Output<<_Array[i]<<endl;
}
void PointArray::Draw() const
{  int i;
   for(i = 0; i < _Size; i++)
      _Array[i].Draw();
}
void PointArray::Animate() const
{  randomize();
   int i = 0;
   setwritemode(XOR_PUT);
   Draw();
   outtextxy(0, getmaxy() - 12, "Dayandirmaq ucun bir duymeye
sixin");
   while(!kbhit())
   {  if(i >= _Size)
i = 0;
      _Array[i].Draw();
      _Array[i].MoveRel(random(3) - 1, random(3) - 1);
      _Array[i].Draw();
      i++;
   }
   getch();
Etibar Seyidzad
208
}
void PointArray::Create(int size)
{  _Array = new Point [_Size = size];
   if(!_Array)
     abort();
}
void PointArray::Destroy()
{  delete []_Array;  }
//********************************************
main()
{  clrscr();
   PointArray Noqteler(15);
   Noqteler.Read();
   clrscr();
   Noqteler.Write();
   cout<<"\ndavam etmek ucun bir duymeye sixin\n";
   getch();
   Noqteler.Save("Noqte.ntk");
   Noqteler.Load("Noqte.ntk");
   cout<<"Fayldan oxunan qiymetler\n";
   Noqteler.Write();
   cout<<"\ndavam etmek ucun bir duymeye sixin\n";
   getch();
   int D = DETECT, M = 0;
   initgraph(&D, &M, "c:\\borlandc\\bgi");
   if(graphresult() != grOk)
     abort();
   Noqteler.Animate();
   closegraph();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
AXINLAR
209
   cout<<"Animate funksiyasindan sonraki qiymetler\n";
   Noqteler.Write();
   cout<<"\ndavam etmek ucun bir duymeye sixin\n";
   getch();
   return 0;
}
Etibar Seyidzad
210
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
211
VIII F L
CLASS K TABXANASI
8.1 Container Class Kitabxanas
Container Class kitabxanas  proqramç lar
find n çox istifad  edil n mü yy n t yinl r,
lumatlar strukturu, alqoritml rin yaz lmas  v
kmill dirilm sind , problem üz rind  çox vaxt s rf
etm  zaman miyy tli rol oynay r. Bu t yinl r v
lumatlar strukturu C++-da vv lc n haz rlanaraq
proqramç lara t qdim edilmi dir. Borland C++ v Turbo
C++-da bu strukturlar n istifad  edilm si il laq dar
rh verm  ehtiyac vard r.
Bu strukturlar n ba q fayllar
C:\BORLANDC\CLASSLIB\INCLUDE qovlu unda
saxlan r. Ba q fayllar n proqrama daxil edilm si
üçün onlar n ad  il  birlikd  bu s tir d  (yol) yaz lmal r.
Bu s tri OPTIONS menyusundan DIRECTORIES mrini
seç k, aç lacaq dialoq p nc sind INCLUDE
parametrin  uy un g n s tr  daxil etm k laz md r.
Bundan ba qa class kitabxanalar n LINK
rh sind  ola bilm si üçün kitabxanalar n daxilind
Etibar Seyidzad
212
oldu u \BORLANDC\CLASSLIB\LIB yolu INCLUDE
yoluna ox ar t yin edilm lidir. Bu yolu OPTIONS
menyusundan DIRECTORIES mrini seç k, aç lacaq
dialoq p nc sind LIBRARIES parametrin  uy un
n s tr  yazmaq laz md r. Normal olaraq istifad
edil k kitabxanan n ad PROJECT daxilind
göst rilm li v  ya LINK m rh sind  kitabxana ad
olaraq verilm lidir. Lakin Borland C++ paketind
OPTIONS menyusundan LINKER alt menyusunu, sonra
da LIBRARIES mri, aç lacaq dialoq p nc sind
“Container Class Library” sah sind ki STATIC v  ya
DINAMIC parametrl rind n biri seçilm lidir.
8.2 T yin Olunmu  Sinifl r
yin olunmu  üç sinif vard r:
1. Veril nl ri saxlayan sinifl r:
    a) bir m lumatdan ibar t olan sinifl r;
    b) iki m lumat aras nda laq  quran sinifl r;
    c) çox m lumatdan ibar t olan sinifl r.
2. Sürücül rl  i n sinifl r;
3. Köm kçi sinifl r.
Sinifl rin növl ri a dak lard r:
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
213
Object
AssociationSortable
Container
Error
StringtBaseTime BaseDate
Stack
Collection
Deque
Queue
AbstractArray
Btree HasTableDoubleList List
Array SortedArray
Bag
Set
Dictionary
Time Date
Etibar Seyidzad
214
8.3 T yinl r v  Tipl r
8.3.1 Tip v  Sinif Kodlar
Kitabxanan n kodla lmas nda istifad  edil n
yinl r v  tipl r a dak lard r:
classType
typedef unsigned int classType;
Sinifl ri bir-birind n ay rmaq üçün qiym t olaraq
r sinf  uy un g n bir tam d verilmi dir.
Bunlar a dak lard r:
Sinif Ad Simvolik Sabit di Qiym ti
Array arrayClass 16
Association associationClass 15
Bag bagClass 12
Btree btreeClass 22
Collection collectionClass 10
Container containerClass 6
Date dateClass 21
Deque dequeClass 9
Dictionary dictionaryClass 14
DoubleList doubleListClass 19
DoubleListElement doubleListElementClass 5
Error errorClass 1
HashTable hashTableClass 11
List listClass 18
ListElement listElementClass 4
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
215
Sinif Ad Simvolik Sabit di Qiym ti
Object objectClass 0
PriorityQueue priorityQueueClass 23
Queue queueClass 8
Set setClass 13
Sortable sortableClass 2
SortedArray sortedArrayClass 17
Stack stackClass 7
String stringClass 3
Time timeClass 20
0 il __lastLibClass (qiym ti 255) aras ndak
qiym tl r Borland t find n istifad  edilm k üçün
rd  tutulmu dur. __firstUserClass (qiym ti 256) il
__lastClass (qiym ti 65568) aras ndak  qiym tl r is
proqramç lar n öz sinifl rini t yin ed rk n istifad  ed
bilm ri üçün n rd  tutulmu dur.
Yuxar dak  c dv ld n d  göründüyü kimi simvolik
sinif qiym tl ri sinfin ad n ilk h rfinin kiçik yaz lmas
 sonuna Class sözünün lav  edilm si il
göst rilmi dir.
hashValueType
typedef unsigned int hashValueType;
Yadda dak  obyektl  müraci t etm k m qs dil
obyektl rin mü yy n bir qiym  gör  sinifl ndirilm si
 bu sinifl ndirm  gör  axtar lmas  üçün onlar n
verdiyi bir di qiym tdir.
Etibar Seyidzad
216
sizeType
typedef unsigned int sizeType;
Yadda da saxlan lan obyektl rin say  t yin etm k
üçün istifad  edilir.
iterFuncType
typedef void (*iterFuncType)(class Object&, void*);
forEach üzv funksiyas n t yinind  istifad  edilir.
condFuncType
typedef int countType;
Yadda dak  elementl ri saymaq üçün istifad
olunan bir tip t yinidir.
Burada göst ril n bütün tipl r v  sabitl r clstypes.h
ba q fayl  daxilind  t yin edilmi di.
8.3.2 S hv Kodlar n T yini
Burada rh edil n obyekt sinifl rinin t tbiqind
proqram n icras n davam etm sin ng l olan s hvl r
meydana g ldiyi zaman proqramdan exit() mri il  ç r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
217
Meydana g n s hvin s bin  gör exit()
funksiyas n (eyni zamanda proqram n) ç  kodlar  v
di qiym tl ri a da göst rilmi dir:
__EEXPAND 2
__ENOMEM 3 Yadda da kifay t q r yer olmad
zaman sah  ayr lmad  hallarda
__ENOTSTOP 4 SortedArray sinfinin s ralana bilm si
hal nda
__ENOTASSOC 5 Dictionary sinfinin h r hans  bir
obyektin  Association sinfind n olmayan
bir obyektin yerl diril msin  c hd
edilm si hal nda
Bu s hv kodlar  “clsdef.h” ba q fayl  daxilind
yin edilmi dir.
8.3.3 Ba q Fayllar  v  T yin Edilmi
Sinifl r
Sinifl rin t yin edildikl ri ba q fayllar
dak lard r:
Sinif Ad Simvolik Sabit
AbstractArray ABSTARRY.H
Array ARRAY.H
Association ASSOC.H
Bag BAG.H
BaseDate LDATE.H
BaseTime LTIME.H
Btree BTREE.H
Etibar Seyidzad
218
Sinif Ad Simvolik Sabit
BtreeIterator BTREE.H
Collection COLLECT.H
Container CONTAIN.H
ContainerIterator CONTAIN.H
Date DATE.H
Deque DEQUE.H
Dictionary DICT.H
DoubleList DBLLIST.H
DoubleListElement DLSTELEM.H
Error ERROR.H
HashTable HASHTBL.H
HashTableIterator HASHTBL.H
List LIST.H
ListElement LSTELEM.H
ListIterator LIST.H
Object OBJECT.H
PriorityQueue PRIORTYQ.H
Queue QUEUE.H
Set SET.H
Sortable SORTABLE.H
SortedArray SORTARRY.H
Stack STACK.H
String STRING.H
Time TIME.H
8.4 Sinifl r
8.4.1 Object
Object müc rr d sinif (abstract class) olmaqla
rab r dig r bütün container class kitabxanas n
obyektl rinin tör nm sind  istifad  edil n ilk baza
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
219
sinfidir. Bu sinif tör n dig r sinifl rin sad
xüsusiyy tl rini t yin edir.
Bu sinif daxilind  t yin edil n üzv funksiyalar n
prototipl ri v  v zif ri a dak lard r:
virtual classType isA() const = 0;
Bu funksiya bir sinfi t yin ed n v  sad  o sinf  aid
olan obyektl rin da ya bil yi xüsusi bir kodu qiym t
kimi geri qaytar r. Bu funksiya obyektl rin eyni sinifd n
olub olmad qlar  mü yy nl dirm k üçün istifad
edilir. Yeni tör dil n Oject bazal  h r obyekt üçün
yaz lmas  vacibdir.
virtual char* nameOf() const = 0;
Bu funksiya obyektin xüsusi ad  il  geri qay r.
Sinfin obyektl rinin ad  yoxdursa, onun ad  il  geri
qay r. Yeni tör dil n Object bazal  h r obyekt üçün
yaz lmas  vacibdir.
virtual hashValueType hashValue() const = 0;
lumatlar strukturunun bir qrup daxilind
saxlan lmas  müxt lif formalarda ola bil r. Saxlan lan
lumata müraci t müdd ti bu forman n t yin
edilm sind  çox miyy tlidir. Bunun üçün bir çox
lumatlar strukturu v  müraci t mexanizml ri t yin
Etibar Seyidzad
220
edilmi dir. Bu mexanizml rd n biri d hashing
adland lan qrupla rma üsuludur. Bu üsulda
lumatlar bir neç  qrupa ayr r v  h r hans  bir
lumata bu qrupdan yaln z birinin daxilind  olma
haqq  verilir. Bir m lumata müraci t etm k ist diyiniz
zaman o m lumat n hans  qrup daxilind  ola bil yini
bildikd , onu yaln z o qrup daxilind  axtarars z. Bu
müraci t müdd tini çox q sald r.
n, m lumatlar strukturunda ada gör  axtar
apar ld  zaman m lumatlar ad n ilk h rfin  gör
qrupla larsa, bütün m lumatlar 32 müxt lif qrupa
ay rmaq laz md r. Bel  bir m lumatlar strukturunda
“ nan Seyidzad ” adl  m lumata müraci t etm k
ist rsinizs , sad , “K” qrupuna baxma z
kifay tdir. Bu misalda “ nan Seyidzad ” adl  bir
lumat n qrup müraci t kodu (hash value) “K”-dir.
Bu üsul container class kitabxanas  daxilind
HashTable sinfi t find n t tbiq edilir. Bu sinfin
proqramç dan gözl diyi yaln z bir ey is , HashTable v
ya bu sinifd n tör n sinifl r daxilind  istifad  edil k
lumat sinifl rinin obyektl rinin saxlad qlar  m lumat
msil ed n qrup nömr si verm ridir. Object sinfind n
tör n h r obyektin bu qiym ti ver  bilm si üçün
hashValue() üzv funksiyas ndan istifad  edilir. Bu
funksiya obyektin daxilind  olmas  laz m g n qrupun
nömr si il  geri qay r. Object sinfind n tör n h r
obyekt üçün bu üzv funksiyas n yaz lmas  vacibdir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
221
virtual int isEqual(const Object& Test) const = 0;
Object sinfind n tör n h r sinif üçün t yin
edilm si vacib olan bir dig r üzv funksiya is isEqual
funksiyas r.  Bu  funksiya  bir  parametri  olan Object
sinfinin Test obyekti il sas obyektin eyni qiym tl
malik olub olmad na n zar t edir. Bu funksiya iki
Object obyektinin b rab r olub olmad na n zar t etm k
üçün istifad  olunur. Bunun üçün obyektl rin ilk
növb  eyni sinifd n olmas  vacibdir. Bu n zar t
operator == vasit sil  olunur. Ancaq eyni sinf  daxil olan
iki obyekt müqayis  edil rs , isEqual sinfi ça r. Bu da
Test parametrinin isEqual sinfinin aid oldu u sinif il
eyni sinifd n olmas  m nas na g lir. Bu halda Test tip
çevrilm si yerin  yetiril k üzv d yi nl ri müqayis
edilm lidir. Bu müqayis  n tic sind  iki obyektin eyni
qiym  malik olmas na q rar veril rs 1, müxt lif
qiym tl  malik olduqlar na dair q rar veril rs , 0
qiym ti geri qaytar r.
virtual int isSortable() const;
Bu funksiya obyektin (sinfin) s ralan b
ralanmayaca  t yin ed n funksiyad r. r bir sinfin
obyektl ri s ralana bil rs 1,  ks  halda 0 qiym ti bu
funksiyadan geri qaytar r. Bu qayda il  obyektl ri iki
hiss  ay rmaq mümkündür: s ralana bil n obyektl r v
Etibar Seyidzad
222
ralanmayan obyektl r. Bunlardan s ralanmayan
obyektl r Object, s ralana bil n obyektl r is Sortable
sinfind n tör n sinifl rd n ld  edilir. Object sinfi  bu
funksiya üçün 0, Sortable sinfi is 1 qiym tini geri
qaytar r. Bu s bd n, bu funksiya h r sinif üçün yenid n
yaz lmal r.
virtual int isAssociation() const;
isSortable funksiyas na ox ar olaraq, isAssociation
funksiyas  bir obyektin iki obyekt aras ndak laq ni
(Association) göst n obyekt olub olmad , y ni bu
obyektin strukturunda bir-biri il laq ndirilmi  iki
müxt lif obyektin olub olmad  bildirir. Normal olaraq
laq li m lumatlardan ibar t obyektl r Association
obyektind n tör ndiyi üçün dig r sinifl r üçün bu
funksiya 0 qiym tini geri qaytar r.
virtual void forEach(iterFuncType Func, void* Data) const;
Bu funksiya da yenid n yaz lmas  laz m olmayan
bir funksiyad r. forEach ilk parametri olan Func
funksiyas  ça r. Ça lan Func funksiyas n iki
parametrind n birincisi obyektin özü, ikincisi is forEach
funksiyas n ikinci parametri olan Data göst ricisidir.
Bu funksiya h qiq n d  bir çox obyektin daxil
oldu u m lumatlar strukturu üz rind  bu struktura daxil
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
223
olan bütün obyektl  eyni funksiyan n (Func) t tbiq
edilm sini, Data göst ricisi is  bu funksiyan n ehtiyac
duydu u qiym tl rin funksiyaya müraci t etm sini
min edir.
virtual Object& firstThat(condFuncType Func, void* Data)
const;
firstThat funksiyas  da forEach funksiyas na ox ar
olaraq Func n zar t funksiyas  ça r. Obyektin özünü
birinci, Data göst ricisini d  ikinci parametr kimi bu
funksiyaya gönd rir. Func funksiyas ndan geri qaytar lan
qiym t s rdan f rqli olarsa, obyekti (*this qiym tini),
r olarsa, NOOBJECT qiym tini geri qaytar r.
Bu funksiya bir obyektin obyekt qrupu daxilind
mü yy n rtl  uy un olaraq m lumatlar strukturu
daxilind ki yerl sin  gör  ilk obyekt olub olmad
anlamaq üçün istifad  edilir.
virtual Object& lastThat(condFuncType Func, void* Data)
const;
Bu funksiya firstThat funksiyas n i
prinsipin  uy un olaraq icra olunur. Yaln z obyektin
lumatlar qrupu daxilind  yerl sin  gör  mü yy n
olunmu rtl ri t min ed n n son obyekt olub
olmad  anlamaq üçün istifad  edilir.
Etibar Seyidzad
224
virtual void printOn(ostream& Stream) const = 0;
Bu funksiya t yin olunan h r yeni sinif üçün
yaz lmas  vacib olan bir funksiyad r. Stream il  t yin
olunan ax na obyektin ifad  etdiyi m lumatlar n
yaz lmas  t min edir.
friend ostream& operator<<(ostream& Stream, const Object&
obyekt);
yin olunan bu operator funksiyas  il Object
sinfind n tör n bütün sinifl rin obyektl rinin ostream
 bundan tör n ax nlar üz rin  yaz la bil yini
göst rir. Bu operator funksiyas
obyekt.printOn(Stream);
klind  t sir  s b olur.
int operator ==(const Object& Test1, const Object& Test2);
int operator !=(const Object& Test1, const Object& Test2);
Bu iki operator funksiyas Test1 v Test2 Object
obyektl rinin müqayis sini t min edir. Bu funksiyalardan
birincisi b rab r olmalar  hal nda, dig ri is  b rab r
olmamalar  hal nda s rdan f rqli bir qiym t il  geri
qay r. Bir misala baxaq.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
225
//IKILIK.CPP
#include <conio.h>
#include <object.h>
#include <clstypes.h>
#define ikilikClass __firstUserClass
class Ikilik : public Object
{  int x, y;
   public:
     Ikilik(int = 0, int = 0);
     int X() const {  return x;  }
     void X(int);
     int Y() const {  return y;  }
     void Y(int);
     classType isA() const;
     char* nameOf() const;
     hashValueType hashValue() const;
     int isEqual(const Object&) const;
     void printOn(ostream&) const;
};
Ikilik::Ikilik(int a, int b)
{  x = a;
   y = b;
}
void Ikilik::X(int a)
{  x = a;  }
void Ikilik::Y(int b)
{  y = b;  }
classType Ikilik::isA() const
Etibar Seyidzad
226
{  return ikilikClass;  }
char* Ikilik::nameOf() const
{  return "Ikilik";  }
hashValueType Ikilik::hashValue() const
{  return 0;  }
int Ikilik::isEqual(const Object& Test) const
{  return ((Ikilik&)Test).x == x && ((Ikilik&)Test).y == y;  }
void Ikilik::printOn(ostream& Stream) const
{  Stream<<nameOf()<<"("<<x<<","<<y<<")\n";  }
//********************************************************
struct Miqdar{
int Dx, Dy;
};
void Surustur(Object& _Obyekt, void* _Data)
{  Ikilik& Obyekt = (Ikilik&)_Obyekt;
   struct Miqdar *Data = (struct Miqdar*)_Data;
   Obyekt.X(Obyekt.X() + Data->Dx);
   Obyekt.Y(Obyekt.Y() + Data->Dy);
}
//*******************************************************
main()
{  clrscr();
   Ikilik A(30, 10);
   Ikilik B(40, 50);
   struct Miqdar SurusturmeMiqdari = {  10, 40  };
   cout<<A<<"\n\tA obyekti B obyektine ";
   if(A == B) cout<<"beraberdir\n";
   else cout<<"beraber deyildir\n";
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
227
   A.forEach(Surustur, &SurusturmeMiqdari);
   cout<<A<<"\n\tA obyekti B obyektine ";
   if(A == B) cout<<"beraberdir\n";
   else cout<<"beraber deyildir\n";
   return 0;
}
8.4.2 Error
Error sinfi Class kitabxanas  daxilind  meydana
n s hv v ziyy tl rini h qiqi qiym tl rd n ay rmaq
üçün istifad  edil n köm kçi sinifdir. M n, bir Object
massivinin bo  olan, h  obyekt yerl dirilm mi
elementl rin Error sinfinin obyektl ri m nims dil k
bu hal mü yy nl mi  olur. Ümumiyy tl  bu liyyat
üçün istifad  olunan NOOBJECT bu sinfin bir obyektidir.
NOOBJECT obyektinin t yin edilm si üçün bu sinif
tör dilmi dir. Error sinfi Object sinfinin xüsusiyy tl rini
hvil almaqla yana  b zil rini d  d yi dirmi dir.
Error sinfi il  b rab r yenid n yaz lan üzv
funksiyalar n davran lar  a dak  kimidir:
Üzv funksiya Qiym ti
isA() errorClass
nameOff() “Error”
Etibar Seyidzad
228
8.4.3 Sortable
Sortable öz aralar nda s ralana bil n obyektl rin
sinifl rinin t yin edilm si üçün n rd  tutulmu  bir
sinifdir. Sortable sinfi çox istifad  olunmur. Sad
ralana bil n obyektl rin tör dilm si üçün haz rlanm
baza sinfidir.
Tör ndiyi obyekt sinfind n f rqli davranan üzv
funksiyalar  v  geri qaytard  qiym tl r a dak lard r:
Üzv funksiya Qiym ti
isA() sortableClass
isSortable() 1
Burada isSortable() funksiyas n 1 qiym tini
qaytard na diqq t edin. Bundan sonra Sortable
sinfind n tör dil k sinifl r s ralana bil n obyektl rin
sinifl ri olacaqlar  üçün bu sinifl ri tör rk n
isSortable() funksiyas  yenid n yazmaq
cburiyy tind  qalmayaca q. Lakin bu d
obyektl rin hans n kiçik, hans n böyük oldu unu
mü yy nl dirm k üçün isLessThan funksiyas na
ehtiyac duyaca q.
virtual int isLessThan(const Object& Test) const;
Bu funksiya isEqual funksiyas na ox ar icra olunur.
isLessThan funksiyas  t yin edilm kd  olan sas sinif il
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
229
eyni sinifd n olan Test obyektinin müqayis sini apararaq
sas obyektin Test obyektind n kiçik olmas  (s ralamada
daha vv l yerl si) hal nda s rdan f rqli bir qiym t
il , böyük v  ya b rab r olmas  hal nda is  s r qiym ti
il  geri qaytar r.
Sortable sinfi üçün isLessThan funksiyas na
saslanaraq <=, <, >, >= operatorlar  yenid n t yin
edilmi dir. Bu operatorlar Sortable sinfi v  bu sinifd n
tör n dig r sinifl r üçün istifad  etm k mümkündür.
8.4.4 String
String sinfi proqramlarda çox istifad  edil n h rf-
m ifad rinin C++ il Class kitabxanas  daxilind
yenid n t yin edilm si üçündür. String Sortable
sinfind n tör nmi  bir sinifdir.
ki müxt lif layih ndiricid n ibar tdir:
String(const char *S);
Bu layih ndirici S il  veril n h rf-r m ifad sinin
bir nüsx sini obyekt daxilind  saxlay r.
String(String& S);
Bu layih ndirici is vv lc n t yin edilmi  bir
String obyektinin saxlad  h rf-r m qiym tinin t yin
Etibar Seyidzad
230
edil k yeni h rf-r m sinfin  köçürülm sini t min
edir.
~String();
Bu sinfin sahib oldu u yoxedici funksiya
layih ndirici t find n h rf-r m sah si üçün ayr lan
yadda n bo ald lmas  t min edir.
operator const char *() const;
Bu sinif eyni zamanda bir d  (char*) tip çevirm
operatoruna malikdir. Bu operatorun köm yi il String
sinfinin obyektl ri asanl qla simvol göst ricisi olaraq
istifad  oluna bil rl r. Bu operator daha çox String
sinfinin obyektl rinin h rf-r m qiym tini öyr nm k
üçündür.
String sinfi bir ax na yaz larsa, slind  saxlad
rf-r m qiym tini ax na yaz r. String sinfinin
obyektl rinin b rab rliyi is  saxlad qlar  h rf-r m
qiym tl rinin b rab rliyi il  t yin olunmu dur.
yin olunmu  dig r iki funksiya v  qaytard
qiym tl r a dak lard r:
Üzv funksiya Qiym ti
isA() stringClass
nameOf() “String”
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
231
//DNSTRING.CPP
#include <conio.h>
#include <strng.h>
#include <iostream.h>
#include <string.h>
main()
{  clrscr();
   char Buffer[80];
   cout<<endl<<"Adiniz :";
   cin>>Buffer;
   String Ad(Buffer);
   cout<<"Soyadiniz :";
   cin>>Buffer;
   String Soyad(Buffer);
   cout<<endl<<Ad<<"\tuzunlugu "<<strlen(Ad)<<endl;
   cout<<Soyad<<"\tuzunlugu "<<strlen(Soyad)<<endl;
   cout<<Ad<<"=="<<Soyad<<"? "
       <<((Ad==Soyad)?"He":"Yox")<<endl;
   cout<<Ad<<"<"<<Soyad<<"? "
       <<((Ad<Soyad)?"He":"Yox")<<endl;
   Ad="Kenan";
   cout<<"\nYeni kimlik-->\t"<<Ad<<" "<<Soyad<<endl;
   return 0;
}
Etibar Seyidzad
232
Birinci icran n n tic si:
Adiniz :Etibar
Soyadiniz :Seyidov
Etibar      uzunlugu 6
Seyidov  uzunlugu 7
Etibar==Seyidov?  Yox
Etibar<Seyidov?  He
Yeni kimlik-->   Kenan Seyidov
kinci icran n n tic si:
Adiniz :Memmed
Soyadiniz :Eliyev
Memmed      uzunlugu 6
Eliyev           uzunlugu 6
Memmed==Eliyev?  He
Memmed<Eliyev?  Yox
Yeni kimlik-->   Kenan Eliyev
8.4.5 BaseDate
BaseDate tarix m lumatlar n bir obyekt kimi
saxlan lmas  üçün Sortable sinfind n tör nmi  birba a
istifad  edilm n, tarixl laq dar tör dil  bil k
sinifl  baza yaratmas  üçün haz rlanm  bir sinifdir.
Qorunmu  (protected) kimi t yin edilmi  üç
layih ndiricisi vard r.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
233
BaseDate(unsigned int Ay, unsigned int Gun, unsigned int Il);
st nil n il (Il),  ay (Ay) v  günün (Gun) tarix olaraq
yeni yarad lan obyektd  saxlanmas  t min edir. S hv
qiym tin daxil edilm si proqram n q lmas na s b
olur.
BaseDate();
Obyektin yarad ld  cari tarixi saxlay r.
BaseDate(BaseDate& date);
vv lc n t yin olunmu  tarix obyektin
saslanaraq yeni yarad lan tarix obyektin vv lki
obyektin göst rdiyi tarixin qiym tini m nims dir.
Obyektin göst rdiyi tarixin mü yy n edilm si üçün
ümumi (public) kimi a dak  üzv funksiyalar  t yin
edilmi dir:
unsigned Day() const;
Obyektin göst rdiyi tarixin gününü 1-d n 31
r bir dl  ifad  edir.
unsigned Month() const;
Etibar Seyidzad
234
Obyektin göst rdiyi tarixin ay 1-d n 12-y  q r
bir dl  ifad  edir.
unsigned Year() const;
Obyektin göst rdiyi tarixin ilini ifad  edir.
Mövcud bir tarix obyektinin göst rdiyi tarixin
yi dirilm si t b olunarsa, bu d  yen  ümumi
(public) kimi t yin olunmu  a dak  üç funksiya istifad
edilir:
void SetDay(unsigned char Gun);
Bu üzv funksiyas  tarix  m nims dil n yeni günün
1-d n 31  q r qiym t almas rtil , tarixin yaln z
gününü d yi dirir.
void SetMonth(unsigned char Ay);
Bu üzv funksiyas  tarix  m nims dil n yeni ay n 1-
n 12-y  q r qiym ti olmaqla, tarixin yaln z ay
yi dirir.
void SetYear(unsigned char Il);
Bu üzv funksiyas  da Il il  göst ril n ili tarixin ilin
nims dir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
235
Bundan ba qa BaseDate sinfi iki tarixin qiym tini
müqayis  edir. r iki tarixin il, ay v  gün qiym tl ri
bir-birin  b rab rdirs , h r iki tarix b rab r say r.
ralama bax ndan tarixl r müqayis  edil rs , Il
qiym ti böyük olan tarix daha böyükdür. Il qiym tl ri d
eyni oldu u halda Ay, Ay qiym tl ri eyni oldu u halda
is Gun qiym tl rin  bax laraq Gun qiym ti daha böyük
olan tarixin böyük oldu u q bul edilir.
8.4.6 Date
BaseDate sinfind n tör n Date sinfinin BaseDate
sinfind n yegan  f rqi printOn funksiyas n yenid n
yaz lmas r. Bu da Date sinfinin çox istifad  olunmas
min edir. Bu funksiya Date sinfinin obyektl rinin “ay,
gün, il” format  il  ba lamas  t min edir. M n, “13-
01-1970” tarixi “January, 01, 1970” olaraq göst ril n
ax na yaz r. Ay ad  göründüyü kimi ingilis dilind dir.
Date sinfinin BaseDate sinfind  oldu u kimi üç
layih ndiricisi vard r. Bu layih ndiricil r BaseDate il
eyni funksiyalar  yerin  yetirirl r. Yaln z bu
layih ndiricil r public s viyy sind  t yin edilmi dirl r.
Üzv funksiya Qiym ti
isA() dateClass
nameOf() “Date”
Etibar Seyidzad
236
//DNDATE.CPP
#include "tarix.h"
#include <conio.h>
#include <ldate.h>
#include <iostream.h>
Date Today;
Date BirthdayOfKenan(10, 18, 1997);
Date BirthdayOfKamran(10, 27, 1996);
Tarix Bugun;
Tarix KenaninDogumGunu(18, 10, 1997);
Tarix KamraninDogumGunu(27, 10, 1996);
main()
{  clrscr();
   cout<<endl<<"Date"<<endl;
   cout<<"Bugun"<<Today<<endl;
   cout<<"Kenan"<<BirthdayOfKenan<<endl;
   cout<<"Kamran"<<BirthdayOfKamran<<endl;
   if(BirthdayOfKenan == BirthdayOfKamran)
     cout<<"Kenan ile Kamran eyni gunde dogulmusdur.\n";
   else if(BirthdayOfKenan < BirthdayOfKamran)
  cout<<"Kenan Kamrandan daha evvel dogulmusdur.\n";
else cout<<"Kenan Kamrandan daha sonra dogulmusdur.\n";
   cout<<endl<<"Tarix"<<endl;
   cout<<"Bugun"<<Bugun<<endl;
   cout<<"Kenan"<<KenaninDogumGunu<<endl;
   cout<<"Kamran"<<KamraninDogumGunu<<endl;
   if(KenaninDogumGunu == KamraninDogumGunu)
     cout<<"Kenan ile Kamran eyni gunde dogulmusdur.\n";
   else if(KenaninDogumGunu < KamraninDogumGunu)
  cout<<"Kenan Kamrandan daha evvel dogulmusdur.\n";
else cout<<"Kenan Kamrandan daha sonra dogulmusdur.\n";
   return 0;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
237
}
//TARIX.H
#ifndef __TARIX_H
#define __TARIX_H
#include <ldate.h>
#define tarixClass 10000
class Tarix:public BaseDate
{
  public:
    Tarix();
    Tarix(unsigned int, unsigned int, unsigned int);
    virtual classType isA() const;
    virtual char* nameOf() const;
    virtual void printOn(ostream&) const;
  protected:
    int day() const;
    unsigned long julday() const;
};
#endif
//TARIX.CPP
#include "tarix.h"
#include <math.h>
#include <iomanip.h>
Tarix::Tarix()
Etibar Seyidzad
238
{}
Tarix::Tarix(unsigned int Gun, unsigned int Ay, unsigned int Il)
:BaseDate(Ay, Gun, Il)
{ }
classType Tarix::isA() const
{  return tarixClass;  }
char* Tarix::nameOf() const
{  return "Tarix";  }
#define MaxBufferLen 30
void Tarix::printOn(ostream& Stream) const
{  static char *AyAdlari[] = {"Yanvar", "Fevral", "Mart", "Aprel",
      "May", "Iyun", "Iyul", "Avqust", "Sentyabr",
      "Oktyabr", "Noyabr", "Dekabr"};
   static char *GunAdlari[] = {"Bazarertesi", "Cersembe axsami",
"Cersembe",
       "Cume axsami", "Cume", "Sembe", "Bazar"};
   char buffer[MaxBufferLen];
   ostream ostr(MaxBufferLen, buffer);
   ostr<<setw(2)<<Day()<<" "<<AyAdlari[Month() - 1]<<" "
       <<setw(4)<<Year()<<" "<<GunAdlari[day()]<<ends;
   Stream<<buffer;
}
#define IGREG (15 + 31L * (10 + 12L * 1582))
unsigned long Tarix::julday() const
{  unsigned long jul;
   int ja, jy, jm, iyyy, mm;
   iyyy = Year();
   mm = Month();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
239
   if(mm > 2)
   {  jy = iyyy;
      jm = mm + 1;
   }
   else
   {  jy = iyyy - 1;
      jm = mm + 13;
   }
   jul = (unsigned long) (floor(365.25 * jy) +
 floor(30.6001 * jm) + Day() + 1720995L);
   if(Day() + 31L * (Month() + 12L * iyyy) >= IGREG)
   {  ja = 0.01 * jy;
      jul += 2 - ja + (int)(0.25 * ja);
   }
   return jul;
}
int Tarix::day() const
{  return (int)((julday() + 1) % 7);  }
8.4.7 BaseTime
BaseDate sinfin  ox ar m ntiql  haz rlanan
BaseTime, Sortable sinfind n tör nmi  v  t yin olunacaq
zaman il laq dar sinifl rin tör dilm sin  baza yaradan
bir sinifdir. Sortable üzvl rini istifad  ed rk n eynil
isA(), nameOf() v printOn() funksiyalar n yenid n
yaz lmas  t b olunur.
Etibar Seyidzad
240
Bu sinif zaman , saat, d qiq , saniy  v  saniy nin
yüzd  biri m rt sind  günlük saxlay r. Saatlar 0-23
aras nda, d qiq  v  saniy r 0-59 aras nda, saniy nin
yüzd  biri is 0-99 aras nda qiym tl r ala bil r.
Bu sinfin üç protected s viyy sind  layih ndiricisi
vard r.
BaseTime(unsigned char saat, unsigned char deqiqe = 0,
            unsigned char saniye = 0, unsigned char yuzdebir = 0);
Günün ist nil n bir an
 saat:d qiq :saniy .yuzd bir
olaraq t yin edir. S hv qiym tin daxil edilm si
proqram n q lmas na s b olur.
BaseTime();
Obyektin yarad lma vaxt  obyektd  saxlay r.
BaseTime(BaseTime& date);
vv lc n t yin edilmi  zaman obyektin
saslanaraq yeni yarad lan zaman obyektin vv lki
obyektin göst rdiyi zaman n qiym tini m nims dir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
241
BaseDate obyektinin göst rdiyi tarixin öyr nilm si
üçün ümumi (public) olaraq a dak  üzv funksiyalar
yin edilmi dir:
unsigned hour() const;
unsigned minute() const;
unsigned second() const;
unsigned hundredths() const;
hour saat, minute d qiq , second saniy , hundredths
is  saniy nin yüzd  birini mü yy nl dirm k üçün
istifad  edilir.
Mövcud bir zaman obyektinin göst rdiyi zaman n
yi dirilm si t b olunarsa, ümumi (public) kimi t yin
edilmi  a dak  funksiyalar istifad  edil  bil r:
unsigned setHour(unsigned char Saat) const;
unsigned setMinute(unsigned char Deqiqe) const;
unsigned setSecond(unsigned char Saniye) const;
unsigned setHundredths(unsigned char Yuzdebir) const;
Bu funksiyalar ard l olaraq zaman n, saat, d qiq ,
saniy  v  saniy nin yüzd  birinin qiym tl rinin bir-
birind n ayr qda d yi dirilm sin  imkan verirl r.
BaseTime sinfi zaman m lumatlar n b rab rliyini,
r iki zaman obyektinin saat, d qiq , saniy  v
saniy nin yüzd  birinin qiym tl rinin b rab r olmas
kimi t yin edilmi dir. Eyni zamanda kiçiklik laq sini d
yin edir.
Etibar Seyidzad
242
8.4.8 Time
Time is BaseTime sinfind n tör nmi  sad  bir
zaman sinfidir. stifad  olunmas  bax ndan
miyy tlidir.
Time sinfinin n çox istifad  edil n funksiyalar
dak lard r:
Üzv funksiya Qiym ti
isA() timeClass
nameOf() “Time”
Bu sinfin d BaseTime sinfind kil  uy un olan,
lakin public s viyy sind  üç layih ndirici funksiyas
vard r:
Time(unsigned char saat, unsigned char deqiqe = 0,
          unsigned char saniye = 0, unsigned yuzdebir = 0);
Günün ist nil n bir an n
saat:d qiq :saniy .yuzd bir
format nda saxlan lmas  t min edir. S hv qiym tin
daxil edilm si proqram n q lmas na s b olur.
Time();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
243
Obyektin yarad ld  zaman  obyektd  saxlay r.
Time(BaseTime& date);
vv lc n t yin edilmi  zaman obyektin
saslanaraq yeni yarad lan zaman obyektin vv lki
obyektin göst rdiyi zaman n qiym tini m nims dir.
printOn(ostream& Stream) const;
funksiyas  zaman  ikir mli dl r klind
SS:DD:ss.YY ZM
SS saat, DD d qiq , ss saniy , YY saniy nin yüzd  biri v
ZM günortadan vv l/günortadan sonran
mü yy nl dir k Stream ax na yaz r. ZM günortadan
vv l saat 0-12 aras ndak  qiym tl r üçün am,
günortadan sonra saat 12-24 aras nda is pm klind
göst rilir.
//TIME.CPP
#include <conio.h>
#include <ltime.h>
main(void)
{  clrscr();
   Time Baslangic;
   cout<<"Proqramdan cixmaq ucun ESC duymesini sixin...\n";
Etibar Seyidzad
244
   _setcursortype(_NOCURSOR);
   int Davam = 1;
   while(Davam)
   {  cout<<Time()<<'\r';
      if(kbhit()) Davam = getch() != 27;
   }
   _setcursortype(_SOLIDCURSOR);
   Time Son;
   cout<<"\n\nProqramin baslama saati = "<<Baslangic;
   cout<<"\nProqramin bitmesi saati = "<<Son;
   cout<<endl;
   return 0;
}
Proqram ç
Proqramdan cixmaq ucun ESC duymesini sixin...
9:47:27.60 pm
Proqramin baslama saati = 9:47:27.20 pm
Proqramin bitmesi saati = 9:47:27.60 pm
8.4.9 Association
Obyekt sinfind n tör nmi Association sinfi
struktur olaraq t rkibind  iki Object sinfind n tör nmi
obyekti  (t qdimat  kimi)  saxlayan  bir  növ  xüsusi  obyekt
sinfidir. Association sinfi t rkibind  t qdimat
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
245
lumatlar  saxlad  bu iki sinif aras nda laq nin
olmas  t yin edir. Bu sinifl rd n birincisi açar (key),
ikincisi is qiym t (value) adland r. Association sinfi
daha çox bir  qrup kimi  daxilind  mü yy n açara  uy un
n qiym ti tapmaq üçün Dictionary sinfinin t lini
yaratmaq üçün layih ndirilmi dir.
Üzv funksiya Qiym ti
isA() associationClass
nameOf() “Time”
Bu sinfin iki layih ndirici funksiyas  vard r:
Association(Object& key, Object& value);
Parametr siyah ndak key (açar) il value (qiym t)
aras nda laq  oldu unu bil n Association obyektini
yin edir.
Association(const Association& association);
Bu layih ndirici mövcud association obyektin
saslanaraq eyni laq li Association obyekti t yin edir.
Yenid n t yin edilmi  dig r üzv funksiyalar v
onlar n v zif ri a dak lard r:
hashValueType hashValue() const;
Etibar Seyidzad
246
Association sinifli bir obyektin hashValue qiym ti,
obyektin laq rini t yin etdiyi obyektl rd n key (açar)
olaraq ayr lm  obyektin hashValue qiym tidir. Value
(qiym t) obyekti n  al nmaz. Key (açar)  obyekti   bu
laq  n tic sind  meydana g n obyekti t kba na t msil
edir. Association sinfind n iki obyektin qar la lmas
zaman  eyni cür davran  gözl nilir.
int isEqual(const object& Test) const;
Bu funksiya Association sinfin  daxil olan iki
obyekti müqayis  edir v  onlar b rab r olarsa, s rdan
rqli bir qiym t, f rqli olarsa, s r qiym tini geri
qaytar r. Association sinifli iki obyektin b rab rliyi iki
Association obyektinin d key (açar) qiym tl rinin
rab r olmas  kimi t yin edilmi dir.
void printOn(ostream& Stream) const;
Association sinfinin obyektl rinin ax n üz rin
yaz lmas  normal hallarda
sinif_ad  { key_object, value_object }
format  il  olur. sinif_ad  is nameOf() il  öyr nildiyi
üçün Association olur. T bii ki, bu format Association
sinfind n tör dil k yeni sinifl rin printOn funksiyas
yenid n yazaraq d yi dirm k mümkündür.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
247
Association sinfi il  t yin edilmi  iki yeni funksiya
is Association obyektinin aralar nda laq  qurdu u key
(açar) v value (qiym t) obyektl rin  müraci t edilm sini
min edir.
Bu iki funksiya a dak  prototipl ri il  t yin edilir:
Object& key() const;
Object& value() const;
8.5 M lumatlar Sturukturu Sinifl ri
Mövcud proqramla rma dill ri m lumatlar qrupu
olan massivl ri (ProLog v LISP siyah  strukturlar )
st kl yir. Bu bax mdan massivl r (c dv ll r d
adland r) proqramla rma dili üçün çox miyy tli
bir mövzunu t kil edir. M lumatlar sturukturu is
sad , massiv v  ya siyah dan ibar t deyildir. Xüsusi
qs dl r üçün oldu u kimi, ümumi m qs dl r üçün d
müxt lif m lumatlar qrupu t yin etm k olar.
ndi d Container Class kitabxanas nda t yin
olunmu  m lumatlar strukturlar  gözd n keçir k.
8.5.1 Container
Çox istifad  olunmayan Container sinfi sas n
ntiqi olaraq müxt lif tipli (hams  eyni d  ola bil r)
Etibar Seyidzad
248
lumatlar  t rkibind  saxlayan v  bu m lumatlar n
yadda da saxlan lmas  nizamlayan bir sinifdir. Bu sinif
dig r yadda  sinifl rinin tör dilm si üçün baza t kil
etdiyi üçün çox miyy tlidir.
Bu sinif d Object sinfind n tör ndiyi üçün onun
xüsusiyy tl rini miras alm  v  d yi dirmi dir.
virtual classType isA() const = 0;
virtual char* nameOf() const = 0;
virtual hashValueType hashValue() const = 0;
Bu üzv funksiyalar Object sinfind  oldu u kimi
eyni m nan  ifad  edirl r. Lakin Container sinfi daxilind
kodla lmayaraq ondan tör dil k sinifl r üçün
kodla lmalar  vacibdir.
virtual int isEqual(const Object& Test) const;
Bu üzv funksiyas  is  iki Container obyektinin
rab rliyini  yoxlay r.  B rab r  olmalar  üçün  h r  iki
Container obyektinin eyni sayda elementd n ibar t
olmas  v  eyni mövqed ki element obyektl rinin b rab r
olmas rtdir.
Container sinfi il  birlikd  t yin olunan yeni üzv
funksiyalar  is  a dak lard r:
int isEmty() const;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
249
Container obyekti daxilind  heç bir obyekt olmazsa,
r qiym ti il  geri qay r. Bu funksiya Container
obyektinin sanki bo  olub olmad  mü yy nl dirir.
countType getItemsInContainer() const;
Bu funksiyas  is Container obyektin  daxil olan
obyektl rin say protected s viyy sind  t yin etdiyi
countType itemsInContainer;
yi nind  saxlay r. Container obyektin  h r d  yeni
obyekt lav  edildiyi zaman bu qiym t bir vahid art r.
Xaric edil n h r obyekt üçün d  bir vahid azal r.
virtual void printOn(ostream& Stream) const;
virtual void printHeader(ostream& Stream) const;
virtual void printSeperator(ostream& Stream) const;
virtual void printTrailer(ostream& Stream) const;
Container sinfi obyektinin ax na yaz lmas  t min
ed n sas funksiya printOn() funksiyas r. printOn()
printHeader() funksiyas  ça raraq liyyata ba lay r.
printHeader() ax na gönd ril k m lumatlar n vv lin
ba q lav  edilm si m qs dil  istifad  olunur.
lumatlar n vv lin lav  olunan bu ba q Container
sinfi üçün obyektin ad  (nameOf() il  öyr nilir) v  “{“
ar sidir. printOn() funksiyas  daha sonra Container
daxilind ki obyektl ri ard l olaraq yazma a ba lay r.
Etibar Seyidzad
250
Yazd  obyektl r aras nda is printSeperator()
funksiyas  ça r. printSeperator() is  yaz lan
obyektl rin bir-birind n ayr lmas  t min edir. Bunun
siri Container sinfi üçün “,\n” m saj n yaz lmas
klind  görünür. Container daxilind ki bütün obyektl r
yaz ld qdan sonra da printTrailer() funksiyas  ça laraq
yazma liyyat  tamamlan r. Bu funksiya da Container
sinfi üçün “}“ simvolunun yaz lmas klind  t sir
göst rir.
virtual void forEach(iterFunctionType iterfunc, void *param);
Bu funksiya Object sinfinin t yin edilm sind n
rql nir. forEach funksiyas iterfunc parametri il  veril n
void iterfunc(Object& obyekt, void *param);
klind  funksiyan n, Container sinfin  daxil  olan  bütün
obyektl  ard l olaraq t tbiq edilm sini t min edir.
iterfunc funksiyas n ikinci parametri olan param il
forEach funksiyas n ikinci parametri olan param eyni
qiym tl rdir.
virtual Object& firstThat(contFuncType condfunc, void *param)
const;
virtual Object& lastThat(contFuncType condfunc, void *param)
const;
Bu funksiyalar
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
251
int confunc(Object& obyekt, void* param);
klind  t yin edil n v  birinci parametr il  göst ril n bir
müqayis  funksiyas na Container obyekti daxilind  olan
obyektl ri ard l olaraq t tbiq edir. condfunc funksiyas
obyektl rin mü yy n olunmu rti öd yib
öd dikl rini yoxlay r. Uy un rti öd n obyektl r
üçün s rdan f rqli qiym ti, rti öd n obyektl r
üçün is  s r qiym tini qaytar r.
Bu funksiyalardan firstThan condfunc
funksiyas ndan s rdan f rqli bir qiym t il  geri
qaytar lan ilk obyekti, lastThan is  son obyekti geri
qaytarma qiym ti kimi qaytar r.
virtual ContainerIterator& initIterator() const = 0;
Bu funksiya is  yenil yicil r bölm sind rh
edil k bir yenil yici (iterator) Container sinfinin obyekti
üçün haz rlayaraq geri qaytarma qiym ti kimi qaytar r.
8.5.2 Stack
sas m lumatlar strukturu olan Stack, Last In First
Out – LIFO (son gir n ilk ç xar) qaydas  il  i n bir
Container sinfidir. Stack strukturunda yadda a yeni
yerl diril k obyekt dig r obyektl rin üz rin
Etibar Seyidzad
252
yerl dirilir. Yadda dan bir obyektin geri qaytar lmas
b olundu u zaman da üstd ki obyekt geri qaytar r.
Araya  bir  obyekt  lav  etm k  v  ya  aradan  bir  obyekti
xarmaq mümkün deyildir.
Stack sinfi Container sinfind n tör nmi dir.
Yenid n t yin olunduqlar  funksiyalar
dak lard r:
Üzv funksiya Qiym ti
isA() stackClass
nameOf() “Stack”
Stack strukturuna yeni lav  edil n üzv funksiyalar
is  a dak lard r:
void push(Object& obyekt);
Bu funksiya obyekt parametri il  veril n Object
sinfind n tör nmi  bir obyektin Stack daxilin
yerl dirilm sini t min edir. Yerl dirm  t bii olaraq
Stack strukturundak  bütün obyektl rin üz rin
olacaqd r.
Object& pop();
Bu funksiya Stack yadda n n üstd ki obyekti
geri  qaytarma  qiym ti  kimi  qaytarark n  bu  obyektin
yadda dan ç xar lmas na da s b olur.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
253
Object& top();
Bu funksiya Stack yadda n n üstd ki obyektinin
öyr nilm sini t min edir v  obyekti yadda dan ç xartm r.
virtual ContainerIterator& initIterator() const;
Bu funksiya Stack yadda  üz rind  bir yenil yici
yin etm k üçün istifad  olunur. Yenil yici Stack
daxilind ki obyektl ri son daxil olandan ilk daxil olana
r yenil dirir.
//DNSTACK.CPP
#include <conio.h>
#include <stack.h>
#include <strng.h>
main()
{  clrscr();
   Stack Yigin;
   char oxu[80];
   cout<<"Verilenlerin girisini tamamlamaq ucun \'.\' daxil edin...\n";
   do
   {  cout<<"> ";
      cin>>ws>>oxu;
      Yigin.push(*new String(oxu));
   }
   while(oxu[0] != '.');
   cout<<Yigin<<endl;
Etibar Seyidzad
254
   cout<<"Yiginda "<<Yigin.getItemsInContainer()
       <<" element var.\n";
   while(!Yigin.isEmpty())
   {  Object& Obyekt = Yigin.pop();
      cout<<Obyekt<<endl;
      delete &Obyekt;
   }
   cout<<endl;
   return 0;
}
Proqram ç
Verilenlerin girisini tamamlamaq ucun ‘.’ daxil edin...
> Baki
> Gence
> Quba
> Sumqay t
> .
List  {
       .,
       Sumqayit,
       Quba,
       Gence,
       Baki }
Yiginda 5 element var.
.
Sumqayit
Quba
Gence
Baki
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
255
8.5.3 Deque
Container sinfind n tör nmi Deque sinfi Stack
sinfin  ox ar formada i yir. Deque sinfind  obyekt
yadda a onun sol (alt) v  ya sa  (üst) ucundan ba layaraq
yerl diril  bil r. Deque yadda ndan al nacaq obyekt
onun  sol  v  ya  sa  ucundak  obyekt  ola  bil r.  Ortadak
bir obyekti Deque yadda ndan ç xartmaq mümkün
deyildir.
Deque sinfinin Container sinfind n al b d yi dirdiyi
funksiyalar a dak lard r:
Üzv funksiya Qiym ti
isA() dequeClass
nameOf() “Deque”
virtual ContainerIterator& initIterator() const;
Bu funksiya Deque yadda  üz rind  bir yenil yici
yin etm k üçün istifad  edilir. Yenil yici Deque
daxilind ki obyektl ri Deque yadda n sol ucundan sa
ucuna do ru yenil yir. r obyektl rin t rs ard ll qda
yenil nm si t b olunarsa, bunun üçün
ContainerIterator& initReverseIterator() const;
üzv funksiyas ndan istifad  etm k olar. Bu funksiya
virtual deyildir. Sad Deque üçün t yin edilmi dir.
Etibar Seyidzad
256
Deque üçün t yin edilmi  dig r funksiyalar is
dak lard r:
void putLeft(Object& obyekt);
void putRight(Object& obyekt);
Bu funksiyalar obyektl rin Deque yadda na lav
edilm rini t min edir. Bunlardan putLeft() obyektl ri
yadda n sol ucuna, putRight() is  sa  ucuna yerl dirir.
Object& peekLeft();
Object& peekRight();
Bu  funksiyalar  is Deque yadda n  sa  v  sol
uclar ndak  obyektl rin mü yy nl dirilm sini t min
edir. peekLeft() sol ucundak , peekRight() is  sa
ucundak  obyektl ri mü yy nl dirir.
Object& getLeft();
Object& getRight();
Bu funksiyalar uy un olaraq peekLeft() v
peekRight() kimi icra olunmalar  il  b rab r, uclardak
obyektl ri mü yy nl dirm kl  yana  bu obyektl ri
Deque yadda ndan ç xar rlar.
//DNDEQUE.CPP
#include <conio.h>
#include <deque.h>
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
257
#include <strng.h>
#include <ctype.h>
main()
{  clrscr();
   Deque Yigin;
   char oxu[80];
   cout<<"Verilenlerin girisini tamamlamaq ucun \'.\' daxil edin...\n";
   do
   {  cout<<"> ";
      cin>>ws>>oxu;
      if(isupper(oxu[0]))
Yigin.putLeft(*new String(oxu));
      else Yigin.putRight(*new String(oxu));
   }
   while(oxu[0] != '.');
   cout<<Yigin<<endl;
   cout<<"Yiginda "<<Yigin.getItemsInContainer()
       <<" element var.\n";
   while(!Yigin.isEmpty())
   {  Object& Obyekt = Yigin.getRight();
      cout<<Obyekt<<endl;
      delete &Obyekt;
   }
   cout<<endl;
   return 0;
}
Proqram ç
Verilenlerin girisini tamamlamaq ucun ‘.’ daxil edin...
> Kenan
> Ismayil
> Amil
Etibar Seyidzad
258
> Ramil
> Kamil
> .
DoubleList  {
       Kamil,
       Ramil,
       Amil,
       Ismayil,
       Kenan,
       . }
Yiginda 6 element var.
.
Kenan
Ismayil
Amil
Ramil
Kamil
8.5.4 Queue
Deque yadda n m hdudla lm  bir t tbiqi
olan Queue sinfind  obyektl r yadda a bir ucdan
yerl dirilib dig r ucdan ç xar la bil r. Ba qa sözl ,
Queue yadda n i  formas  “ilk gir n ilk ç xar”
(Firs In First  Out  – FIFO) kilnd dir. Queue bir yadda
növb sidir.
Queue sinfinin Container sinfind n al b d yi dirdiyi
funksiyalar a dak lard r:
Üzv funksiya Qiym ti
isA() queueClass
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
259
nameOf() “Queue”
Bu sinif üçün t yin olunmu  üzv funksiyalar
dak lard r:
void put(Object& obyekt);
üzv funksiyas  obyekti növb nin sonuna lav  edir.
Object& get();
üzv funksiyas  is  növb nin vv lind ki obyekti
növb n ç xararaq geri qaytarma qiym ti olaraq
qaytar r.
Object& peekLeft();
Object& peekRight();
is Deque sinfind  oldu u kimi Queue sinfind  növb nin
ba lan nda v  sonundak  obyektl rin yaln z
mü yy nl dirilm si üçün istifad  edilir. Bunlardan
peekLeft() növb nin sonundak , peekRight() funksiyas
is  növb nin vv lind ki obyekti göst rir.
8.5.5 PriorityQueue
PriorityQueue Container sinfind n tör nmi  xüsusi
bir növb  tipidir. PriorityQueue növb si  “ n  böyük  ilk
Etibar Seyidzad
260
xar” (“Greatest In First Out” – GIFO) v  ya “ n kiçik ilk
xar” (“Smallest  In  First  Out”)  – SIFO) qaydalar ndan
biri il  i yir. Y ni növb  daxil olan obyektl r
prioritet  gör  s ralanm  olur. Növb n bir qiym tin
al nmas  laz m g ldiyi zaman prioritetin  gör  birinci
n obyekt al r.
PriorityQueue növb si daxilind ki obyektl rin
yerl kl ri yer, isLessThan funksiyas  vasit sil
mü yy nl dirilir. Kiçik olan obyekt birincidir. Bir-birin
rab r olan obyektl r is  “birinci g n ilk prioritetlidir”
qaydas  il  yerl dirilir. Buna gör  d PriorityQueue
növb si daxilind  ancaq Sortable sinfind n tör nmi
sinifl r a dak lard r.
 Üzv funksiya Qiym ti
isA() priorityQueueClass
nameOf() “PriorityQueue”
Object& get();
Növb nin ba lan ndak  birinci olan obyekti geri
qaytarma qiym ti olaraq qaytarark n bu obyekti eyni
zamanda növb n ç xar r.
Object& peekLeft();
get() funksiyas na ox ar kild  çal an bu funksiya
is  sad  prioritetin  gör  birinci olan obyektin
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
261
mü yy nl dirilm si üçün istifad  edilir. Obyekti
növb n ç xarm r.
void detachLeft();
Bu funksiya is  növb  daxilind  birinci olan
obyektin sad  növb n ç xar lmas  t min edir.
Obyektin mü yy nl dirilm si üçün istifad  edilm z.
void put(Object& obyekt);
Bu funksiya parametr siyah nda veril n obyekt
obyektini, növb  siyah nda prioritetin  uy un yerd
yerl dirir.
8.5.6 Collection
Collection sinfi Conatainer sinfind  t tbiq edil n
obyektl rin mü yy n qaydaya gör  yadda a yerl dirilib,
yen  mü yy n bir qayda il  yadda dan xaric edilm sini
 alaraq obyektl rin yadda  daxilind  axtar b
tap lmas , ist nil n zaman ç xar lmas , ist nil n yer
qoyulmas sas nda i yir. Collection Container kimi
istifad  olunan bir sinif deyildir. Ox ar sinifl  baza
yarad r.
virtual classType isA() const = 0;
virtual char* nameOf() const = 0;
Etibar Seyidzad
262
virtual hashValueType hashValue() const = 0;
virtual containerIterator& initIterator() const = 0;
Container sinfind n al nan bu üzv funksiyalar
yenid n yaz laraq Collection sinfind n tör k sinifl
verilir.
Collection üçün yeni t yin edil n üzv funksiyalar is
dak lard r:
virtual void add(Object& obyekt) = 0;
Bu üzv funksiyas  yeni bir obyekti kolleksiyaya
daxil etm k üçün istifad  edilir.
virtual void detach(const Object& obyekt, int tip = 0) = 0;
Bu üzv funksiyas  is  birinci parametr il  veril n
obyektin kolleksiyadan ç xar lmas  t min edir.
Verilm si hal nda s r qiym tini alan tip parametrinin
r qiym ti üçün obyekt sad  kolleksiyadan ç xar ld
zaman, s rdan f rqli qiym tl r üçün is  kolleksiyadan
xar ld qdan sonra yadda dan da silin kdir.
void destroy(const Object& obyekt);
destroy funksiyas detach funksiyas tip parametri
1 olmas  il  ça r. Y ni obyekt obyektin  b rab r
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
263
obyekti kolleksiyada taparaq oradan ç xar r v
yadda dan silir.
virtual Object& findMember(const Object& obyekt) const;
findMember üzv funksiyas  kolleksiya daxilind
obyekt obyektin  b rab r olan obyekti axtar r v  tapd
ilk obyekti geri qaytar r. Axtar lan obyekt tap lmazsa,
NOOBJECT qiym tini qaytar r.
virtual int hashMember(const Object& obyekt) const;
Bu üzv funksiya is  veril n obyektin Collection
daxilind  tap b tap lmad na n zar t edir. Uy un
obyekt Collection daxilind  tap larsa, s rdan f rqli bir
qiym ti il  tap lmazsa, s r qiym tini qaytar r.
8.5.7 List
lumatlar strukturlar  aras nda n
miyy tlil rind n biri olan list strukturu, sas
lumat  göst n qdimat (referans) v  bu
lumatdan sonra g n siyah  elementini göst n bir
göst ricid n ibar tdir. Bu siyah  elementl rinin bir-
birinin ard nca lav  edilm sini z ncir formas nda siyah
strukturlar ld  edilir. Siyah  daxilind ki h r element öz
Etibar Seyidzad
264
lumat na v  sonrak  element  müraci t ed  bil k
lumata malikdir.
Stack, Queue, Referans v Set kimi dig r
lumatlar strukturlar  da siyah  strukturundan istifad
ed k, sad  bu struktura m lumatlar n daxil/xaric
edilm si il laq dar m hdudiyy tl r g tirmi dir.
Bununla da siyah  strukturlar  proqramla rma
bax ndan miyy tli yer tuturlar.
List sinfinin Collection sinfind n miras ald  v
yenid n t yin etdiyi funksiyalar a dak lard r:
Üzv funksiya Qiym ti
isA() listClass
nameOf() “List”
hashValue() 0
Object& peekHead() const;
Sonrak
M ’lumat
Sonrak
M ’lumat
Sonrak
M ’lumat
Kök
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
265
Bu üzv funksiyas  siyah ya n son lav  edil n
obyekti geri qaytarma qiym ti olaraq qaytar r. Siyah  bo
olarsa, bu funksiya NOOBJECT qiym tini qaytar r.
Bunun xaricind ki üzv funksiyalar Collection,
Container sinifl rind  t yin olunan funksiyalard r. V  bu
sinifl rin gördüyü liyyatlar  yerin  yetirirl r.
8.5.8 DoubleList
Collection sinfind n tör n DoubleList sinfi List
sinfind n f rqli olaraq m lumat  göst n m lumat
qdimat  v  sonrak  siyah  elementini  göst n  sonrak
lumat t qdimat  il  b rab r vv lki m lumat
elementini göst n vv lki m lumat t qdimat na da
malikdir.
Bu struktur biristiqam tli siyah  strukturlar na
nisb n daha çox yadda  t b edir, lakin h r iki
M ’lumat M ’lumat
vv lki Sonrak vv lki Sonrak
Kök
Bo
Bo
Son
Etibar Seyidzad
266
istiqam td  d  ir lil k mümkün oldu undan b zi
alqoritml r üçün daha uy un bir strukturdur.
Bu sinif daxilind vv lki v  sonrak  hallar il
laq dar eyni liyyat  yerin  yetir n simmetrik iki mr
r zaman mövcuddur.
void addAtHead(Object& obyekt);
void addAtTail(Object& obyekt);
Bu funksiyalar Collection üçün t yin edil n add
mri kimi icra olunur. Aralar ndak sas f rq,
addAtHeader obyekti siyah n vv lin lav  etdiyi
halda, addAtTail is  sonuna lav  edir.
void destroyFromHead(const Object& obyekt);
Bu funksiya siyah vv ld n ax ra q r gözd n
keçir k obyekt obyektin  b rab r olan tapd  ilk
obyekti siyah dan ç xar r v  yadda dan silir.
void destroyFromTail(const Object& obyekt);
Bu funksiya is  siyah  ax rdan vv  q r
gözd n keçir k tapd obyekt obyektin  b rab r  olan
ilk obyekti siyah dan ç xar r v  yadda dan silir.
void detachFromHead(const Object& obyekt, int tip = 0);
void detachFromTail(const Object& obyekt, int tip = 0);
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
267
Bu funksiyalar siyah  gözd n keçir k
(detachFromHead vv ld n ax ra q r, detachFormTail
ax rdan vv  q r) qar lar na ç xd  ilk obyekti
sad  siyah dan ç xar rlar. tip qiym tinin 0-dan f rqli
olmas  obyektin yadda dan silinm si  liyyat n da
eyni zamanda icra edilm sini, y ni bu mrl rin
destroyFromHead v  ya destroyFromTail funksiyalar na
uy un icra edilm sini t min edir.
Object peekAtHead() const;
siyah n vv lind ki,
Object peekAtTail() const;
is  siyah n sonundak  obyektin mü yy nl dirilm si
üçün istifad  edilir.
virtual ContainerIterator& initIterator() const;
Bu funksiya siyah  m lumatlar n siyah n vv lind n
ax na do ru,
virtual ContainerIterator& initReverseIterator() const;
is  siyah n ax ndan vv lin  do ru yenil nm sini
min edir.
Etibar Seyidzad
268
Collection üçün t yin edil n b zi funksiyalar
DoubleList üçün uy un olaraq icra olunurlar. Bu
funksiyalar n parametr siyah lar n eyni olmas na n r
yetirin.
Collection DoubleList
add addAtHeader
destroy destroyFromHead
detach detachFromHead
yin edil n dig r klassik funksiyalar v  onlar n
qiym tl ri is  a dak  kimidir:
Üzv funksiya Qiym ti
isA() doubleListClass
nameOf() “DoubleList”
hashValue() 0
8.5.9 HashTable
Collection sinfind n tör n HashTable onun
daxilind ki obyektl  daha tez müraci t edilm sini
min edir. Normal olaraq obyektl rin ist r massiv
daxilind , ist rs  d  siyah  strukturu daxilind
saxlan lmas ndan as  olmayaraq axtard z obyektin
yerini bilmiriks , obyekt kolleksiyas nda axtar lan
obyekt  müraci t ed  q r bütün obyektl  bir-bir
baxmaq laz m g lir. Bu da kolleksiyan n ba lan na
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
269
yax n obyektl rin axtar lmas nda vaxt bax ndan yax
tic  verm sin  baxmayaraq uzaq obyektl r üçün m nfi
tic  verir. Buna gör  d  ist nil n bir elem nt  müraci t
etm k üçün, bütün elementl ri gözd n keçirm k üçün
lumatlar strukturu t yin edilmi dir. HashTable bu
lumatlar strukturundan yaln z biridir. HashTable
lumatlar strukturunun i  qaydas Object sinfi
daxilind hashValue funksiyas rh ed rk n
göst rmi dik.
HashTable kolleksiyalar  daxilind ki obyektl r
hashValue funksiyalar n verdikl ri qiym tl  gör
qrupla r. Axtar  aparark n d  yaln z axtar lan
obyekt hashValue funksiyas  il  mü yy n edil n qrup
daxilind  axtar lacaqd r.
HashTable kolleksiyas n neç  qrupdan ibar t
olaca  proqramç  t find n bu kolleksiya t rtib
edil rk n mü yy n edilir. Buna gör  d HashTable
sinfinin layih ndiricisi
HashTable(sizeType grup_sayi =
DEFAULT_HASH_TABLE_SIZE);
klind  t yin edilmi dir. r
HashTable Memurlar(50);
Etibar Seyidzad
270
kimi bir Memurlar kolleksiyas  t rtib edil rs , bu
kolleksiya 50 qrupdan ibar t bir HashTable olacaqd r.
Yox r
HashTable Memurlar;
kimi t yin edil rs ,
DEFAULT_HASH_TABLE_SIZE
aktiv qiym tini istifad  ed kdir ki, bu qiym t d 111-
dir. Y ni 111 müxt lif qrupu olan Memurlar ad nda
HashTable kolleksiyas  yarad lacaqd r.
Layih ndirici xaricind ki funksiyalar Collection
daxilind  t yin edil n funksiyalard r v  eyni m nan
da rlar.
Üzv funksiya Qiym ti
isA() hashTableClass
nameOf() “HashTable”
hashValue() 0
8.5.10 Btree
Btree, Binary-Tree (ikilik a ac) üsulunun yadda
sinifl ri il  t tbiq edilm sidir. kilik a ac üsulunda
lumatlar sanki bir a ac üz rind  kökd n budaqlara
do ru yerl dirilirmi  kimi saxlan r. Bu üsulda yadda
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
271
daxilind  yerl diril k m lumatlar n öz aralar nda
ralanmas  laz md r. M lumatlar bir yarpaq kimidir v
budaqlar üz rind  yerl irl r. Budaqlarda yarpaq v  ya
qiym t budaqlar  yerl ir. Bu budaqlar üz rind
ralamaya gör  ard l (bir-birini t qib ed n) m lumatlar
yerl ir. Budaqlar da bir-birin  gör  ard l m lumat
qruplar ndan ibar t budaqlar klind  a ac üz rind
yerl irl r. Bel likl , m lumat  q sa müdd td  gözd n
keçirm kl  sür tli axtarmaq olar. M lumat yadda da
olmasa da, bütün m lumatlar gözd n keçirilm n bu
lumat n yadda da olub olmamas
mü yy nl dirm k olar.
Btree sinfi Collection sinfind n tör nmi  sinifdir.
Üzv funksiya Qiym ti
isA() btreeClass
nameOf() “Btree”
Btree sinfinin t yin edilmi  bir layih ndiricisi
vard r.
Btree(int Yarpaq_Sayi = 3);
Bu layih ndiriciy  parametr kimi normal olaraq
bir budaq üz rind  olmas  laz m g n Yarpaq_Say  daxil
edilir. Bu qiym t verilm dikd 3 olur. Budaq üz rind ki
yarpaqlar n say n az olmas  axtarma liyyat
sür tl ndirir. Lakin a ac üz rind ki budaqlar n say
Etibar Seyidzad
272
art r. Buna gör  d  m lumatlar artd qca axtarma
müdd ti d  art r. Yarpaqlar n say  çox oldu u zaman is
lumatlar n say n az olmas na baxmayaraq axtarma
müdd ti uzana bil r. Buna gör  d  yarpaqlar n say
lumat çoxlu unu n  alaraq mü yy nl dirm k
faydal r.
int order();
vv lc n yarad lm  bir a ac n budaqlar
üz rind  ola bil k yarpaqlar n say n
mü yy nl dirilm si üçün istifad  olunur. Geri qaytarma
qiym ti olaraq budaq üz rind  ola bil k yarpaq say
qaytar r.
virtual void add(Object& Obyekt);
Bu funksiya parametr kimi veril n Obyekt
obyektinin a ac üz rind  yerl dirilm sini t min edir.
Burada a ac üz rind ki m lumatlar n s ralana bil n
obyekt olduqlar  n  alaraq Obyekt obyektinin
Sortable sinfind n tör nmi  sinfin obyekti olmas na
diqq t etm k laz md r.
Object& operator[ ](long Index) const;
ac daxilind  yerl n obyektl r a ac üz rind
kiçikd n böyüy  do ru s ralanm  olurlar. lk s ra
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
273
nömr si 0 olamaqla ist nil n s radak  obyektin
öyr nilm si üçün [  ] operatorundan istifad  etm k olar.
Bunun üçün Btree sinfinin obyektl rinin h r birini massiv
olaraq dü ünm k v  istifad  etm k mümkündür.
Btree Stock;
...
cout<<”en kicik element = “<<Stock[0]<<”dir\n”;
kimi. Yaln z [  ] operatoru vasit sil  h r hans  bir s raya
obyekt m nims dil  bilm z. Bu operator sad  ist nil n
radak  elementin öyr nilm sini t min edir.
long rank(const Object& Obyekt) const;
Btree a ac  daxilind  oldu u m lum olan obyektin
ac n hans  s ras nda oldu unu öyr nm k üçün rank
funksiyas ndan istifad  etm k olar.
Collection, Container v Object sinifl ri üçün t yin
edilmi  dig r funksiyalar Btree daxilind  eyni m qs dl
istifad  etm k olar.
//BTREE.CPP
#include <sortable.h>
#define integerClass 300
class Integer : public Sortable
{  int _integer;
Etibar Seyidzad
274
   public:
     Integer(int = 0);
     char* nameOf() const;
     classType isA() const;
     hashValueType hashValue() const;
     int isEqual(const Object&) const;
     int isLessThan(const Object&) const;
     void printOn(ostream&) const;
};
Integer::Integer(int x)
{  _integer = x;  }
char* Integer::nameOf() const
{  return "Integer";  }
classType Integer::isA() const
{  return integerClass;  }
hashValueType Integer::hashValue() const
{  return _integer;  }
int Integer::isEqual(const Object& object) const
{  return _integer == ((Integer&)object)._integer;  }
int Integer::isLessThan(const Object& object) const
{  return _integer<((Integer&)object)._integer;  }
void Integer::printOn(ostream& stream) const
{  stream<<_integer;  }
//**************************************************
#include <conio.h>
#include <btree.h>
#include <stdlib.h>
#include <stdio.h>
#include <ltime.h>
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
275
Btree Stock(15);
main()
{  clrscr();
   int i;
   char buffer[120];
   for(i = 0; i < 2500; i++)
      Stock.add(* new Integer(random(3000)));
   cout<<"\nStokta axtardiginiz nomreleri daxil edin\n"
 "bitirmek ucun SON yazin\n";
   while(!cin.rdstate())
   {  int X;
      cin>>X;
      if(cin.rdstate())
break;
      Integer Find(X);
      cout<<"Axtarisa baslama saati  : "<<Time()<<endl;
      cout<<Find<<" Stokda"<<(Stock.hasMember(Find) ?
  " Movcuddur" : " Mevcud deyil")<<endl;
      cout<<"Axtarisin bitmesi saati : "<<Time()<<endl;
   }
   cin.clear();
   cin>>ws>>buffer;
   cout<<"Rank qiymetini oyrenmek ucun "
 "nomreleri daxil edin\nbitirmek ucun SON yazin\n";
   while(!cin.rdstate())
   {  int X;
      cin>>X;
      if(cin.rdstate())
break;
      Integer Find(X);
      cout<<"Rank("<<Find<<") = "<<Stock.rank(Find)<<endl;
   }
   cin.clear();
   cin>>ws>>buffer;
Etibar Seyidzad
276
   cout<<"Oyrenmek istediyiniz melumatin"
 " sira nomresini daxil edin\n"
 "bitirmek ucun SON yazin\n";
   while(!cin.rdstate())
   {  int X;
      cin>>X;
      if(cin.rdstate())
break;
      cout<<'#'<<X<<"-->"<<Stock[X]<<endl;
   }
   cin.clear();
   cin>>ws>>buffer;
   return 0;
}
Proqram ç
Stokta axtardiginiz nomreleri daxil edin
bitirmek ucun SON yazin
50 200 700 3000 122 son
Axtarisa baslama saati  : 8:57:25.10 pm
50 Stokda Movcuddur
Axtarisin bitmesi saati   : 8:57:25.10 pm
Axtarisa baslama saati  : 8:57:25.10 pm
200 Stokda Mevcud deyil
Axtarisin bitmesi saati   : 8:57:25.10 pm
Axtarisa baslama saati  : 8:57:25.10 pm
700 Stokda Mevcud deyil
Axtarisin bitmesi saati   : 8:57:25.10 pm
Axtarisa baslama saati  : 8:57:25.10 pm
3000 Stokda Mevcud deyil
Axtarisin bitmesi saati   : 8:57:25.10 pm
Axtarisa baslama saati  : 8:57:25.10 pm
122 Stokda Mevcuddur
Axtarisin bitmesi saati   : 8:57:25.10 pm
Rank qiymetini oyrenmek ucun nomreleri daxil edin
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
277
bitirmek ucun SON yazin
50 200 3 son
Rank(50) = 44
Rank(200) = 177
Rank(3) = 2
Oyrenmek istediyiniz melumatin sira nomresini daxil edin
bitirmek ucun SON yazin
0 1 2 2499 2500 son
#0 --> 1
#1 --> 2
#2 --> 3
#2499 --> 2997
#2500 --> Error
8.5.11 Bag
Mü yy n m qs dl  gör  bir-birin  b rab r olan
obyektl rin m lumatlar strukturu daxilind  olmas na
icaz  veril  v  ya verilm  bil r. ndiy  q r gözd n
keçirdiyimiz sinifl rin ham  kimi Collection sinfind n
tör nmi Bag sinfi d  buna icaz  verir. Set v Dictionary
sinifl ri is  icaz  vermirl r. Bag sinfinin HashTable
sinfin  ox ar layih ndiricisi vard r. Eyni m ntiql
yir. Sad  aktiv qiym ti f rql nir.
Bag(sizeType qrup_say  = DEFAULT_ BAG_SIZE);
DEFAULT_BAG_SIZE parametrinin standart t yin
olunmu  qiym ti 29-dur.
Üzv funksiya Qiym ti
Etibar Seyidzad
278
isA() bagClass
nameOf() “Bag”
8.5.12 Set
Set sinfi Bag sinfind n tör nmi  bir sinif kimi
ondan f rqli olaraq bir obyektin Collection daxilind
yaln z bir d  olmas na icaz  verir. Ekvivalenti
kolleksiya daxilind  olan obyekti kolleksiyaya q bul
etmir. Bag il  eyni layih ndiriciy  malikdir. Yaln z
aktiv qiym ti f rqlidir.
Set(sizeType qrup_say  = DEFAULT_ SET_SIZE);
DEFAULT_SET_SIZE parametrinin standart t yin
olunmu  qiym ti 29-dur.
Üzv funksiya Qiym ti
isA() setClass
nameOf() “Set”
8.5.13 Dictionary
Dictionary (Lü t) axtar a gör  m lumat
kolleksiyas  daxilind  bir obyekt tap b bu obyektd n
daha çox m lumat ld  etm  üsuludur. M n, bir
xsin  ad  göst k  o  xsin  soyad,  do um  yeri,
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
279
do um tarixi kimi dig r m lumatlar n da
öyr nilm sidir. Bunun n klassik t tbiqi lü td  öz ksini
tap r. Bir söz  uy un g n o sözün verdiyi m nalar v  ya
dig r dill rd ki m nalar  tap b mü yy nl dirilir.
Dictionary Set sinfind n tör n Association
sinfind n tör nmi  obyektl rin daxilind  ola bil k
xüsusi bir kolleksiya növüdür.
Dictionary sinfinin üzv funksiyalar Collection sinfi
daxilind rh etdiyimiz üzv funksiyalar r. Eyni
prototipl rinin olmas na baxmayaraq bu funksiyalardak
obyekt parametrl rin  uy un obyekt olaraq Association
sinfind n tör nmi  obyektl r istifad  edil  bil r.
Üzv funksiya Qiym ti
isA() dictionaryClass
nameOf() “Dictionary”
8.5.14 AbstractArray
AbstractArray xüsusil  d  bütün proqramla rma
dill rin  daxil oldu una gör  çox istifad  edil n
lumatlar strukturu tipli massivl rdir. Container Class
kitabxanas  daxilind  ümumi m qs dli iki sinif t yin
edilmi dir. Bunlar ümumi m qs dli massivl r üçün Array
 s ralanm  obyektl r üçün SortedArray sinifl ridir.
Etibar Seyidzad
280
AbstractArray is Collection sinfind n tör n v  bu iki
sinf  baza yaradan müc rr d bir sinifdir.
vv lc  massiv anlay  ayd nla raq. Massiv
eyni tipli elementl rin kolleksiyas r. Elementl r massiv
daxilind  ard l yerl ir v  h r bir elementin s ra
nömr si olur ki, buna da elementin indeksi deyilir. H r
hans  bir element  bu indeksl  müraci t edilir. ndeksl r
1 v  ya 0-dan  ba lay r.  Üst  s rh d  is  proqramç
find n t yin olunur v  bu s rh ddi keçm k olmaz.
Container Class kitabxanas  daxilind  t yin
olunmu  massiv  sinifl ri  üçün  d  ox ar  qaydalar
qüvv dir.
dak  f rql r vard r:
Massivl r daxilind Object sinfind n tör nmi
bütün obyektl r ola bil r;
Alt v  üst s rh dl r proqramç  t find n t yin
edil  bil r;
Massivin elementl rinin say  kifay t etm zs , o
geni ndiril  bil r;
Qiym ti verilm n elementl r NOOBJECT kimi
bul edilir.
Massivl r üçün AbstractArray sinfi daxilind  t yin
edil n funksiyalar a dak lard r:
int lowerBound() const;
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
281
Bu funksiya massivin alt s rh ddini geri qaytarma
qiym ti kimi qaytar r. Bu, massiv daxilind  olan ilk
qiym tin s ra nömr sidir.
int upperBound() const;
Massivin üst s rh ddini geri qaytarma qiym ti kimi
qaytar r. Bu, massiv daxilind  olan son qiym tin s ra
nömr sidir.
sizeType arraySize() const;
Bu funksiya massiv daxilind ki elementl rin say
mü yy nl dirir. getItemsInContainer funksiyas ndan bu
xüsusiyy ti il  f rql nir. getItemsInContainer kolleksiya
daxilind  olan elementl rin say  mü yy nl dirir.
virtual void detach(int indeks, int tip = 0);
Bu funksiya indeks il  yeri veril n obyekti massiv
daxilind  oldu u zaman massivd n xaric edir. tip
parametrinin qiym ti 0-dan f rqlidirs , obyekti
massivd n xaric etm kl  b rab r onu yadda dan da silir.
void destroy(int indeks);
Etibar Seyidzad
282
Bu funksiya is indeks il  yeri veril n obyekti
massiv daxilind  oldu u zaman massivd n xaric edir v
sonra bu obyekti yadda dan silir.
virtual int isEqual(const Object& Obyekt) const;
Massivl r üçün yenid n t yin edil n bu funksiya
dig r sinifl rd  oldu u kimi müqayis  edil n h r iki
massivin  eyni  s rada  v  bir-birin  b rab r  olan
obyektl rinin olmas rtini qoyur. Bundan ba qa
massivl rin alt v  üst s rh dl ri b rab r olaml r.
virtual void PrintOn(ostream& Stream) const;
Massiv daxilind ki obyektl rin ax na yaz lmas  t b
olunarsa, printOn funksiyas  v  ya “<<” operatoru istifad
edilir. Bunlar n istifad  olunmas  n tic sind  massiv
daxilind ki obyektl r ax na yaz r, qiym ti verilm mi
elementl r is  “error” m saj  il ks olunur (bo
elementl Error sinfinin obyekti olan NOOBJECT
nims dilir). r buna ehtiyac olmazsa, y ni yaln z
qiqi obyektl rin göst rilm si t b olunarsa,
virtual printContainerOn(ostream& Obyekt) const;
üzv funksiyas ndan istifad  etm k olar.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
283
8.5.15 Array
Array sinfi ümumi m qs dl r üçün istifad  olunan
bir sinifdir. AbstractArray sinfind n tör nmi dir. Array
sinfinin obyekti olan massivl Object sinfind n
tör nmi  bütün sinifl rin obyektl rini yerl dirm k
mümkündür. Yerl diril n h r element yerl diyi yerd
qal r.
Bu sinfin layih ndiricisi a dak  kimi t yin
edilm dir:
Array(int Ust, int Alt = 0, sizeType Delta = 0);
Burada ilk parametr olan Ust massivin n böyük
indeksini göst rir. Bu qiym t mütl q verilm lidir. kinci
parametr olan Alt is  massivin n kiçik indeksini göst rir.
Bu qiym t verilm zs , avtomatik olaraq 0 q bul edilir.
Üçüncü parametr olan Delta is  massiv add üzv
funksiyas  il  element yerl dirildiyi zaman bo  yer
olmazsa, massivin üst s rh ddinin n  q r
geni ndiril yini göst rir. Bu qiym t d  verilm zs , 0
oldu u, y ni bel  bir halda h r hans  bir geni nm nin
olmayaca  göst rir.
Qeyd edildiyi kimi massiv  obyekt lav  etm k
üçün
virtual void add(Object& Obyekt);
Etibar Seyidzad
284
üzv funksiyas  istifad  edilir. Bu funksiya Obyekt
obyektini massiv daxilind ki ilk bo  yer  yerl dirir. Bo
yer olmazsa, massiv layih ndirm  zaman  mü yy n
edil n miqdarda geni ndirilir. Geni nm  olmazsa,
hv ba  verir. Massiv lav  edil n obyektl rin massiv
daxilnd  hans  s rada yerl yi yen  bu funksiya il
mü yy n edilir. r yerl yi yerin d  göst rilm si
b olunarsa,
void addAt(Object& Obyekt, int Indeks);
üzv  funksiyas ndan  istifad  etm k  laz md r.  Bu  halda
Obyekt Indeks il  veril n yer  yerl dirilir. Yerl dirm
liyyat ndan vv l yerl diril k yerd  ba qa bir
obyekt olarsa, bu obyekt massivd n ç xar r v r silin
bil rs , silinir.
Massiv daxilind  bir obyekti findMember üzv
funksiyas  il  axtarmaq olar. r yeri m lumdursa,
Object& operator[ ](int Indeks) const;
operator funksiyas  istifad  edil  bil r. M n, bir
massivin 5-ci elementin  müraci t etm k üçün
Object& Obyekt = mas[5];
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
285
 ya ekrana ç xarmaq üçün
cout<<mas[5]<<endl;
trini yazmaq olar.
Dig r funksiyalar n geri qaytarma qiym tl ri is
dak lard r:
Üzv funksiya Qiym ti
isA() arrayClass
nameOf() “Array”
8.5.16 SortedArray
SortedArray sas n massivdir. Lakin Array sinfind n
rqli olaraq elementl rini kiçikd n böyüy  do ru
ralanm kild  saxlay r. Buna gör  d  ancaq Sortable
sinfind n tör n sinifl rin obyektl rini t rkibind
saxlay r. SortedArray massivl ri daxilind  olan obyektl r
ralanm kild  massivin vv lind  yerl irl r. lav
edili n h r obyekt s ralamadak  uy un yerd  yerl dirilir.
Bu liyyat massivin daxilind ki dig r obyektl r
sürü dürül k yerin  yetirilir. Bir obyekt massivd n
xar ld qdan sonra  g n bo lu u doldurmaq
üçün obyektl r bu d  d ks istiqam td  sürü dürülür.
Etibar Seyidzad
286
Bu sinfin layih ndiricisi d Array sinfinin
layih ndiricisi kimi t yin edilmi dir.
SortedArray(int Ust, int Alt = 0, sizeType Delta = 0);
Parametrl r Array sinfinin layih ndiricisinin
parametrl ri il  eyni funksiyalara malikdirl r. Ust
massivin n böyük, Alt is n kiçik indeksi, Delta is
kifay t q r yer olmad  zaman geni nm  miqdar
göst rir.
Dig r funksiyalar n geri qaytarma qiym tl ri
dak lard r:
Üzv funksiya Qiym ti
isA() sortedArrayClass
nameOf() “Array”
Bu sinifd  yeri b lli olan bir obyekt üçün
const Sortable& operator[ ](int Indeks) const;
operator funksiyas ndan istifad  etm k olar.
Bir diskd ki aktiv qovluqda olan fayllar n
geni nm rinin siyah n görünm sin  aid bir
proqram t rtib ed k.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
287
//EXT.CPP
#include <clsdefs.h>
#include <sortable.h>
#include <sortarry.h>
#include <set.h>
#include <dir.h>
#include <dos.h>
#include <string.h>
#include <iomanip.h>
#include <conio.h>
class NameExt : public Sortable
{  char ext[4];
   public:
     NameExt();
     NameExt(const NameExt&);
     NameExt(char *n);
     classType isA() const;
     char* nameOf() const;
     hashValueType hashValue() const;
     int isEqual(const Object&) const;
     int isLessThan(const Object&) const;
     void printOn(ostream&) const;
};
NameExt::NameExt()
{  ext[0] ='\0';  }
NameExt::NameExt(const NameExt& O)
{  strcpy(ext,O.ext);  }
NameExt::NameExt(char *n)
{  strcpy(ext, n);  }
classType NameExt::isA() const
{  return __firstUserClass;  }
Etibar Seyidzad
288
char* NameExt::nameOf() const
{  return "File Name Extention";  }
hashValueType NameExt::hashValue() const
{  return (ext[0] == '\0' || ext[0] == ' ') ? 0 : ext[0] - 64;  }
int NameExt::isEqual(const Object& Test) const
{  return strcmp(ext, ((NameExt&)Test).ext) == 0;  }
int NameExt::isLessThan(const Object& Test) const
{  return strcmp(ext, ((NameExt&)Test).ext) < 0;  }
void NameExt::printOn(ostream& Stream) const
{  Stream<<'\"'<<setw(3)<<setiosflags(ios::left)<<ext<<'\"';  }
//***********************************************************
class Extension : public Set
{  int sta;
   public:
     Extension(int);
     void printHeader(ostream&) const;
     void printSeparator(ostream& ) const;
     void printTrailer(ostream&) const;
};
Extension::Extension(int _sta) : Set(26)
{  sta = _sta;  }
void Extension::printHeader(ostream& Stream) const
{  Stream<<"Genislenme siyahisi"<<endl<<endl;  }
void Extension::printSeparator(ostream& Stream) const
{  if(sta)
     Stream<<'\t';
   else Stream<<'\n';
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
289
void Extension::printTrailer(ostream& Stream) const
{  Stream<<endl;  }
//********************************************************
Extension ExtList(1);
void scan(char *s)
{  struct ffblk SF;
   int Ok;
   Ok = findfirst(s, &SF, FA_ARCH);
   while(Ok == 0)
   {  char *p = strchr(SF.ff_name, '.');
      NameExt* N = new NameExt((p == NULL) ? " " : p + 1);
      ExtList.add(*N);
      Ok = findnext(&SF);
   }
}
//*********************************************************
main(int c, char *a[])
{  clrscr();
   char match[MAXDIR];
   if(c > 1)
   {  strcpy(match, a[1]);
      if(strchr(match, '.') == NULL)
strcat(match, ".*");
   }
   else strcpy(match, "*.*");
   scan(match);
   if(ExtList.isEmpty())
   cout<<"Verilen genislenmeli fayl yoxdur.";
   else cout<<ExtList<<"\nCemi "
    <<ExtList.getItemsInContainer()
Etibar Seyidzad
290
    <<" eded genislenme var";
   return 0;
}
Proqram ç
Genislenme siyahisi
"BAT" "BAK" "CSM" "386" "CFG" "COM" "CPP" "DAT"
"DFM" "DSK"
"DPR" "DOS" "DIF" "DLL" "ERR" "EXE" FIL"" "FON" "H
" "HLP"
"ILD" "ILC" "ILF" "ILS" "INI" "ICO" "MAK" "OVL"
"OBJ" "PIF"
"SYM" "SWP" "SYS" "TDS" "TXT" "TC  " "TAH" "TCH"
"TFH" "TDH"
Cemi 40 eded genislenme var
8.6 Yenil yicil r (Iterators)
Yenil yicil r Container sinfind n tör nmi  sinifl rin
obyektl ri üz rind  göst rici kimi i k, bu
obyektl  h r hans  bir z r verm n, yadda
xüsusiyy tin  malik olan obyektl r daxilind ki
obyektl  bir-bir müraci t edilm sini t min edirl r.
Yenil yici sinifl rinin h r biri ContainerIterator sinfind n
tör nmi dir.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
291
Müxt lif yadda  tipl ri üçün t yin olunmu
yenil yicil r ümumi xüsusiyy tl  malikdirl r.
Yaln z DoubleListIterator sinfinin lav  bir
xüsusiyy ti vard r.
Yenil yicinin layih ndirilm si üçün h r yenil yici
bir layih ndiriciy  sahib olmaqla b rab r, yenil
liyyat n yerin  yetiril yi yadda  obyektinin
vitual ContainerIterator& initIterator() const;
kimi t yin edilmi  üzv funksiyas ndan istifad  etm k
qs uy undur. M n, S Stack strukturu üz rind
yenil liyyat  aparacaq I yenil yicisini
ContainerIterator& I = S.initIterator();
klind  t yin  etm k  olar.  Lakin  burada  qeyd  etm k
laz md r ki, initIterator() üzv funksiyas new operatoru il
ContainerIterator
HashTableIterator
BtreeIterator
ListIterator
DoubleListIterator
ArrayIterator
Etibar Seyidzad
292
yarad ld  üçün yenil yici il  i imizi tamamlad qdan
sonra delete operatoru il  onu silm k laz md r.
delete &I;
Yenil yicil r üçün t yin edilmi  ortaq funksiyalar
dak lard r:
virtual operator int();
Yenil yicini int tipli bir  çevirm k laz m
rs , onun yadda  sinfi üz rind  yenil yi ba qa
obyektin qal b qalmayaca  sual  ortaya ç r. N tic
rd rsa, yenil k obyekt qalm r, s rdan f rqlidirs ,
yenil k dig r obyektl rin d  oldu u b lli olur.
virtual Object& operator++();
virtual Object& operator++(int);
Bu operator is  yenil yicinin göst rdiyi obyekti geri
qaytarma qiym ti kimi qaytard qdan sonra onun yadda
daxilind  növb ti obyekti göst rm sini t min edir.
virtual operator Object&();
Bu operator is  yenil yicinin göst rdiyi obyektin
öyr nilm sini t min edir. Ba qa bir liyyat  yerin
yetirm z.
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
293
virtual void restart();
Bu funksiya yenil yicinin yadda  daxilind  ilk
obyekti göst rm sini t min edir. Bel likl , yadda  üçün
yeni bir obyekt t yin edilm n yadda  daxilind ki
obyektl r yenid n gözd n keçiril  bil r.
8.6.1 DoubleListIterator
DoubleListIterator DoubleList sinfi üz rind
yenil liyyat  yerin  yetirm k üçün
layih ndirilmi dir. DoubleList sinfi m lumatlar  bir-biri
il  h m ir liy , h m d  geriy  do ru laq ndirdiyi üçün
DoubleListIterator yenil yicisi il  uy un istiqam tl rd
getm k mümkündür.
Bunun üçün ++ operatoruna ox ar olaraq bu sinif
üçün -- operatoru da t yin edilmi dir.
virtual Object& operator--();
virtual Object& operator--(int);
Bu operatorlar yenil yicinin göst rdiyi obyekti geri
qaytararaq, onun vv lki obyekti göst rm sini t min
edirl r.
Etibar Seyidzad
294
8.7 Misal
Ekran üz rind  müxt lif böc kl r vard r. Bu
böc kl rin davran lar  müxt lifdir. M n, b zil ri
ekran k rlar na toxunduqlar  zaman geri qay daraq
yollar na davam edirl r. B zil ri is  bir k nardan ç b
dig r k nardan gir k yollar na davam edirl r. Bir böc k
is  klaviatura düym rinin s lmas  il  veril n mrl rl
(ox düym rin  s xaraq) h t etdirilir. Oyunun
qs di d  bu böc kl ri ekrandan t mizl kdir.
//CCDEMO.CPP
#include <queue.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
#define SCREENWIDTH 79
#define SCREENHEIGHT 24
#define WAITTIME 150
#define KB_HOME 71
#define KB_TOP 72
#define KB_PGUP 73
#define KB_LEFT 75
#define KB_RIGHT 77
#define KB_END 79
#define KB_BOTTOM 80
#define KB_PGDN 81
class Bocek;
   //Bocek adli sinfin daha sonra teyin edileceyini bildirir
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
295
Queue Bocekler;
   //Boceklerin siyahisi
Bocek* Canavar;
   //Bocek sinfinin yalniz gostericisi istifade oluna biler
//********************* Bocek Sinfi ***********************//
class Bocek : public Object
{  protected:
     int type; //Bocegin tipi
     int x, y; //Bocegin yeri
     int u, v; //Bocegin sur'etleri
   public:
     Bocek();
     Bocek(int, int, int, int, int);
     virtual ~Bocek();
     virtual char* nameOf() const
     {  return "Bocek";  }
     virtual classType isA() const
     {  return 12000;  }
     virtual hashValueType hashValue() const
     {  return type;  }
     virtual void printOn(ostream&) const;
     virtual int isEqual(const Object&) const;
     virtual void toxunma(Bocek&);
//Parametr ile verilen bocege toxunmas
//neticesinde cagrilacaq uzv funksiya
     virtual void solSerhed();
     virtual void sagSerhed();
Etibar Seyidzad
296
     virtual void ustSerhed();
     virtual void altSerhed();
//Ekran serhedlerine toxundu u zaman
//cagirilacaq uzv funksiyalar
     virtual void sicra();
//Hereket vaxti geldiyi zaman
//hereketi temin eden uzv funksiya
     void oldun();
//Bir boceyin basqa birine toxunmas  zamani
//olmesi halinda cagirilacaq uzv funksiya
     int olumu();
//Bir boceyin olu olub olmadigini anlamaq
//ucun istifade edilecek uzv funksiya
   protected:
     virtual void nezaret();
//Bocegin ekran serhedlerine catib catmadigina
//ve diger boceklere toxunub toxunmadigina
//nezaret edecek funksiya
     virtual void sil();
//Bocegi ekrandan silecek funksiya
     virtual void cek();
//Bocegi ekranda cekecek funksiya
   private:
     int oldx, oldy;
//Bocegin evvelki yeri
};
Bocek::Bocek()
{  type = '*';
   oldx = oldy = x = y = u = v = 1;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
297
Bocek::Bocek(int _t, int _x, int _y, int _u, int _v)
{  type = _t;
   oldx = x = _x;
   oldy = y = _y;
   u = _u;
   v = _v;
}
Bocek::~Bocek()
{  }
void Bocek::printOn(ostream& Stream) const
{  Stream<<nameOf()<<"Tip : "<<type;
   Stream<<" Yer : "<<x<<", "<<y;
   Stream<<" Addim : "<<u<<", "<<v;
}
int Bocek::isEqual(const Object& Test) const
{  return type == ((Bocek&)Test).type &&
   x == ((Bocek&)Test).x &&
   y == ((Bocek&)Test).y &&
   u == ((Bocek&)Test).u &&
   v == ((Bocek&)Test).v;
}
void Bocek:: toxunma(Bocek& B)
{  if(B == *Canavar)
     oldun();
   else
   {  u = -u;
      v = -v;
      B.u = -B.u;
      B.v = -B.v;
      if(type == B.type && Bocekler.getItemsInContainer() < 20)
Bocekler.put(*new Bocek(type, x * 2, y * 2, -u, -v));
   }
}
void Bocek::solSerhed()
Etibar Seyidzad
298
{  x = SCREENWIDTH;  }
void Bocek::sagSerhed()
{  x = 1;  }
void Bocek::ustSerhed()
{  y = SCREENHEIGHT;  }
void Bocek::altSerhed()
{  y = 1;  }
void Bocek::sicra()
{  sil();
   x+= u;
   y+= v;
   nezaret();
   cek();
}
void Bocek::nezaret()
{  if(x <= 1)
     solSerhed();
   else if(x >= SCREENWIDTH)
  sagSerhed();
   if(y <= 1)
     ustSerhed();
   else if(y >= SCREENHEIGHT)
  altSerhed();
   ContainerIterator& Iter = Bocekler.initIterator();
   while(int(Iter))
   {  Bocek* Item = (Bocek*) & (Iter++);
      if(Item->x == x && Item->y == y)
toxunma(*Item);
   }
   delete &Iter;
}
void Bocek::sil()
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
299
{  gotoxy(oldx, oldy);
   putchar(' ');
}
void Bocek::cek()
{  gotoxy(x, y);
   putchar(type);
   oldx = x;
   oldy = y;
}
void Bocek::oldun()
{  u = v =0;
   sil();
}
int Bocek::olumu()
{  return u == 0 && v == 0;  }
//***************** KenarBocek Sinfi *******************//
//Bir kenardan cixib diger kenardan giren bocek tipi  //
class KenarBocek : public Bocek
{  public:
     KenarBocek() : Bocek()
     { }
     KenarBocek(int a, int b, int c, int d, int e)
     : Bocek(a, b, c, d, e)
     {  }
     virtual void toxunma(Bocek&);
     virtual void solSerhed();
     virtual void sagSerhed();
     virtual void ustSerhed();
     virtual void altSerhed();
};
void KenarBocek::carpdin(Bocek& B)
Etibar Seyidzad
300
{  if(B == *Canavar)
     oldun();
   else if(Bocekler.getItemsInContainer() < 20)
  Bocekler.put(*new KenarBocek(type, x + 1, y, -u, -v));
}
void KenarBocek::solSerhed()
{  u = 1;  }
void KenarBocek::sagSerhed()
{  u = -1;  }
void KenarBocek::ustSerhed()
{  v = 1;  }
void KenarBocek::altSerhed()
{  v = -1;  }
//********************* NezaretBocek Sinfi **********************
//Oyuncunun ox duymeleri ile hereket etdirdiyi bocek  //
class NezaretBocek : public Bocek
{  public:
     NezaretBocek() : Bocek()
     {  u = v = 1;  }
     NezaretBocek(int a, int b, int c)
     : Bocek(a, b, c, 1, 1)
     {  }
     virtual void toxunma(Bocek&);
     virtual void solSerhed();
     virtual void sagSerhed();
     virtual void ustSerhed();
     virtual void altSerhed();
     virtual void sicra();
};
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
301
void NezaretBocek:: toxunma(Bocek& B)
{  if(B == *Canavar)
     return;
   B.oldun();
}
void NezaretBocek::solSerhed()
{  x = 1;  }
void NezaretBocek::sagSerhed()
{  x = SCREENWIDTH;  }
void NezaretBocek::ustSerhed()
{  y = 1;  }
void NezaretBocek::altSerhed()
{  y = SCREENHEIGHT;  }
void NezaretBocek::sicra()
{  if(kbhit())
   {  int ch = getch();
      if(ch == 27 || ch == 3)
exit(1);
      if(ch == 0)
      {  ch = getch();
 switch(ch)
 {  case KB_HOME   : y--;
    case KB_LEFT   : x--; break;
    case KB_PGDN   : y++;
    case KB_RIGHT  : x++; break;
    case KB_PGUP   : x++;
    case KB_TOP    : y--; break;
    case KB_END    : x--;
    case KB_BOTTOM : y++; break;
 }
 sil();
 nezaret();
      }
Etibar Seyidzad
302
   }
   cek();
}
//*********************** Ana Proqram ********************//
//Proqrami icra eden, ardicil olaraq butun boceklere mesaj
//gonderen alt proqram
void Run()
{  Bocek* Item;
   int i;
   while(*(Item = (Bocek*)&Bocekler.get()) != NOOBJECT)
   {  if(Item->olumu())
      {  delete Item;
 continue;
      }
      Item->sicra();
      Bocekler.put(*Item);
      for(i = 0; i < WAITTIME; i++)
 Canavar->sicra();
      if(Bocekler.getItemsInContainer() <= 1)
      {  clrscr();
 gotoxy(20, 12);
 cprintf("\a\aOyun Bitdi");
 gotoxy(20, 14);
 cprintf("Her hansi bir duymeni sixin");
 getch();
 while(kbhit())
      getch();
 break;
      }
   }
}
//Proqramdan cixarken istifade olunan altproqram
void Cix()
{  clrscr();
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
CLASS K TABXANASI
303
   _setcursortype(_NORMALCURSOR);
}
//Proqramin baslamasi ucun qurmaq
main()
{  int i;
//Boceklerin yaradilmasi
   for(i = 0; i < 6; i++)
      Bocekler.put(*new Bocek('&', i + 10, 15, -1, 1));
//KenarBoceklerin yaradilmasi
   for(i = 0; i < 6; i++)
      Bocekler.put(*new KenarBocek('*', i + 30, i + 5, 1, 1));
//Oyuncunun nezaret edecegi bocegin yaradilmasi
   Canavar = new NezaretBocek('#', SCREENWIDTH / 2,
   SCREENHEIGHT / 2);
   Bocekler.put(*Canavar);
//Ekran gorunusunun hazirlanmasi
   clrscr();
   _setcursortype(_NOCURSOR);
//Cixis funksiyasinin menimsedilmesi
   atexit(Cix);
//Oyunun baslanmasi
   Run();
//Oyundan normal cixis
Etibar Seyidzad
304
   return 0;
}
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
Cl
ick
 he
re 
to 
bu
y
A
BB
YY
PDF
Transformer 2.0
www.ABBYY.c
om
